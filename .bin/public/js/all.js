(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],2:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],5:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":3,"./encode":4}],6:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function about(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/about.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/about.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/about.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/about.jade" });
buf.push("<h1 id=\"why-taunus-\">Why Taunus?</h1>\n<p>Taunus focuses on delivering a progressively enhanced experience to the end-user, while providing <em>a reasonable development experience</em> as well. <strong>Taunus prioritizes content</strong>. It uses server-side rendering to get content to your humans as fast as possible, and it uses client-side rendering to improve their experience.</p>\n<p>While it focuses on progressive enhancement, <strong><a href=\"http://ponyfoo.com/articles/adjusting-ux-for-humans\">usability</a> and performance are both core concerns</strong> for Taunus. Incidentally, focusing on progressive enhancement also improves both of these. Usability is improved because the experience is gradually improved, meaning that if somewhere along the line a feature is missing, the component is <strong>still expected to work</strong>.</p>\n<p>For example, a progressively enhanced site uses plain-old links to navigate from one view to another, and then adds a <code>click</code> event handler that blocks navigation and issues an AJAX request instead. If JavaScript fails to load, perhaps the experience might stay a little bit worse, but that&#39;s okay, because we acknowledge that <strong>our sites don&#39;t need to look and behave the same on every browser</strong>. Similarly, <a href=\"http://ponyfoo.com/articles/critical-path-performance-optimization\">performance is greatly enhanced</a> by delivering content to the human as fast as possible, and then adding functionality on top of that.</p>\n<p>With progressive enhancement, if the functionality never gets there because a JavaScript resource failed to load because the network failed <em>(not uncommon in the mobile era)</em> or because the user blocked JavaScript, your application will still work!</p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.unshift({ lineno: 3, filename: "views/documentation/about.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 4, filename: "views/documentation/about.jade" });
buf.push("<h1 id=\"why-not-other-frameworks-\">Why Not Other Frameworks?</h1>\n<p>Many other frameworks weren&#39;t designed with progressive enhancement, or even shared-rendering in mind. Content isn&#39;t prioritized, and humans are expected to <a href=\"http://ponyfoo.com/articles/stop-breaking-the-web\">download most of a web page before they can see any digestible content</a>. While Google is going to resolve the SEO issues with dedicated client-side rendering soon, that won&#39;t solve all your problems. Google isn&#39;t the only web crawler operator out there, and it might be a while before social media link crawlers catch up with them. Even if crawlers are not an issue, being able to provide the fastest possible experience is a big problem to resolve.</p>\n<p>Lately, many mature open-source frameworks started dropping support for older browsers. This is necessary because of the way they&#39;re architected, where the developer is put first. <strong>Taunus is <a href=\"https://twitter.com/hashtag/humanfirst\">#humanfirst</a></strong>, meaning that it concedes that humans are more important than the developers building their applications.</p>\n<p>Progressively enhanced applications are always going to have great browser support because of the way they&#39;re architected. As the name implies, a baseline is established where we deliver the core experience to the user <em>(typically in the form of readable HTML content)</em>, and then enhance it <strong>if possible</strong> using CSS and JavaScript. Building applications in this way means that <strong>you&#39;ll be able to reach the most people with your core experience</strong>, and you&#39;ll also be able to provide humans in more modern browsers with all of the latest features and technologies.</p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.unshift({ lineno: 5, filename: "views/documentation/about.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 6, filename: "views/documentation/about.jade" });
buf.push("<h1 id=\"features\">Features</h1>\n<p>Out of the box, Taunus ensures that your site works on any HTML-enabled document viewer, or even on the terminal, providing support for plain text responses <a href=\"/getting-started\">without any configuration needed</a>. Even while Taunus provides shared-rendering capabilities, it offers code reuse of views and routes, meaning you&#39;ll only have to declare these once but they&#39;ll be used in both the server-side and the client-side.</p>\n<p>Taunus features a reasonably enhanced experience, where if features aren&#39;t available on a browser, they&#39;re just not provided. For example, the client-side router makes use of the <code>history</code> API but if that&#39;s not available then it&#39;ll fall back to simply not meddling with links instead of using a client-side-only hash router.</p>\n<p>Taunus can deal with view caching on your behalf, if you so desire, using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\">asynchronous embedded database stores</a> on the client-side. Turns out, there&#39;s <a href=\"http://caniuse.com/#search=indexeddb\">pretty good browser support for IndexedDB</a>. Of course, IndexedDB will only be used if it&#39;s available, and if it&#39;s not then view models won&#39;t be cached in the client-side besides an in-memory store. <strong>The site won&#39;t simply roll over and die, though.</strong></p>\n<p>If you&#39;ve turned client-side caching on, then you can also turn on the <strong>view pre-fetching feature</strong>, which will start downloading views as soon as humans hover on links, as to deliver a <em>faster perceived human experience</em>.</p>\n<p>Taunus provides the bare bones for your application so that you can separate concerns into routes, controllers, models, and views. Then it gets out of the way, by design. There are <a href=\"/complements\">a few complementary modules</a> you can use to enhance your development experience, as well.</p>\n<p>With Taunus you&#39;ll be in charge. <a href=\"/getting-started\">Are you ready to get started?</a></p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.unshift({ lineno: 7, filename: "views/documentation/about.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 8, filename: "views/documentation/about.jade" });
buf.push("<h1 id=\"familiarity\">Familiarity</h1>\n<p>You can use Taunus to develop applications using your favorite Node.js HTTP server, <strong>both <a href=\"http://expressjs.com\">Express</a> and <a href=\"http://hapijs.com\">Hapi</a> are fully supported</strong>. In both cases, you&#39;ll <a href=\"/getting-started\">build controllers the way you&#39;re already used to</a>, except you won&#39;t have to <code>require</code> the view controllers or define any view routes since Taunus will deal with that on your behalf. In the controllers you&#39;ll be able to do everything you&#39;re already able to do, and then you&#39;ll have to return a JSON model which will be used to render a view.</p>\n<p>You can use any view-rendering engine that you want, provided that it can be compiled into JavaScript functions. That&#39;s because Taunus treats views as mere JavaScript functions, rather than being tied into a specific view-rendering engine.</p>\n<p>Client-side controllers are just functions, too. You can bring your own selector engine, your own AJAX libraries, and your own data-binding solutions. It might mean there&#39;s a bit more work involved for you, but you&#39;ll also be free to pick whatever libraries you&#39;re most comfortable with! That being said, Taunus <a href=\"/complements\">does recommend a few libraries</a> that work well with it.</p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # Why Taunus?\n\n    Taunus focuses on delivering a progressively enhanced experience to the end-user, while providing _a reasonable development experience_ as well. **Taunus prioritizes content**. It uses server-side rendering to get content to your humans as fast as possible, and it uses client-side rendering to improve their experience.\n\n    While it focuses on progressive enhancement, **[usability][2] and performance are both core concerns** for Taunus. Incidentally, focusing on progressive enhancement also improves both of these. Usability is improved because the experience is gradually improved, meaning that if somewhere along the line a feature is missing, the component is **still expected to work**.\n\n    For example, a progressively enhanced site uses plain-old links to navigate from one view to another, and then adds a `click` event handler that blocks navigation and issues an AJAX request instead. If JavaScript fails to load, perhaps the experience might stay a little bit worse, but that's okay, because we acknowledge that **our sites don't need to look and behave the same on every browser**. Similarly, [performance is greatly enhanced][1] by delivering content to the human as fast as possible, and then adding functionality on top of that.\n\n    With progressive enhancement, if the functionality never gets there because a JavaScript resource failed to load because the network failed _(not uncommon in the mobile era)_ or because the user blocked JavaScript, your application will still work!\n\n    [1]: http://ponyfoo.com/articles/critical-path-performance-optimization\n    [2]: http://ponyfoo.com/articles/adjusting-ux-for-humans\n\nsection.ly-section.md-markdown\n  :markdown\n    # Why Not Other Frameworks?\n\n    Many other frameworks weren't designed with progressive enhancement, or even shared-rendering in mind. Content isn't prioritized, and humans are expected to [download most of a web page before they can see any digestible content][2]. While Google is going to resolve the SEO issues with dedicated client-side rendering soon, that won't solve all your problems. Google isn't the only web crawler operator out there, and it might be a while before social media link crawlers catch up with them. Even if crawlers are not an issue, being able to provide the fastest possible experience is a big problem to resolve.\n\n    Lately, many mature open-source frameworks started dropping support for older browsers. This is necessary because of the way they're architected, where the developer is put first. **Taunus is [#humanfirst][1]**, meaning that it concedes that humans are more important than the developers building their applications.\n\n    Progressively enhanced applications are always going to have great browser support because of the way they're architected. As the name implies, a baseline is established where we deliver the core experience to the user _(typically in the form of readable HTML content)_, and then enhance it **if possible** using CSS and JavaScript. Building applications in this way means that **you'll be able to reach the most people with your core experience**, and you'll also be able to provide humans in more modern browsers with all of the latest features and technologies.\n\n    [1]: https://twitter.com/hashtag/humanfirst\n    [2]: http://ponyfoo.com/articles/stop-breaking-the-web\n\nsection.ly-section.md-markdown\n  :markdown\n    # Features\n\n    Out of the box, Taunus ensures that your site works on any HTML-enabled document viewer, or even on the terminal, providing support for plain text responses [without any configuration needed][2]. Even while Taunus provides shared-rendering capabilities, it offers code reuse of views and routes, meaning you'll only have to declare these once but they'll be used in both the server-side and the client-side.\n\n    Taunus features a reasonably enhanced experience, where if features aren't available on a browser, they're just not provided. For example, the client-side router makes use of the `history` API but if that's not available then it'll fall back to simply not meddling with links instead of using a client-side-only hash router.\n\n    Taunus can deal with view caching on your behalf, if you so desire, using [asynchronous embedded database stores][3] on the client-side. Turns out, there's [pretty good browser support for IndexedDB][4]. Of course, IndexedDB will only be used if it's available, and if it's not then view models won't be cached in the client-side besides an in-memory store. **The site won't simply roll over and die, though.**\n\n    If you've turned client-side caching on, then you can also turn on the **view pre-fetching feature**, which will start downloading views as soon as humans hover on links, as to deliver a _faster perceived human experience_.\n\n    Taunus provides the bare bones for your application so that you can separate concerns into routes, controllers, models, and views. Then it gets out of the way, by design. There are [a few complementary modules][1] you can use to enhance your development experience, as well.\n\n    With Taunus you'll be in charge. [Are you ready to get started?][2]\n\n    [1]: /complements\n    [2]: /getting-started\n    [3]: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\n    [4]: http://caniuse.com/#search=indexeddb\n\nsection.ly-section.md-markdown\n  :markdown\n    # Familiarity\n\n    You can use Taunus to develop applications using your favorite Node.js HTTP server, **both [Express][3] and [Hapi][4] are fully supported**. In both cases, you'll [build controllers the way you're already used to][1], except you won't have to `require` the view controllers or define any view routes since Taunus will deal with that on your behalf. In the controllers you'll be able to do everything you're already able to do, and then you'll have to return a JSON model which will be used to render a view.\n\n    You can use any view-rendering engine that you want, provided that it can be compiled into JavaScript functions. That's because Taunus treats views as mere JavaScript functions, rather than being tied into a specific view-rendering engine.\n\n    Client-side controllers are just functions, too. You can bring your own selector engine, your own AJAX libraries, and your own data-binding solutions. It might mean there's a bit more work involved for you, but you'll also be free to pick whatever libraries you're most comfortable with! That being said, Taunus [does recommend a few libraries][2] that work well with it.\n\n    [1]: /getting-started\n    [2]: /complements\n    [3]: http://expressjs.com\n    [4]: http://hapijs.com\n");
}
}
},{"jadum/runtime":32}],7:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function api(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/api.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/api.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/api.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/api.jade" });
buf.push("<h1 id=\"api-documentation\">API Documentation</h1>\n<p>Here&#39;s the API documentation for Taunus. If you&#39;ve never used it before, we recommend going over the <a href=\"/getting-started\">Getting Started</a> guide before jumping into the API documentation. That way, you&#39;ll get a better idea of what to look for and how to put together simple applications using Taunus, before going through documentation on every public interface to Taunus.</p>\n<p>Taunus exposes <em>three different public APIs</em>, and there&#39;s also <strong>plugins to integrate Taunus and an HTTP server</strong>. This document covers all three APIs extensively. If you&#39;re concerned about the inner workings of Taunus, please refer to the <a href=\"/getting-started\">Getting Started</a> guide. This document aims to only cover how the public interface affects application state, but <strong>doesn&#39;t delve into implementation details</strong>.</p>\n<h1 id=\"table-of-contents\">Table of Contents</h1>\n<ul>\n<li>A <a href=\"#server-side-api\">server-side API</a> that deals with server-side rendering<ul>\n<li>The <a href=\"#-taunus-mount-addroute-options-\"><code>taunus.mount</code></a> method<ul>\n<li>Its <a href=\"#the-options-object\"><code>options</code></a> argument<ul>\n<li><a href=\"#-options-layout-\"><code>layout</code></a></li>\n<li><a href=\"#-options-routes-\"><code>routes</code></a></li>\n<li><a href=\"#-options-getdefaultviewmodel-\"><code>getDefaultViewModel</code></a></li>\n<li><a href=\"#-options-plaintext-\"><code>plaintext</code></a></li>\n<li><a href=\"#-options-resolvers-\"><code>resolvers</code></a></li>\n<li><a href=\"#-options-version-\"><code>version</code></a></li>\n<li><a href=\"#-options-deferminified-\"><code>deferMinified</code></a></li>\n</ul>\n</li>\n<li>Its <a href=\"#-addroute-definition-\"><code>addRoute</code></a> argument</li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-render-action-viewmodel-req-res-next-\"><code>taunus.render</code></a> method</li>\n<li>The <a href=\"#-taunus-resolve-action-data-\"><code>taunus.resolve</code></a> method</li>\n<li>The <a href=\"#-taunus-redirect-req-res-url-\"><code>taunus.redirect</code></a> method</li>\n<li>The <a href=\"#-taunus-rebuilddefaultviewmodel-done-\"><code>taunus.rebuildDefaultViewModel</code></a> method</li>\n</ul>\n</li>\n<li><a href=\"#server-side-controllers\">Server-side controllers</a></li>\n<li>A <a href=\"#http-framework-plugins\">suite of plugins</a> can integrate Taunus and an HTTP server<ul>\n<li>Using <a href=\"#using-taunus-express-\"><code>taunus-express</code></a> for <a href=\"http://expressjs.com\">Express</a></li>\n<li>Using <a href=\"#using-taunus-hapi-\"><code>taunus-hapi</code></a> for <a href=\"http://hapijs.com\">Hapi</a></li>\n</ul>\n</li>\n<li>A <a href=\"#command-line-interface\">CLI that produces a wiring module</a> for the client-side<ul>\n<li>The <a href=\"#-output-\"><code>--output</code></a> flag</li>\n<li>The <a href=\"#-watch-\"><code>--watch</code></a> flag</li>\n<li>The <a href=\"#-transform-module-\"><code>--transform &lt;module&gt;</code></a> flag</li>\n<li>The <a href=\"#-defer-actions-\"><code>--defer</code></a> flag</li>\n<li>The <a href=\"#-resolvers-module-\"><code>--resolvers &lt;module&gt;</code></a> flag</li>\n<li>The <a href=\"#-bundle-\"><code>--bundle</code></a> flag</li>\n</ul>\n</li>\n<li>A <a href=\"#client-side-api\">client-side API</a> that deals with client-side rendering<ul>\n<li>The <a href=\"#-taunus-mount-container-wiring-options-\"><code>taunus.mount</code></a> method<ul>\n<li>Using the <a href=\"#using-the-auto-strategy\"><code>auto</code></a> strategy</li>\n<li>Using the <a href=\"#using-the-inline-strategy\"><code>inline</code></a> strategy</li>\n<li>Using the <a href=\"#using-the-manual-strategy\"><code>manual</code></a> strategy</li>\n<li><a href=\"#caching\">Caching</a></li>\n<li><a href=\"#prefetching\">Prefetching</a></li>\n<li><a href=\"#versioning\">Versioning</a></li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-on-type-fn-\"><code>taunus.on</code></a> method</li>\n<li>The <a href=\"#-taunus-once-type-fn-\"><code>taunus.once</code></a> method</li>\n<li>The <a href=\"#-taunus-off-type-fn-\"><code>taunus.off</code></a> method</li>\n<li>The <a href=\"#-taunus-intercept-action-fn-\"><code>taunus.intercept</code></a> method</li>\n<li>The <a href=\"#-taunus-partial-container-action-model-\"><code>taunus.partial</code></a> method</li>\n<li>The <a href=\"#-taunus-navigate-url-options-\"><code>taunus.navigate</code></a> method</li>\n<li>The <a href=\"#-taunus-route-url-startindex-\"><code>taunus.route</code></a> method<ul>\n<li>The <a href=\"#-taunus-route-equals-route-route-\"><code>taunus.route.equals</code></a> method</li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-resolve-on-the-client\"><code>taunus.resolve</code></a> method</li>\n<li>The <a href=\"#-taunus-state-\"><code>taunus.state</code></a> property</li>\n<li>The <a href=\"#-taunus-xhr-url-options-done-\"><code>taunus.xhr</code></a> method</li>\n<li>The <a href=\"#using-taunus-prefetch-url-element-\"><code>taunus.prefetch</code></a> method</li>\n<li><a href=\"#debugging-taunus\">Debugging Taunus</a></li>\n</ul>\n</li>\n<li><a href=\"#client-side-controllers\">Client-side controllers</a></li>\n<li>The <a href=\"#the-taunusrc-manifest\"><code>.taunusrc</code></a> manifest</li>\n</ul>\n<h1 id=\"server-side-api\">Server-side API</h1>\n<p>The server-side API is used to set up the view router. It then gets out of the way, allowing the client-side to eventually take over and add any extra sugar on top, <em>including client-side rendering</em>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-mount-addroute-options-\"><code>taunus.mount(addRoute, options?)</code></h2>\n<p>Mounts Taunus on top of a server-side router, by registering each route in <code>options.routes</code> with the <code>addRoute</code> method.</p>\n<blockquote>\n<p>Note that most of the time, <strong>this method shouldn&#39;t be invoked directly</strong>, but rather through one of the <a href=\"#http-framework-plugins\">HTTP framework plugins</a> presented below.</p>\n</blockquote>\n<p>Here&#39;s an incomplete example of how this method may be used. It is incomplete because route definitions have more options beyond the <code>route</code> and <code>action</code> properties.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\ntaunus.mount(addRoute, {\n  routes: [{ route: &#39;/&#39;, action: &#39;home/index&#39; }]\n});\n\nfunction addRoute (definition) {\n  app.get(definition.route, definition.action);\n}\n</code></pre>\n<p>Let&#39;s go over the options you can pass to <code>taunus.mount</code> first.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"the-options-object\">The <code>options?</code> object</h4>\n<p>There&#39;s a few options that can be passed to the server-side mountpoint. You&#39;re probably going to be passing these to your <a href=\"#http-framework-plugins\">HTTP framework plugin</a>, rather than using <code>taunus.mount</code> directly.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-layout-\"><code>options.layout?</code></h6>\n<p>The <code>layout</code> property is expected to have the <code>function(data)</code> signature. It&#39;ll be invoked whenever a full HTML document needs to be rendered, and a <code>data</code> object will be passed to it. That object will contain everything you&#39;ve set as the view model, plus a <code>partial</code> property containing the raw HTML of the rendered partial view. Your <code>layout</code> method will typically wrap the raw HTML for the partial with the bare bones of an HTML document. Check out <a href=\"https://github.com/ponyfoo/ponyfoo/blob/33271751312db6e92059d98293d0a7ac6e9e8e5b/views/server/layout/layout.jade\">the <code>layout.jade</code> used in Pony Foo</a> as an example.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-routes-\"><code>options.routes</code></h6>\n<p>The other big option is <code>routes</code>, which expects a collection of route definitions. Route definitions use a number of properties to determine how the route is going to behave.</p>\n<p>Here&#39;s an example route that uses the <a href=\"http://expressjs.com\">Express</a> routing scheme.</p>\n<pre><code class=\"lang-js\">{\n  route: &#39;/articles/:slug&#39;,\n  action: &#39;articles/article&#39;,\n  ignore: false,\n  cache: &lt;inherit&gt;\n}\n</code></pre>\n<ul>\n<li><code>route</code> is a route in the format your HTTP framework of choice understands</li>\n<li><code>action</code> is the name of your controller action. It&#39;ll be used to find the server-side controller, the default view that should be used with this route, and the client-side controller</li>\n<li><code>cache</code> can be used to determine the client-side caching behavior in this application path, and it&#39;ll default to inheriting from the options passed to <code>taunus.mount</code> <em>on the client-side</em></li>\n<li><code>ignore</code> is used in those cases where you want a URL to be ignored by the client-side router even if there&#39;s a catch-all route that would match that URL</li>\n</ul>\n<p>As an example of the <code>ignore</code> use case, consider the routing table shown below. The client-side router doesn&#39;t know <em>(and can&#39;t know unless you point it out)</em> what routes are server-side only, and it&#39;s up to you to point those out.</p>\n<pre><code class=\"lang-js\">[\n  { route: &#39;/&#39;, action: &#39;/home/index&#39; },\n  { route: &#39;/feed&#39;, ignore: true },\n  { route: &#39;/*&#39;, action: &#39;error/not-found&#39; }\n]\n</code></pre>\n<p>This step is necessary whenever you have an anchor link pointed at something like an RSS feed. The <code>ignore</code> property is effectively telling the client-side <em>&quot;don&#39;t hijack links containing this URL&quot;</em>.</p>\n<p>Please note that external links are never hijacked. Only same-origin links containing a URL that matches one of the routes will be hijacked by Taunus. External links don&#39;t need to be <code>ignore</code>d.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-getdefaultviewmodel-\"><code>options.getDefaultViewModel?</code></h6>\n<p>The <code>getDefaultViewModel(done)</code> property can be a method that puts together the base view model, which will then be extended on an action-by-action basis. When you&#39;re done creating a view model, you can invoke <code>done(null, model)</code>. If an error occurs while building the view model, you should call <code>done(err)</code> instead.</p>\n<p>Taunus will throw an error if <code>done</code> is invoked with an error, so you might want to put safeguards in place as to avoid that from happenning. The reason this method is asynchronous is because you may need database access or somesuch when putting together the defaults. The reason this is a method and not just an object is that the defaults may change due to human interaction with the application, and in those cases <a href=\"#taunus-rebuilddefaultviewmodel\">the defaults can be rebuilt</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-plaintext-\"><code>options.plaintext?</code></h6>\n<p>The <code>plaintext</code> options object is passed directly to <a href=\"https://github.com/bevacqua/hget\">hget</a>, and it&#39;s used to <a href=\"https://github.com/ponyfoo/ponyfoo/blob/f6d6b5068ff03a387f503900160d9fdc1e749750/controllers/routing.js#L70-L72\">tweak the plaintext version</a> of your site.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-resolvers-\"><code>options.resolvers?</code></h6>\n<p>Resolvers are used to determine the location of some of the different pieces of your application. Typically you won&#39;t have to touch these in the slightest.</p>\n<table>\n<thead>\n<tr>\n<th>Signature</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getServerController(action)</code></td>\n<td>Return path to server-side controller action handler module</td>\n</tr>\n<tr>\n<td><code>getView(action)</code></td>\n<td>Return path to view template module</td>\n</tr>\n</tbody>\n</table>\n<p>The <code>addRoute</code> method passed to <code>taunus.mount</code> on the server-side is mostly going to be used internally by the HTTP framework plugins, so feel free to skip over the following section.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-version-\"><code>options.version?</code></h6>\n<p>Refer to the <a href=\"#versioning\">Versioning</a> section.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-getpartial-\"><code>options.getPartial?</code></h6>\n<p>By default, Taunus will render partials on the server-side by looking up the module for an action method, and calling that action passing in a model.</p>\n<p>You can override the default behavior by setting <code>options.getPartial</code> to a function. This method takes three parameters.</p>\n<ul>\n<li><code>action</code> is the action that needs to be rendered</li>\n<li><code>model</code> is the model you can use to render the view for that action</li>\n<li><code>done(err, html)</code> is called when you&#39;re done, passing in the resulting <code>html</code> for the partial</li>\n</ul>\n<p>Note that if you don&#39;t set <code>getPartial</code>, Taunus will just require your controller action method and invoke that instead.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6 id=\"-options-deferminified-\"><code>options.deferMinified?</code></h6>\n<p>When views and controllers are lazily loaded, they are compiled and bundled using Browserify. Taunus will even produce a source map. To avoid the source map, and minify the bundle instead, set <code>deferMinified</code> to <code>true</code>.</p>\n<p>You&#39;ll probably want to set <code>deferMinified</code> to whether the application is running on the production environment.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"-addroute-definition-\"><code>addRoute(definition)</code></h4>\n<p>The <code>addRoute(definition)</code> method will be passed a route definition, containing the following properties. This method is expected to register a route in your HTTP framework&#39;s router.</p>\n<ul>\n<li><code>route</code> is the route that you set as <code>definition.route</code></li>\n<li><code>action</code> is the action as passed to the route definition</li>\n<li><code>actionFn</code> will be the controller for this action method</li>\n<li><code>middleware</code> will be an array of methods to be executed before <code>actionFn</code></li>\n</ul>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-render-action-viewmodel-req-res-next-\"><code>taunus.render(action, viewModel, req, res, next)</code></h2>\n<p>This method is almost an implementation detail as you should be using Taunus through one of the plugins anyways, so we won&#39;t go very deep into it.</p>\n<p>The render method is what Taunus uses to render views by constructing HTML, JSON, or plaintext responses. The <code>action</code> property determines the default view that will be rendered. The <code>viewModel</code> will be extended by <a href=\"#-options-getdefaultviewmodel-\">the default view model</a>, and it may also override the default <code>action</code> by setting <code>viewModel.model.action</code>.</p>\n<p>The <code>req</code>, <code>res</code>, and <code>next</code> arguments are expected to be the Express routing arguments, but they can also be mocked <em>(which is in fact what the Hapi plugin does)</em>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-rebuilddefaultviewmodel-done-\"><code>taunus.rebuildDefaultViewModel(done?)</code></h2>\n<p>Once Taunus has been mounted, calling this method will rebuild the view model defaults using the <code>getDefaultViewModel</code> that was passed to <code>taunus.mount</code> in the options. An optional <code>done</code> callback will be invoked when the model is rebuilt.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-resolve-action-data-\"><code>taunus.resolve(action, data?)</code></h2>\n<p>Returns the first route that matches an <code>action</code>, replacing named parameters with data from the <code>data</code> object. If a matching route is not found, <code>null</code> is returned.</p>\n<blockquote>\n<p>If a route is matched but a required named parameter isn&#39;t in <code>data</code>, <strong>an exception will be thrown</strong>.</p>\n</blockquote>\n<p>This method is most useful when composing the URL for a redirect or an action link within a template, as a means to keep the route declaration isolated from the route itself. If the route changes, the method will reflect the newer route as long as the parameters stay the same, resulting in increased maintainability. <em>The method is available in both layout templates and partial view templates.</em></p>\n<h6 id=\"example\">Example</h6>\n<pre><code class=\"lang-js\">taunus.resolve(&#39;projects/project&#39;, {\n  name: &#39;puppies&#39;, organization: &#39;caniuse&#39;\n});\n// &lt;- /p/caniuse/puppies\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-redirect-req-res-url-\"><code>taunus.redirect(req, res, url)</code></h2>\n<p>Redirects the response to a different URL. If the page was being loaded for the first time, this method is equivalent to <code>res.redirect(url)</code>. If the page was being loaded via the client-side AJAX routing engine, a specially crafted JSON response will trigger a full page reload on the client-side.</p>\n<h6 id=\"example\">Example</h6>\n<pre><code class=\"lang-js\">taunus.redirect(req, res, &#39;/login&#39;);\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"server-side-controllers\">Server-Side Controllers</h1>\n<p>On the server-side, controllers are modules that export a single function. The parameters passed to these controllers depend on the server-side HTTP framework that&#39;s being used.</p>\n<p>For example, Express gives us three parameters: <code>req</code>, <code>res</code> and <code>next</code>. Hapi gives us two instead: <code>request</code> and <code>reply</code>.</p>\n<p>Here&#39;s a sample controller using <code>taunus-express</code>, as <a href=\"#using-taunus-express-\">detailed below</a>. This is a very simple controller where we are setting the special <code>viewModel</code> property on the response, and calling <code>next</code>. Suppose this controller is the <code>product/home</code> action handler.</p>\n<pre><code class=\"lang-js\">module.exports = function (req, res, next) {\n  res.viewModel = {\n    model: {\n      title: &#39;view title&#39;\n    }\n  };\n  next();\n};\n</code></pre>\n<p>As you can see, Taunus won&#39;t alter the API provided by Express. Instead, it builds upon the notion of using middleware. Once the <code>product/home</code> view is rendered and JavaScript loads, the <code>product/home</code> view controller is executed on the client-side.</p>\n<p>You could change the view to be rendered by setting the <code>action</code> property on the <code>model</code>. In the example shown below this would mean that the <code>error/offline</code> view would be rendered. The client-side controller will be that of <code>error/offline</code>, as well. View controllers are tied to the view that gets rendered.</p>\n<pre><code class=\"lang-js\">module.exports = function (req, res, next) {\n  res.viewModel = {\n    model: {\n      title: &#39;view title&#39;\n    }\n  };\n  if (offline) {\n    res.viewModel.model.action = &#39;error/offline&#39;;\n  }\n  next();\n};\n</code></pre>\n<p>Having a default action and the ability to redirect to another gives us a lot of flexibility when determining how to respond to a request.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"http-framework-plugins\">HTTP Framework Plugins</h1>\n<p>There&#39;s currently two different HTTP frameworks <em>(<a href=\"http://expressjs.com\">Express</a> and <a href=\"http://hapijs.com\">Hapi</a>)</em> that you can readily use with Taunus without having to deal with any of the route plumbing yourself.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"using-taunus-express-\">Using <code>taunus-express</code></h2>\n<p>The <code>taunus-express</code> plugin is probably the easiest to use, as Taunus was originally developed with just <a href=\"http://expressjs.com\">Express</a> in mind. In addition to the options already outlined for <a href=\"#-taunus-mount-addroute-options-\">taunus.mount</a>, you can add middleware for any route individually.</p>\n<ul>\n<li><code>middleware</code> are any methods you want Taunus to execute as middleware in Express applications</li>\n</ul>\n<p>To get <code>taunus-express</code> going you can use the following piece of code, provided that you come up with an <code>options</code> object.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {\n  // ...\n};\n\ntaunusExpress(taunus, app, options);\n</code></pre>\n<p>The <code>taunusExpress</code> method will merely set up Taunus and add the relevant routes to your Express application by calling <code>app.get</code> a bunch of times. You can <a href=\"https://github.com/taunus/taunus-express\">find taunus-express on GitHub</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"using-taunus-hapi-\">Using <code>taunus-hapi</code></h2>\n<p>The <code>taunus-hapi</code> plugin is a bit more involved, and you&#39;ll have to create a Pack in order to use it. In addition to <a href=\"#-taunus-mount-addroute-options-\">the options we&#39;ve already covered</a>, you can add <code>config</code> on any route.</p>\n<ul>\n<li><code>config</code> is passed directly into the route registered with Hapi, giving you the most flexibility</li>\n</ul>\n<p>To get <code>taunus-hapi</code> going you can use the following piece of code, and you can bring your own <code>options</code> object.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar Hapi = require(&#39;hapi&#39;);\nvar taunus = require(&#39;taunus&#39;);\nvar taunusHapi = require(&#39;taunus-hapi&#39;)(taunus);\nvar pack = new Hapi.Pack();\n\npack.register({\n  plugin: taunusHapi,\n  options: {\n    // ...\n  }\n});\n</code></pre>\n<p>The <code>taunusHapi</code> plugin will mount Taunus and register all of the necessary routes. You can <a href=\"https://github.com/taunus/taunus-hapi\">find taunus-hapi on GitHub</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"command-line-interface\">Command-Line Interface</h1>\n<p>Once you&#39;ve set up the server-side to render your views using Taunus, it&#39;s only logical that you&#39;ll want to render the views in the client-side as well, effectively converting your application into a single-page application after the first view has been rendered on the server-side.</p>\n<p>The Taunus CLI is an useful intermediary in the process of getting the configuration you wrote so far for the server-side to also work well in the client-side.</p>\n<p>Install it globally for development, but remember to use local copies for production-grade uses.</p>\n<pre><code class=\"lang-shell\">npm install -g taunus\n</code></pre>\n<p>When invoked without any arguments, the CLI will simply follow the default conventions to find your route definitions, views, and client-side controllers.</p>\n<pre><code class=\"lang-shell\">taunus\n</code></pre>\n<p>By default, the output will be printed to the standard output, making for a fast debugging experience. Here&#39;s the output if you just had a single <code>home/index</code> route, and the matching view and client-side controller existed.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar templates = {\n  &#39;home/index&#39;: require(&#39;./views/home/index.js&#39;)\n};\n\nvar controllers = {\n  &#39;home/index&#39;: require(&#39;../client/js/controllers/home/index.js&#39;)\n};\n\nvar routes = [\n  {\n    route: &#39;/&#39;,\n    action: &#39;home/index&#39;\n  }\n];\n\nmodule.exports = {\n  templates: templates,\n  controllers: controllers,\n  routes: routes\n};\n</code></pre>\n<p>You can use a few options to alter the outcome of invoking <code>taunus</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-output-\"><code>--output</code></h2>\n<p><sub>the <code>-o</code> alias is available</sub></p>\n<p>Output is written to a file instead of to standard output. The file path used will be the <code>client_wiring</code> option in <a href=\"#the-taunusrc-manifest\"><code>.taunusrc</code></a>, which defaults to <code>&#39;.bin/wiring.js&#39;</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-watch-\"><code>--watch</code></h2>\n<p><sub>the <code>-w</code> alias is available</sub></p>\n<p>Whenever a server-side route definition changes, the output is printed again to either standard output or a file, depending on whether <code>--output</code> was used.</p>\n<p>The program won&#39;t exit.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-transform-module-\"><code>--transform &lt;module&gt;</code></h2>\n<p><sub>the <code>-t</code> alias is available</sub></p>\n<p>This flag allows you to transform server-side routes into something the client-side understands. Express routes are completely compatible with the client-side router, but Hapi routes need to be transformed using the <a href=\"https://github.com/taunus/hapiify\"><code>hapiify</code></a> module.</p>\n<pre><code class=\"lang-shell\">npm install hapiify\ntaunus -t hapiify\n</code></pre>\n<p>Using this transform relieves you from having to define the same routes twice using slightly different formats that convey the same meaning.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-defer-actions-\"><code>--defer [actions]</code></h2>\n<p><sub>the <code>-d</code> alias is available</sub></p>\n<p>Here is where things get interesting. The <code>--defer</code> flag allows you to defer loading for zero or more actions. Excluding the controller and view templates for any deferred action can significantly reduce the fingerprint of your application.</p>\n<p>The <code>[actions]</code> argument determines what actions get deferred, and which don&#39;t. It expects a comma-separated list of actions, where you can pass in either the controller name, or both the controller name and the action name. Using <code>?</code> acts as a wildcard.</p>\n<p>For example, using <code>admin</code> <em>(equivalent to using <code>admin/?</code>)</em> will defer every action under the <code>admin</code> controller. Using <code>admin/nuke</code> will only defer the <code>admin/nuke</code> action. If you omit the <code>[actions]</code> parameter entirely, the default value of <code>&#39;?&#39;</code> will be used and everything will be deferred.</p>\n<p>When components get deferred, they&#39;ll be loaded as soon as Taunus detects that they&#39;re needed. This can happen in a few places.</p>\n<ul>\n<li>The user navigates to (or <a href=\"#prefetching\"><em>prefetches</em></a>) the <code>/admin</code> route, and <code>admin/index</code> was deferred, and its components aren&#39;t cached on the client-side yet</li>\n<li>A controller uses <code>taunus.partial</code> to render an action that was deferred, and its components aren&#39;t cached on the client-side yet</li>\n<li>The user navigates to the <code>/admin</code> route, and its matching <code>admin/index</code> route wasn&#39;t deferred, but the server-side controller decides to change the action to <code>admin/superadmin</code>. When the response gets to the client, it&#39;ll need to ask the server for the <code>admin/superadmin</code> template if the client doesn&#39;t already have it</li>\n</ul>\n<p>You don&#39;t have to worry about those different scenarios, though, as Taunus handles them all for you transparently. You should <a href=\"/performance#send-views-and-controllers-to-the-client-selectively\">learn more about deferred loading on the Performance Optimization guide</a>.</p>\n<blockquote>\n<p>A possible concern with deferred execution is that partial views may not be rendered immediately, as a request may be necessary to fetch the controller or template for the partial.</p>\n</blockquote>\n<p>Some other considerations, regarding how deferred components get bundled, are listed in the <a href=\"/performance#send-views-and-controllers-to-the-client-selectively\">Performance Optimization</a> guide.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-resolvers-module-\"><code>--resolvers &lt;module&gt;</code></h2>\n<p><sub>the <code>-r</code> alias is available</sub></p>\n<p>Similarly to the <a href=\"#-options-resolvers-\"><code>resolvers</code></a> option that you can pass to <a href=\"#-taunus-mount-addroute-options-\"><code>taunus.mount</code></a>, these resolvers can change the way in which file paths are resolved.</p>\n<table>\n<thead>\n<tr>\n<th>Signature</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getClientController(action)</code></td>\n<td>Return path to client-side controller action handler module</td>\n</tr>\n<tr>\n<td><code>getView(action)</code></td>\n<td>Return path to view template module</td>\n</tr>\n</tbody>\n</table>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-bundle-\"><code>--bundle</code></h2>\n<p><sub>the <code>-b</code> alias is available</sub></p>\n<p>Under this experimental flag, the CLI will use Browserify to compile a standalone module that includes the wiring normally exported by the CLI plus all of Taunus <a href=\"https://github.com/umdjs/umd\">as a UMD module</a>.</p>\n<p>This allows you to use Taunus on the client-side even if you don&#39;t want to use <a href=\"http://browserify.org\">Browserify</a> directly.</p>\n<p>Feedback and suggestions about this flag, <em>and possible alternatives that would make Taunus easier to use</em>, are welcome.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"client-side-api\">Client-side API</h1>\n<p>Just like the server-side, everything in the client-side begins at the mountpoint. Once the application is mounted, anchor links will be hijacked and the client-side router will take over view rendering. Client-side controllers are executed whenever a view is rendered.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-mount-container-wiring-options-\"><code>taunus.mount(container, wiring, options?)</code></h2>\n<p>The mountpoint takes a root container, the wiring module, and an options parameter. The <code>container</code> is where client-side-rendered views will be placed, by replacing whatever HTML contents already exist. You can pass in the <code>wiring</code> module exactly as built by the CLI, and no further configuration is necessary.</p>\n<p>When the mountpoint executes, Taunus will configure its internal state, <em>set up the client-side router</em>, run the client-side controller for the server-side rendered view, and start hijacking links.</p>\n<p>As an example, consider a browser makes a <code>GET</code> request for <code>/articles/the-fox</code> for the first time. Once <code>taunus.mount(container, wiring)</code> is invoked on the client-side, several things would happen in the order listed below.</p>\n<ul>\n<li>Taunus sets up the client-side view routing engine</li>\n<li>If enabled <em>(via <code>options</code>)</em>, the caching engine is configured</li>\n<li>Taunus obtains the view model <em>(more on this later)</em></li>\n<li>When a view model is obtained, the <code>&#39;start&#39;</code> event is emitted</li>\n<li>Anchor links start being monitored for clicks <em>(at this point your application becomes a <a href=\"http://en.wikipedia.org/wiki/Single-page_application\">SPA</a>)</em></li>\n<li>The <code>articles/article</code> client-side controller is executed</li>\n</ul>\n<p>That&#39;s quite a bit of functionality, but if you think about it, most other frameworks also render the view at this point, <em>rather than on the server-side!</em></p>\n<p>In order to better understand the process, I&#39;ll walk you through the <code>options</code> parameter.</p>\n<p>First off, the <code>bootstrap</code> option determines the strategy used to pull the view model of the server-side rendered view into the client-side. There are three possible strategies available: <code>auto</code> <em>(the default strategy)</em>, <code>inline</code>, or <code>manual</code>. The <code>auto</code> strategy involves the least work, which is why it&#39;s the default.</p>\n<ul>\n<li><code>auto</code> will make an AJAX request for the view model</li>\n<li><code>inline</code> expects you to place the model into a <code>&lt;script type=&#39;text/taunus&#39;&gt;</code> tag</li>\n<li><code>manual</code> expects you to get the view model however you want to, and then let Taunus know when it&#39;s ready</li>\n</ul>\n<p>Let&#39;s go into detail about each of these strategies.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-the-auto-strategy\">Using the <code>auto</code> strategy</h4>\n<p>The <code>auto</code> strategy means that Taunus will make use of an AJAX request to obtain the view model. <em>You don&#39;t have to do anything else</em> and this is the default strategy. This is the <strong>most convenient strategy, but also the slowest</strong> one.</p>\n<p>It&#39;s slow because the view model won&#39;t be requested until the bulk of your JavaScript code has been downloaded, parsed, executed, and <code>taunus.mount</code> is invoked.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-the-inline-strategy\">Using the <code>inline</code> strategy</h4>\n<p>The <code>inline</code> strategy expects you to add a <code>data-taunus</code> attribute on the <code>container</code> element. This attribute must be equal to the <code>id</code> attribute of a <code>&lt;script&gt;</code> tag containing the serialized view model alongside the version information automatically injected by Taunus into the layout template data.</p>\n<pre><code class=\"lang-jade\">div(data-taunus=&#39;model&#39;)!=partial\nscript(type=&#39;text/taunus&#39;, data-taunus=&#39;model&#39;)=JSON.stringify({ version: version, model: model })\n</code></pre>\n<p>Pay special attention to the fact that the model is not only made into a JSON string, <em>but also HTML encoded by Jade</em>. When Taunus extracts the model from the <code>&lt;script&gt;</code> tag it&#39;ll unescape it, and then parse it as JSON.</p>\n<p>This strategy is also fairly convenient to set up, but it involves a little more work. It might be worthwhile to use in cases where models are small, but it will slow down server-side view rendering, as the model is inlined alongside the HTML.</p>\n<p>That means that the content you are supposed to be prioritizing is going to take longer to get to your humans, but once they get the HTML, this strategy will execute the client-side controller almost immediately.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-the-manual-strategy\">Using the <code>manual</code> strategy</h4>\n<p>The <code>manual</code> strategy is the most involved of the three, but also the most performant. In this strategy you&#39;re supposed to add the following <em>(seemingly pointless)</em> snippet of code in a <code>&lt;script&gt;</code> other than the one that&#39;s pulling down Taunus, so that they are pulled concurrently rather than serially.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nwindow.taunusReady = function (model) {\n  window.taunusReady = model;\n};\n</code></pre>\n<p>Once you somehow get your hands on the view model, you should invoke <code>taunusReady(model)</code>. Considering you&#39;ll be pulling both the view model and Taunus at the same time, a number of different scenarios may play out.</p>\n<ul>\n<li>The view model is loaded first, you call <code>taunusReady(model)</code> and wait for Taunus to take the model object and boot the application as soon as <code>taunus.mount</code> is executed</li>\n<li>Taunus loads first and <code>taunus.mount</code> is called first. In this case, Taunus will replace <code>window.taunusReady</code> with a special <code>boot</code> method. When the view model finishes loading, you call <code>taunusReady(model)</code> and the application finishes booting</li>\n</ul>\n<blockquote>\n<p>If this sounds a little mind-bending it&#39;s because it is. It&#39;s not designed to be pretty, but merely to be performant.</p>\n</blockquote>\n<p>Now that we&#39;ve addressed the awkward bits, let&#39;s cover the <em>&quot;somehow get your hands on the view model&quot;</em> aspect. My preferred method is using JSONP, as it&#39;s able to deliver the smallest snippet possible, and it can take advantage of server-side caching. Considering you&#39;ll probably want this to be an inline script, keeping it small is important.</p>\n<p>The good news is that the server-side supports JSONP out the box. Here&#39;s a snippet of code you could use to pull down the view model and boot Taunus up as soon as both operations are ready.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nfunction inject (url) {\n  var script = document.createElement(&#39;script&#39;);\n  script.src = url;\n  document.body.appendChild(script);\n}\n\nfunction injector () {\n  var search = location.search;\n  var searchQuery = search ? &#39;&amp;&#39; + search.substr(1) : &#39;&#39;;\n  var searchJson = &#39;?json&amp;callback=taunusReady&#39; + searchQuery;\n  inject(location.pathname + searchJson);\n}\n\nwindow.taunusReady = function (model) {\n  window.taunusReady = model;\n};\n\ninjector();\n</code></pre>\n<p>As mentioned earlier, this approach involves getting your hands dirtier but it pays off by being the fastest of the three.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"caching\">Caching</h4>\n<p>The client-side in Taunus supports caching in-memory and using the embedded IndexedDB system by merely turning on the <code>cache</code> flag in the options passed to <code>taunus.mount</code> on the client-side.</p>\n<p>If you set <code>cache</code> to <code>true</code> then cached items will be considered <em>&quot;fresh&quot; (valid copies of the original)</em> for <strong>15 seconds</strong>. You can also set <code>cache</code> to a number, and that number of seconds will be used as the default instead.</p>\n<p>Caching can also be tweaked on individual routes. For instance, you could set <code>{ cache: true }</code> when mounting Taunus and then have <code>{ cache: 3600 }</code> on a route that you want to cache for a longer period of time.</p>\n<p>The caching layer is <em>seamlessly integrated</em> into Taunus, meaning that any views rendered by Taunus will be cached according to these caching rules. Keep in mind, however, that persistence at the client-side caching layer will only be possible in <a href=\"http://caniuse.com/#feat=indexeddb\">browsers that support IndexedDB</a>. In the case of browsers that don&#39;t support IndexedDB, Taunus will use an in-memory cache, which will be wiped out whenever the human decides to close the tab in their browser.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"prefetching\">Prefetching</h4>\n<p>If caching is enabled, the next logical step is prefetching. This is enabled just by adding <code>prefetch: true</code> to the options passed to <code>taunus.mount</code>. The prefetching feature will fire for any anchor link that&#39;s trips over a <code>mouseover</code> or a <code>touchstart</code> event. If a route matches the URL in the <code>href</code>, an AJAX request will prefetch the view and cache its contents, improving perceived performance.</p>\n<p>When links are clicked before prefetching finishes, they&#39;ll wait on the prefetcher to finish before immediately switching to the view, effectively cutting down the response time. If the link was already prefetched or otherwise cached, the view will be loaded immediately. If the human hovers over a link and another one was already being prefetched, then that one is aborted. This prevents prefetching from draining the bandwidth on clients with limited or intermittent connectivity.</p>\n<h4 id=\"versioning\">Versioning</h4>\n<p>When enabled, versioning will look out for discrepancies between what&#39;s currently on the client and what&#39;s on the server, and reload everything necessary to make what&#39;s on the client match what&#39;s on the server.</p>\n<p>In order to turn it on, set the <code>version</code> field in the options when invoking <code>taunus.mount</code> <strong>on both the server-side and the client-side, using the same value</strong>. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.</p>\n<blockquote>\n<p>To make sure you don&#39;t forget to change the version string in one of the mountpoints, please create a JSON file with just the version string and <code>require</code> that file in both sides.</p>\n<pre><code class=\"lang-shell\">echo &#39;&quot;1.0.0&quot;&#39; &gt; version.json\n</code></pre>\n</blockquote>\n<p>The default version string is set to <code>1</code>. The Taunus version will be prepended to yours, resulting in a value such as <code>t3.0.0;v1</code> where Taunus is running version <code>3.0.0</code> and your application is running version <code>1</code>.</p>\n<p>Refer to the Getting Started guide for a more detailed <a href=\"/getting-started#versioning\">analysis of the uses for versioning</a>. There&#39;s some more nuggets of information in the <a href=\"/performance#use-versioning-to-ensure-cache-validity\">Performance Optimization</a> guide as well.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-on-type-fn-\"><code>taunus.on(type, fn)</code></h2>\n<p>Taunus emits a series of events during its lifecycle, and <code>taunus.on</code> is the way you can tune in and listen for these events using a subscription function <code>fn</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Arguments</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#39;start&#39;</code></td>\n<td><code>container, model, route</code></td>\n<td>Emitted when <code>taunus.mount</code> finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling <code>taunus.mount</code>.</td>\n</tr>\n<tr>\n<td><code>&#39;render&#39;</code></td>\n<td><code>container, model, route</code></td>\n<td>A view has just been rendered and its client-side controller is about to be invoked</td>\n</tr>\n<tr>\n<td><code>&#39;change&#39;</code></td>\n<td><code>route, model</code></td>\n<td>Same as <code>&#39;render&#39;</code>, but only if <code>container</code> is the mountpoint and the route has changed.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.start&#39;</code></td>\n<td><code>route, context</code></td>\n<td>Emitted whenever an XHR request starts.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.done&#39;</code></td>\n<td><code>route, context, data</code></td>\n<td>Emitted whenever an XHR request ends successfully.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.abort&#39;</code></td>\n<td><code>route, context</code></td>\n<td>Emitted whenever an XHR request is purposely aborted.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.error&#39;</code></td>\n<td><code>route, context, err</code></td>\n<td>Emitted whenever an XHR request results in an HTTP error.</td>\n</tr>\n</tbody>\n</table>\n<p>Consider for instance that you&#39;d like to keep track of every view that gets rendered, and what DOM element it gets placed into. The piece of code below would quickly do that for us.</p>\n<pre><code class=\"lang-js\">taunus.on(&#39;render&#39;, function (container) {\n  console.log(&#39;Rendered a view on&#39;, container);\n});\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-once-type-fn-\"><code>taunus.once(type, fn)</code></h2>\n<p>This method is equivalent to <a href=\"#-taunus-on-type-fn-\"><code>taunus.on</code></a>, except the event listeners will be used once and then it&#39;ll be discarded.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-off-type-fn-\"><code>taunus.off(type, fn)</code></h2>\n<p>Using this method you can remove any event listeners that were previously added using <code>.on</code> or <code>.once</code>. You must provide the type of event you want to remove and a reference to the event listener function that was originally used when calling <code>.on</code> or <code>.once</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-intercept-action-fn-\"><code>taunus.intercept(action?, fn)</code></h2>\n<p>This method can be used to anticipate model requests, before they ever make it into XHR requests. You can add interceptors for specific actions, which would be triggered only if the request matches the specified <code>action</code>. You can also add global interceptors by omitting the <code>action</code> parameter, or setting it to <code>*</code>.</p>\n<p>An interceptor function will receive an <code>event</code> parameter, containing a few different properties.</p>\n<ul>\n<li><code>url</code> contains the URL that needs a view model</li>\n<li><code>route</code> contains the full route object as you&#39;d get from <a href=\"#-taunus-route-url-startindex-\"><code>taunus.route(url, startIndex?)</code></a></li>\n<li><code>parts</code> is just a shortcut for <code>route.parts</code></li>\n<li><code>preventDefault(data)</code> allows you to suppress the need for an AJAX request, commanding Taunus to use the response data you&#39;ve provided instead</li>\n<li><code>defaultPrevented</code> tells you if some other handler has prevented the default behavior</li>\n<li><code>canPreventDefault</code> tells you if invoking <code>event.preventDefault</code> will have any effect</li>\n<li><code>data</code> starts as <code>null</code>, and it can later become the data passed to <code>preventDefault</code></li>\n</ul>\n<p>Interceptors are asynchronous, but if an interceptor spends longer than 50ms it&#39;ll be short-circuited and calling <code>event.preventDefault</code> past that point won&#39;t have any effect.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-partial-container-action-model-\"><code>taunus.partial(container, action, model)</code></h2>\n<p>This method provides you with access to the view-rendering engine of Taunus. You can use it to render the <code>action</code> view into the <code>container</code> DOM element, using the specified <code>model</code>. Once the view is rendered, the <code>render</code> event will be fired <em>(with <code>container, model</code> as arguments)</em> and the client-side controller for that view will be executed.</p>\n<p>Note that the partial may be rendered asynchronously if the <code>action</code> is <a href=\"#-defer-actions-\">deferred</a> and its components (view template, controller) aren&#39;t readily available in the client yet.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-navigate-url-options-\"><code>taunus.navigate(url, options)</code></h2>\n<p>Whenever you want to navigate to a URL, say when an AJAX call finishes after a button click, you can use <code>taunus.navigate</code> passing it a plain URL or anything that would cause <code>taunus.route(url, startIndex?)</code> to return a valid route.</p>\n<p>By default, if <code>taunus.navigate(url, options)</code> is called with an <code>url</code> that doesn&#39;t match any client-side route, then the user will be redirected via <code>location.href</code>. In cases where the browser doesn&#39;t support the history API, <code>location.href</code> will be used as well.</p>\n<p>There&#39;s a few options you can use to tweak the behavior of <code>taunus.navigate</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>context</code></td>\n<td>A DOM element that caused the navigation event, used when emitting events</td>\n</tr>\n<tr>\n<td><code>strict</code></td>\n<td>If set to <code>true</code> and the URL doesn&#39;t match any route, then the navigation attempt must be ignored</td>\n</tr>\n<tr>\n<td><code>scroll</code></td>\n<td>When this is set to <code>false</code>, elements aren&#39;t scrolled into view after navigation</td>\n</tr>\n<tr>\n<td><code>force</code></td>\n<td>Unless this is set to <code>true</code>, navigation won&#39;t <em>fetch a model</em> if the route matches the current route, and <code>state.model</code> will be reused instead</td>\n</tr>\n<tr>\n<td><code>replaceState</code></td>\n<td>Use <code>replaceState</code> instead of <code>pushState</code> when changing history</td>\n</tr>\n</tbody>\n</table>\n<p>Note that the notion of <em>fetching a model</em> might be deceiving as the model could be pulled from the cache even if <code>force</code> is set to <code>true</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-route-url-startindex-\"><code>taunus.route(url, startIndex?)</code></h2>\n<p>This convenience method allows you to break down a URL into its individual components. The method accepts any of the following URL patterns, and it returns a Taunus route object. The optional <code>startIndex</code> argument specifies what index to start at, as seen on <code>taunus.state.routes</code>.</p>\n<ul>\n<li>A fully qualified URL on the same origin, e.g <code>http://taunus.bevacqua.io/api</code></li>\n<li>An absolute URL without an origin, e.g <code>/api</code></li>\n<li>Just a hash, e.g <code>#foo</code> <em>(<code>location.href</code> is used)</em></li>\n<li>Falsy values, e.g <code>null</code> <em>(<code>location.href</code> is used)</em></li>\n</ul>\n<p>Relative URLs are not supported <em>(anything that doesn&#39;t have a leading slash)</em>, e.g <code>files/data.json</code>. Anything that&#39;s not on the same origin or doesn&#39;t match one of the registered routes is going to yield <code>null</code>.</p>\n<p><em>This method is particularly useful when debugging your routing tables, as it gives you direct access to the router used internally by Taunus.</em></p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"-taunus-route-equals-route-route-\"><code>taunus.route.equals(route, route)</code></h4>\n<p>Compares two routes and returns <code>true</code> if they would fetch the same model. Note that different URLs may still return <code>true</code>. For instance, <code>/foo</code> and <code>/foo#bar</code> would fetch the same model even if they&#39;re different URLs.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-resolve-on-the-client\"><code>taunus.resolve</code> on the client</h2>\n<p>This method is identical to the server-side flavor of <a href=\"#-taunus-resolve-action-data-\"><code>taunus.resolve(action, data)</code></a>, but available on the client-side.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-state-\"><code>taunus.state</code></h2>\n<p>This is an internal state variable, and it contains a lot of useful debugging information.</p>\n<ul>\n<li><code>container</code> is the DOM element passed to <code>taunus.mount</code></li>\n<li><code>controllers</code> are all the controllers, as defined in the wiring module</li>\n<li><code>templates</code> are all the templates, as defined in the wiring module</li>\n<li><code>routes</code> are all the routes, as defined in the wiring module</li>\n<li><code>route</code> is a reference to the current route</li>\n<li><code>model</code> is a reference to the model used to render the current view</li>\n<li><code>prefetch</code> exposes whether prefetching is turned on</li>\n<li><code>cache</code> exposes whether caching is enabled</li>\n<li><code>version</code> exposes the version string that&#39;s currently in use</li>\n</ul>\n<p>There&#39;s also a <code>clear</code> method accessible through <code>taunus.state.clear</code>, which will empty the cache, as well as remove from the <code>state</code> any controllers and templates that were lazy loaded.</p>\n<p>Of course, you&#39;re not supposed to meddle with it, so be a good citizen and just inspect its values!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"-taunus-xhr-url-options-done-\"><code>taunus.xhr(url, options?, done)</code></h2>\n<p>This method allows you to issue your own AJAX requests through the <code>xhr</code> module. It sets a few convenient defaults, <em>listed below</em>, where <code>url</code> refers to the URL passed as the first parameter.</p>\n<pre><code class=\"lang-js\">{\n  url: url,\n  json: true,\n  headers: { Accept: &#39;application/json&#39; }\n}\n</code></pre>\n<p>The <code>done(err, body, res)</code> callback will be invoked when the request finishes, and it&#39;ll be passed three parameters, an optional error if something went wrong <em>(request failed, was aborted, etc.)</em> and a <code>body</code> parameter containing the response body. The raw <code>res</code> object that&#39;s typically provided by <a href=\"https://github.com/Raynos/xhr\"><code>xhr</code></a> as the second parameter is provided as the third parameter instead.</p>\n<p>As an example, here is a <code>GET</code> request.</p>\n<pre><code class=\"lang-js\">taunus.xhr(&#39;/api/places&#39;, function (err, body) {\n  console.log(body);\n  // &lt;- { places: [&#39;underwater fortress&#39;, &#39;island mansion&#39;] }\n});\n</code></pre>\n<p>Always remember to handle the case where <code>err</code> is set!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"using-taunus-prefetch-url-element-\">Using <code>taunus.prefetch(url, element)</code></h1>\n<p>The prefetcher API allows you to start fetching an <code>url</code>, provided that it matches a known Taunus view route and that <a href=\"#caching\">the cache</a> is enabled. The <code>element</code> is used mostly as context during event emission, and it can be useful for debugging as well.</p>\n<p>Use cases for prefetching are further discussed in the <a href=\"/performance#enable-prefetching-for-predictive-cache-loading\">Performance Optimization</a> guide.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2 id=\"debugging-taunus\">Debugging Taunus</h2>\n<p>On the client-side, you will typically <code>require</code> Taunus using the statement below.</p>\n<pre><code class=\"lang-js\">var taunus = require(&#39;taunus&#39;);\n</code></pre>\n<p>However, you could also turn on the internal debug logger simply by using another entry point!</p>\n<pre><code class=\"lang-js\">var taunus = require(&#39;taunus/browser/debug&#39;);\n</code></pre>\n<p>The screenshot below contains an example of this mechanism, where using <a href=\"#-taunus-partial-container-action-model-\"><code>taunus.partial</code></a> triggers a flurry of debug messages.</p>\n<p><img src=\"http://i.imgur.com/CjbIHy0.png\" alt=\"debug.png\"></p>\n<p>This is particularly helpful during development, but also useful if you don&#39;t understand exactly how Taunus is doing something, as the logger is pretty verbose.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"client-side-controllers\">Client-Side Controllers</h1>\n<p>Client-side controllers are executed right after a view is rendered, even in the case of <a href=\"#-taunus-partial-container-action-model-\">partial views</a>. These controllers are used to progressively add behavior on top of the HTML for that view.</p>\n<p>View controllers take three parameters.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>model</code></td>\n<td>Model that was used to render the view</td>\n</tr>\n<tr>\n<td><code>container</code></td>\n<td>The DOM element where the view was rendered</td>\n</tr>\n<tr>\n<td><code>route?</code></td>\n<td>Route that triggered the rendering engine. May be <code>null</code></td>\n</tr>\n</tbody>\n</table>\n<p>Note that Taunus will <a href=\"#-taunus-on-type-fn-\">emit a <code>render</code> event</a> right before the view controller gets executed, giving you a chance to react to views getting rendered.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"the-taunusrc-manifest\">The <code>.taunusrc</code> manifest</h1>\n<p>If you want to use values other than the conventional defaults shown in the table below, then you should create a <code>.taunusrc</code> file. Note that the defaults need to be overwritten in a case-by-case basis. These options can also be configured in your <code>package.json</code>, under the <code>taunus</code> property.</p>\n<pre><code class=\"lang-json\">{\n  &quot;views&quot;: &quot;.bin/views&quot;,\n  &quot;server_routes&quot;: &quot;controllers/routes.js&quot;,\n  &quot;server_controllers&quot;: &quot;controllers&quot;,\n  &quot;client_controllers&quot;: &quot;client/js/controllers&quot;,\n  &quot;client_wiring&quot;: &quot;.bin/wiring.js&quot;\n}\n</code></pre>\n<ul>\n<li>The <code>views</code> directory is where your views <em>(already compiled into JavaScript)</em> are placed. These views are used directly on both the server-side and the client-side</li>\n<li>The <code>server_routes</code> file is the module where you export a collection of routes. The CLI will pull these routes when creating the client-side routes for the wiring module</li>\n<li>The <code>server_controllers</code> directory is the root directory where your server-side controllers live. It&#39;s used when setting up the server-side router</li>\n<li>The <code>client_controllers</code> directory is where your client-side controller modules live. The CLI will <code>require</code> these controllers in its resulting wiring module</li>\n<li>The <code>client_wiring</code> file is where your wiring module will be placed by the CLI. You&#39;ll then have to <code>require</code> it in your application when booting up Taunus</li>\n</ul>\n<p>Here is where things get <a href=\"http://en.wikipedia.org/wiki/Convention_over_configuration\">a little conventional</a>. Views, and both server-side and client-side controllers are expected to be organized by following the <code>{root}/{controller}/{action}</code> pattern, but you could change that using <code>resolvers</code> when invoking the CLI and using the server-side API.</p>\n<p>Views and controllers are also expected to be CommonJS modules that export a single method.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # API Documentation\n\n    Here's the API documentation for Taunus. If you've never used it before, we recommend going over the [Getting Started][1] guide before jumping into the API documentation. That way, you'll get a better idea of what to look for and how to put together simple applications using Taunus, before going through documentation on every public interface to Taunus.\n\n    Taunus exposes _three different public APIs_, and there's also **plugins to integrate Taunus and an HTTP server**. This document covers all three APIs extensively. If you're concerned about the inner workings of Taunus, please refer to the [Getting Started][1] guide. This document aims to only cover how the public interface affects application state, but **doesn't delve into implementation details**.\n\n    # Table of Contents\n\n    - A [server-side API](#server-side-api) that deals with server-side rendering\n      - The [`taunus.mount`](#-taunus-mount-addroute-options-) method\n        - Its [`options`](#the-options-object) argument\n          - [`layout`](#-options-layout-)\n          - [`routes`](#-options-routes-)\n          - [`getDefaultViewModel`](#-options-getdefaultviewmodel-)\n          - [`plaintext`](#-options-plaintext-)\n          - [`resolvers`](#-options-resolvers-)\n          - [`version`](#-options-version-)\n          - [`deferMinified`](#-options-deferminified-)\n        - Its [`addRoute`](#-addroute-definition-) argument\n      - The [`taunus.render`](#-taunus-render-action-viewmodel-req-res-next-) method\n      - The [`taunus.resolve`](#-taunus-resolve-action-data-) method\n      - The [`taunus.redirect`](#-taunus-redirect-req-res-url-) method\n      - The [`taunus.rebuildDefaultViewModel`](#-taunus-rebuilddefaultviewmodel-done-) method\n    - [Server-side controllers](#server-side-controllers)\n    - A [suite of plugins](#http-framework-plugins) can integrate Taunus and an HTTP server\n      - Using [`taunus-express`](#using-taunus-express-) for [Express][2]\n      - Using [`taunus-hapi`](#using-taunus-hapi-) for [Hapi][3]\n    - A [CLI that produces a wiring module](#command-line-interface) for the client-side\n      - The [`--output`](#-output-) flag\n      - The [`--watch`](#-watch-) flag\n      - The [`--transform <module>`](#-transform-module-) flag\n      - The [`--defer`](#-defer-actions-) flag\n      - The [`--resolvers <module>`](#-resolvers-module-) flag\n      - The [`--bundle`](#-bundle-) flag\n    - A [client-side API](#client-side-api) that deals with client-side rendering\n      - The [`taunus.mount`](#-taunus-mount-container-wiring-options-) method\n        - Using the [`auto`](#using-the-auto-strategy) strategy\n        - Using the [`inline`](#using-the-inline-strategy) strategy\n        - Using the [`manual`](#using-the-manual-strategy) strategy\n        - [Caching](#caching)\n        - [Prefetching](#prefetching)\n        - [Versioning](#versioning)\n      - The [`taunus.on`](#-taunus-on-type-fn-) method\n      - The [`taunus.once`](#-taunus-once-type-fn-) method\n      - The [`taunus.off`](#-taunus-off-type-fn-) method\n      - The [`taunus.intercept`](#-taunus-intercept-action-fn-) method\n      - The [`taunus.partial`](#-taunus-partial-container-action-model-) method\n      - The [`taunus.navigate`](#-taunus-navigate-url-options-) method\n      - The [`taunus.route`](#-taunus-route-url-startindex-) method\n        - The [`taunus.route.equals`](#-taunus-route-equals-route-route-) method\n      - The [`taunus.resolve`](#-taunus-resolve-on-the-client) method\n      - The [`taunus.state`](#-taunus-state-) property\n      - The [`taunus.xhr`](#-taunus-xhr-url-options-done-) method\n      - The [`taunus.prefetch`](#using-taunus-prefetch-url-element-) method\n      - [Debugging Taunus](#debugging-taunus)\n    - [Client-side controllers](#client-side-controllers)\n    - The [`.taunusrc`](#the-taunusrc-manifest) manifest\n\n    # Server-side API\n\n    The server-side API is used to set up the view router. It then gets out of the way, allowing the client-side to eventually take over and add any extra sugar on top, _including client-side rendering_.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.mount(addRoute, options?)`\n\n    Mounts Taunus on top of a server-side router, by registering each route in `options.routes` with the `addRoute` method.\n\n    > Note that most of the time, **this method shouldn't be invoked directly**, but rather through one of the [HTTP framework plugins](#http-framework-plugins) presented below.\n\n    Here's an incomplete example of how this method may be used. It is incomplete because route definitions have more options beyond the `route` and `action` properties.\n\n    ```js\n    'use strict';\n\n    taunus.mount(addRoute, {\n      routes: [{ route: '/', action: 'home/index' }]\n    });\n\n    function addRoute (definition) {\n      app.get(definition.route, definition.action);\n    }\n    ```\n\n    Let's go over the options you can pass to `taunus.mount` first.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### The `options?` object\n\n    There's a few options that can be passed to the server-side mountpoint. You're probably going to be passing these to your [HTTP framework plugin](#http-framework-plugins), rather than using `taunus.mount` directly.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.layout?`\n\n    The `layout` property is expected to have the `function(data)` signature. It'll be invoked whenever a full HTML document needs to be rendered, and a `data` object will be passed to it. That object will contain everything you've set as the view model, plus a `partial` property containing the raw HTML of the rendered partial view. Your `layout` method will typically wrap the raw HTML for the partial with the bare bones of an HTML document. Check out [the `layout.jade` used in Pony Foo][4] as an example.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.routes`\n\n    The other big option is `routes`, which expects a collection of route definitions. Route definitions use a number of properties to determine how the route is going to behave.\n\n    Here's an example route that uses the [Express][2] routing scheme.\n\n    ```js\n    {\n      route: '/articles/:slug',\n      action: 'articles/article',\n      ignore: false,\n      cache: <inherit>\n    }\n    ```\n\n    - `route` is a route in the format your HTTP framework of choice understands\n    - `action` is the name of your controller action. It'll be used to find the server-side controller, the default view that should be used with this route, and the client-side controller\n    - `cache` can be used to determine the client-side caching behavior in this application path, and it'll default to inheriting from the options passed to `taunus.mount` _on the client-side_\n    - `ignore` is used in those cases where you want a URL to be ignored by the client-side router even if there's a catch-all route that would match that URL\n\n    As an example of the `ignore` use case, consider the routing table shown below. The client-side router doesn't know _(and can't know unless you point it out)_ what routes are server-side only, and it's up to you to point those out.\n\n    ```js\n    [\n      { route: '/', action: '/home/index' },\n      { route: '/feed', ignore: true },\n      { route: '/*', action: 'error/not-found' }\n    ]\n    ```\n\n    This step is necessary whenever you have an anchor link pointed at something like an RSS feed. The `ignore` property is effectively telling the client-side _\"don't hijack links containing this URL\"_.\n\n    Please note that external links are never hijacked. Only same-origin links containing a URL that matches one of the routes will be hijacked by Taunus. External links don't need to be `ignore`d.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.getDefaultViewModel?`\n\n    The `getDefaultViewModel(done)` property can be a method that puts together the base view model, which will then be extended on an action-by-action basis. When you're done creating a view model, you can invoke `done(null, model)`. If an error occurs while building the view model, you should call `done(err)` instead.\n\n    Taunus will throw an error if `done` is invoked with an error, so you might want to put safeguards in place as to avoid that from happenning. The reason this method is asynchronous is because you may need database access or somesuch when putting together the defaults. The reason this is a method and not just an object is that the defaults may change due to human interaction with the application, and in those cases [the defaults can be rebuilt](#taunus-rebuilddefaultviewmodel).\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.plaintext?`\n\n    The `plaintext` options object is passed directly to [hget][5], and it's used to [tweak the plaintext version][6] of your site.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.resolvers?`\n\n    Resolvers are used to determine the location of some of the different pieces of your application. Typically you won't have to touch these in the slightest.\n\n    Signature                     | Description\n    ------------------------------|------------------------------------------------------\n    `getServerController(action)` | Return path to server-side controller action handler module\n    `getView(action)`             | Return path to view template module\n\n    The `addRoute` method passed to `taunus.mount` on the server-side is mostly going to be used internally by the HTTP framework plugins, so feel free to skip over the following section.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.version?`\n\n    Refer to the [Versioning](#versioning) section.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.getPartial?`\n\n    By default, Taunus will render partials on the server-side by looking up the module for an action method, and calling that action passing in a model.\n\n    You can override the default behavior by setting `options.getPartial` to a function. This method takes three parameters.\n\n    - `action` is the action that needs to be rendered\n    - `model` is the model you can use to render the view for that action\n    - `done(err, html)` is called when you're done, passing in the resulting `html` for the partial\n\n    Note that if you don't set `getPartial`, Taunus will just require your controller action method and invoke that instead.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.deferMinified?`\n\n    When views and controllers are lazily loaded, they are compiled and bundled using Browserify. Taunus will even produce a source map. To avoid the source map, and minify the bundle instead, set `deferMinified` to `true`.\n\n    You'll probably want to set `deferMinified` to whether the application is running on the production environment.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### `addRoute(definition)`\n\n    The `addRoute(definition)` method will be passed a route definition, containing the following properties. This method is expected to register a route in your HTTP framework's router.\n\n    - `route` is the route that you set as `definition.route`\n    - `action` is the action as passed to the route definition\n    - `actionFn` will be the controller for this action method\n    - `middleware` will be an array of methods to be executed before `actionFn`\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.render(action, viewModel, req, res, next)`\n\n    This method is almost an implementation detail as you should be using Taunus through one of the plugins anyways, so we won't go very deep into it.\n\n    The render method is what Taunus uses to render views by constructing HTML, JSON, or plaintext responses. The `action` property determines the default view that will be rendered. The `viewModel` will be extended by [the default view model](#-options-getdefaultviewmodel-), and it may also override the default `action` by setting `viewModel.model.action`.\n\n    The `req`, `res`, and `next` arguments are expected to be the Express routing arguments, but they can also be mocked _(which is in fact what the Hapi plugin does)_.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.rebuildDefaultViewModel(done?)`\n\n    Once Taunus has been mounted, calling this method will rebuild the view model defaults using the `getDefaultViewModel` that was passed to `taunus.mount` in the options. An optional `done` callback will be invoked when the model is rebuilt.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.resolve(action, data?)`\n\n    Returns the first route that matches an `action`, replacing named parameters with data from the `data` object. If a matching route is not found, `null` is returned.\n\n    > If a route is matched but a required named parameter isn't in `data`, **an exception will be thrown**.\n\n    This method is most useful when composing the URL for a redirect or an action link within a template, as a means to keep the route declaration isolated from the route itself. If the route changes, the method will reflect the newer route as long as the parameters stay the same, resulting in increased maintainability. _The method is available in both layout templates and partial view templates._\n\n    ###### Example\n\n    ```js\n    taunus.resolve('projects/project', {\n      name: 'puppies', organization: 'caniuse'\n    });\n    // <- /p/caniuse/puppies\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.redirect(req, res, url)`\n\n    Redirects the response to a different URL. If the page was being loaded for the first time, this method is equivalent to `res.redirect(url)`. If the page was being loaded via the client-side AJAX routing engine, a specially crafted JSON response will trigger a full page reload on the client-side.\n\n    ###### Example\n\n    ```js\n    taunus.redirect(req, res, '/login');\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Server-Side Controllers\n\n    On the server-side, controllers are modules that export a single function. The parameters passed to these controllers depend on the server-side HTTP framework that's being used.\n\n    For example, Express gives us three parameters: `req`, `res` and `next`. Hapi gives us two instead: `request` and `reply`.\n\n    Here's a sample controller using `taunus-express`, as [detailed below](#using-taunus-express-). This is a very simple controller where we are setting the special `viewModel` property on the response, and calling `next`. Suppose this controller is the `product/home` action handler.\n\n    ```js\n    module.exports = function (req, res, next) {\n      res.viewModel = {\n        model: {\n          title: 'view title'\n        }\n      };\n      next();\n    };\n    ```\n\n    As you can see, Taunus won't alter the API provided by Express. Instead, it builds upon the notion of using middleware. Once the `product/home` view is rendered and JavaScript loads, the `product/home` view controller is executed on the client-side.\n\n    You could change the view to be rendered by setting the `action` property on the `model`. In the example shown below this would mean that the `error/offline` view would be rendered. The client-side controller will be that of `error/offline`, as well. View controllers are tied to the view that gets rendered.\n\n    ```js\n    module.exports = function (req, res, next) {\n      res.viewModel = {\n        model: {\n          title: 'view title'\n        }\n      };\n      if (offline) {\n        res.viewModel.model.action = 'error/offline';\n      }\n      next();\n    };\n    ```\n\n    Having a default action and the ability to redirect to another gives us a lot of flexibility when determining how to respond to a request.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # HTTP Framework Plugins\n\n    There's currently two different HTTP frameworks _([Express][2] and [Hapi][3])_ that you can readily use with Taunus without having to deal with any of the route plumbing yourself.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Using `taunus-express`\n\n    The `taunus-express` plugin is probably the easiest to use, as Taunus was originally developed with just [Express][2] in mind. In addition to the options already outlined for [taunus.mount](#-taunus-mount-addroute-options-), you can add middleware for any route individually.\n\n    - `middleware` are any methods you want Taunus to execute as middleware in Express applications\n\n    To get `taunus-express` going you can use the following piece of code, provided that you come up with an `options` object.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      // ...\n    };\n\n    taunusExpress(taunus, app, options);\n    ```\n\n    The `taunusExpress` method will merely set up Taunus and add the relevant routes to your Express application by calling `app.get` a bunch of times. You can [find taunus-express on GitHub][7].\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Using `taunus-hapi`\n\n    The `taunus-hapi` plugin is a bit more involved, and you'll have to create a Pack in order to use it. In addition to [the options we've already covered](#-taunus-mount-addroute-options-), you can add `config` on any route.\n\n    - `config` is passed directly into the route registered with Hapi, giving you the most flexibility\n\n    To get `taunus-hapi` going you can use the following piece of code, and you can bring your own `options` object.\n\n    ```js\n    'use strict';\n\n    var Hapi = require('hapi');\n    var taunus = require('taunus');\n    var taunusHapi = require('taunus-hapi')(taunus);\n    var pack = new Hapi.Pack();\n\n    pack.register({\n      plugin: taunusHapi,\n      options: {\n        // ...\n      }\n    });\n    ```\n\n    The `taunusHapi` plugin will mount Taunus and register all of the necessary routes. You can [find taunus-hapi on GitHub][8].\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Command-Line Interface\n\n    Once you've set up the server-side to render your views using Taunus, it's only logical that you'll want to render the views in the client-side as well, effectively converting your application into a single-page application after the first view has been rendered on the server-side.\n\n    The Taunus CLI is an useful intermediary in the process of getting the configuration you wrote so far for the server-side to also work well in the client-side.\n\n    Install it globally for development, but remember to use local copies for production-grade uses.\n\n    ```shell\n    npm install -g taunus\n    ```\n\n    When invoked without any arguments, the CLI will simply follow the default conventions to find your route definitions, views, and client-side controllers.\n\n    ```shell\n    taunus\n    ```\n\n    By default, the output will be printed to the standard output, making for a fast debugging experience. Here's the output if you just had a single `home/index` route, and the matching view and client-side controller existed.\n\n    ```js\n    'use strict';\n\n    var templates = {\n      'home/index': require('./views/home/index.js')\n    };\n\n    var controllers = {\n      'home/index': require('../client/js/controllers/home/index.js')\n    };\n\n    var routes = [\n      {\n        route: '/',\n        action: 'home/index'\n      }\n    ];\n\n    module.exports = {\n      templates: templates,\n      controllers: controllers,\n      routes: routes\n    };\n    ```\n\n    You can use a few options to alter the outcome of invoking `taunus`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--output`\n\n    <sub>the `-o` alias is available</sub>\n\n    Output is written to a file instead of to standard output. The file path used will be the `client_wiring` option in [`.taunusrc`](#the-taunusrc-manifest), which defaults to `'.bin/wiring.js'`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--watch`\n\n    <sub>the `-w` alias is available</sub>\n\n    Whenever a server-side route definition changes, the output is printed again to either standard output or a file, depending on whether `--output` was used.\n\n    The program won't exit.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--transform <module>`\n\n    <sub>the `-t` alias is available</sub>\n\n    This flag allows you to transform server-side routes into something the client-side understands. Express routes are completely compatible with the client-side router, but Hapi routes need to be transformed using the [`hapiify`][9] module.\n\n    ```shell\n    npm install hapiify\n    taunus -t hapiify\n    ```\n\n    Using this transform relieves you from having to define the same routes twice using slightly different formats that convey the same meaning.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--defer [actions]`\n\n    <sub>the `-d` alias is available</sub>\n\n    Here is where things get interesting. The `--defer` flag allows you to defer loading for zero or more actions. Excluding the controller and view templates for any deferred action can significantly reduce the fingerprint of your application.\n\n    The `[actions]` argument determines what actions get deferred, and which don't. It expects a comma-separated list of actions, where you can pass in either the controller name, or both the controller name and the action name. Using `?` acts as a wildcard.\n\n    For example, using `admin` _(equivalent to using `admin/?`)_ will defer every action under the `admin` controller. Using `admin/nuke` will only defer the `admin/nuke` action. If you omit the `[actions]` parameter entirely, the default value of `'?'` will be used and everything will be deferred.\n\n    When components get deferred, they'll be loaded as soon as Taunus detects that they're needed. This can happen in a few places.\n\n    - The user navigates to (or [_prefetches_](#prefetching)) the `/admin` route, and `admin/index` was deferred, and its components aren't cached on the client-side yet\n    - A controller uses `taunus.partial` to render an action that was deferred, and its components aren't cached on the client-side yet\n    - The user navigates to the `/admin` route, and its matching `admin/index` route wasn't deferred, but the server-side controller decides to change the action to `admin/superadmin`. When the response gets to the client, it'll need to ask the server for the `admin/superadmin` template if the client doesn't already have it\n\n    You don't have to worry about those different scenarios, though, as Taunus handles them all for you transparently. You should [learn more about deferred loading on the Performance Optimization guide][20].\n\n    > A possible concern with deferred execution is that partial views may not be rendered immediately, as a request may be necessary to fetch the controller or template for the partial.\n\n    Some other considerations, regarding how deferred components get bundled, are listed in the [Performance Optimization][20] guide.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--resolvers <module>`\n\n    <sub>the `-r` alias is available</sub>\n\n    Similarly to the [`resolvers`](#-options-resolvers-) option that you can pass to [`taunus.mount`](#-taunus-mount-addroute-options-), these resolvers can change the way in which file paths are resolved.\n\n    Signature                     | Description\n    ------------------------------|------------------------------------------------------\n    `getClientController(action)` | Return path to client-side controller action handler module\n    `getView(action)`             | Return path to view template module\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--bundle`\n\n    <sub>the `-b` alias is available</sub>\n\n    Under this experimental flag, the CLI will use Browserify to compile a standalone module that includes the wiring normally exported by the CLI plus all of Taunus [as a UMD module][10].\n\n    This allows you to use Taunus on the client-side even if you don't want to use [Browserify][11] directly.\n\n    Feedback and suggestions about this flag, _and possible alternatives that would make Taunus easier to use_, are welcome.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Client-side API\n\n    Just like the server-side, everything in the client-side begins at the mountpoint. Once the application is mounted, anchor links will be hijacked and the client-side router will take over view rendering. Client-side controllers are executed whenever a view is rendered.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.mount(container, wiring, options?)`\n\n    The mountpoint takes a root container, the wiring module, and an options parameter. The `container` is where client-side-rendered views will be placed, by replacing whatever HTML contents already exist. You can pass in the `wiring` module exactly as built by the CLI, and no further configuration is necessary.\n\n    When the mountpoint executes, Taunus will configure its internal state, _set up the client-side router_, run the client-side controller for the server-side rendered view, and start hijacking links.\n\n    As an example, consider a browser makes a `GET` request for `/articles/the-fox` for the first time. Once `taunus.mount(container, wiring)` is invoked on the client-side, several things would happen in the order listed below.\n\n    - Taunus sets up the client-side view routing engine\n    - If enabled _(via `options`)_, the caching engine is configured\n    - Taunus obtains the view model _(more on this later)_\n    - When a view model is obtained, the `'start'` event is emitted\n    - Anchor links start being monitored for clicks _(at this point your application becomes a [SPA][13])_\n    - The `articles/article` client-side controller is executed\n\n    That's quite a bit of functionality, but if you think about it, most other frameworks also render the view at this point, _rather than on the server-side!_\n\n    In order to better understand the process, I'll walk you through the `options` parameter.\n\n    First off, the `bootstrap` option determines the strategy used to pull the view model of the server-side rendered view into the client-side. There are three possible strategies available: `auto` _(the default strategy)_, `inline`, or `manual`. The `auto` strategy involves the least work, which is why it's the default.\n\n    - `auto` will make an AJAX request for the view model\n    - `inline` expects you to place the model into a `<script type='text/taunus'>` tag\n    - `manual` expects you to get the view model however you want to, and then let Taunus know when it's ready\n\n    Let's go into detail about each of these strategies.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `auto` strategy\n\n    The `auto` strategy means that Taunus will make use of an AJAX request to obtain the view model. _You don't have to do anything else_ and this is the default strategy. This is the **most convenient strategy, but also the slowest** one.\n\n    It's slow because the view model won't be requested until the bulk of your JavaScript code has been downloaded, parsed, executed, and `taunus.mount` is invoked.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `inline` strategy\n\n    The `inline` strategy expects you to add a `data-taunus` attribute on the `container` element. This attribute must be equal to the `id` attribute of a `<script>` tag containing the serialized view model alongside the version information automatically injected by Taunus into the layout template data.\n\n    ```jade\n    div(data-taunus='model')!=partial\n    script(type='text/taunus', data-taunus='model')=JSON.stringify({ version: version, model: model })\n    ```\n\n    Pay special attention to the fact that the model is not only made into a JSON string, _but also HTML encoded by Jade_. When Taunus extracts the model from the `<script>` tag it'll unescape it, and then parse it as JSON.\n\n    This strategy is also fairly convenient to set up, but it involves a little more work. It might be worthwhile to use in cases where models are small, but it will slow down server-side view rendering, as the model is inlined alongside the HTML.\n\n    That means that the content you are supposed to be prioritizing is going to take longer to get to your humans, but once they get the HTML, this strategy will execute the client-side controller almost immediately.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `manual` strategy\n\n    The `manual` strategy is the most involved of the three, but also the most performant. In this strategy you're supposed to add the following _(seemingly pointless)_ snippet of code in a `<script>` other than the one that's pulling down Taunus, so that they are pulled concurrently rather than serially.\n\n    ```js\n    'use strict';\n\n    window.taunusReady = function (model) {\n      window.taunusReady = model;\n    };\n    ```\n\n    Once you somehow get your hands on the view model, you should invoke `taunusReady(model)`. Considering you'll be pulling both the view model and Taunus at the same time, a number of different scenarios may play out.\n\n    - The view model is loaded first, you call `taunusReady(model)` and wait for Taunus to take the model object and boot the application as soon as `taunus.mount` is executed\n    - Taunus loads first and `taunus.mount` is called first. In this case, Taunus will replace `window.taunusReady` with a special `boot` method. When the view model finishes loading, you call `taunusReady(model)` and the application finishes booting\n\n    > If this sounds a little mind-bending it's because it is. It's not designed to be pretty, but merely to be performant.\n\n    Now that we've addressed the awkward bits, let's cover the _\"somehow get your hands on the view model\"_ aspect. My preferred method is using JSONP, as it's able to deliver the smallest snippet possible, and it can take advantage of server-side caching. Considering you'll probably want this to be an inline script, keeping it small is important.\n\n    The good news is that the server-side supports JSONP out the box. Here's a snippet of code you could use to pull down the view model and boot Taunus up as soon as both operations are ready.\n\n    ```js\n    'use strict';\n\n    function inject (url) {\n      var script = document.createElement('script');\n      script.src = url;\n      document.body.appendChild(script);\n    }\n\n    function injector () {\n      var search = location.search;\n      var searchQuery = search ? '&' + search.substr(1) : '';\n      var searchJson = '?json&callback=taunusReady' + searchQuery;\n      inject(location.pathname + searchJson);\n    }\n\n    window.taunusReady = function (model) {\n      window.taunusReady = model;\n    };\n\n    injector();\n    ```\n\n    As mentioned earlier, this approach involves getting your hands dirtier but it pays off by being the fastest of the three.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Caching\n\n    The client-side in Taunus supports caching in-memory and using the embedded IndexedDB system by merely turning on the `cache` flag in the options passed to `taunus.mount` on the client-side.\n\n    If you set `cache` to `true` then cached items will be considered _\"fresh\" (valid copies of the original)_ for **15 seconds**. You can also set `cache` to a number, and that number of seconds will be used as the default instead.\n\n    Caching can also be tweaked on individual routes. For instance, you could set `{ cache: true }` when mounting Taunus and then have `{ cache: 3600 }` on a route that you want to cache for a longer period of time.\n\n    The caching layer is _seamlessly integrated_ into Taunus, meaning that any views rendered by Taunus will be cached according to these caching rules. Keep in mind, however, that persistence at the client-side caching layer will only be possible in [browsers that support IndexedDB][14]. In the case of browsers that don't support IndexedDB, Taunus will use an in-memory cache, which will be wiped out whenever the human decides to close the tab in their browser.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Prefetching\n\n    If caching is enabled, the next logical step is prefetching. This is enabled just by adding `prefetch: true` to the options passed to `taunus.mount`. The prefetching feature will fire for any anchor link that's trips over a `mouseover` or a `touchstart` event. If a route matches the URL in the `href`, an AJAX request will prefetch the view and cache its contents, improving perceived performance.\n\n    When links are clicked before prefetching finishes, they'll wait on the prefetcher to finish before immediately switching to the view, effectively cutting down the response time. If the link was already prefetched or otherwise cached, the view will be loaded immediately. If the human hovers over a link and another one was already being prefetched, then that one is aborted. This prevents prefetching from draining the bandwidth on clients with limited or intermittent connectivity.\n\n    #### Versioning\n\n    When enabled, versioning will look out for discrepancies between what's currently on the client and what's on the server, and reload everything necessary to make what's on the client match what's on the server.\n\n    In order to turn it on, set the `version` field in the options when invoking `taunus.mount` **on both the server-side and the client-side, using the same value**. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.\n\n    > To make sure you don't forget to change the version string in one of the mountpoints, please create a JSON file with just the version string and `require` that file in both sides.\n    >\n    > ```shell\n    > echo '\"1.0.0\"' > version.json\n    > ```\n\n    The default version string is set to `1`. The Taunus version will be prepended to yours, resulting in a value such as `t3.0.0;v1` where Taunus is running version `3.0.0` and your application is running version `1`.\n\n    Refer to the Getting Started guide for a more detailed [analysis of the uses for versioning][15]. There's some more nuggets of information in the [Performance Optimization][18] guide as well.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.on(type, fn)`\n\n    Taunus emits a series of events during its lifecycle, and `taunus.on` is the way you can tune in and listen for these events using a subscription function `fn`.\n\n    Event            | Arguments                 | Description\n    -----------------|---------------------------|------------------------------------\n    `'start'`        | `container, model, route` | Emitted when `taunus.mount` finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling `taunus.mount`.\n    `'render'`       | `container, model, route` | A view has just been rendered and its client-side controller is about to be invoked\n    `'change'`       | `route, model`            | Same as `'render'`, but only if `container` is the mountpoint and the route has changed.\n    `'fetch.start'`  |  `route, context`         | Emitted whenever an XHR request starts.\n    `'fetch.done'`   |  `route, context, data`   | Emitted whenever an XHR request ends successfully.\n    `'fetch.abort'`  |  `route, context`         | Emitted whenever an XHR request is purposely aborted.\n    `'fetch.error'`  |  `route, context, err`    | Emitted whenever an XHR request results in an HTTP error.\n\n    Consider for instance that you'd like to keep track of every view that gets rendered, and what DOM element it gets placed into. The piece of code below would quickly do that for us.\n\n    ```js\n    taunus.on('render', function (container) {\n      console.log('Rendered a view on', container);\n    });\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.once(type, fn)`\n\n    This method is equivalent to [`taunus.on`](#-taunus-on-type-fn-), except the event listeners will be used once and then it'll be discarded.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.off(type, fn)`\n\n    Using this method you can remove any event listeners that were previously added using `.on` or `.once`. You must provide the type of event you want to remove and a reference to the event listener function that was originally used when calling `.on` or `.once`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.intercept(action?, fn)`\n\n    This method can be used to anticipate model requests, before they ever make it into XHR requests. You can add interceptors for specific actions, which would be triggered only if the request matches the specified `action`. You can also add global interceptors by omitting the `action` parameter, or setting it to `*`.\n\n    An interceptor function will receive an `event` parameter, containing a few different properties.\n\n    - `url` contains the URL that needs a view model\n    - `route` contains the full route object as you'd get from [`taunus.route(url, startIndex?)`](#-taunus-route-url-startindex-)\n    - `parts` is just a shortcut for `route.parts`\n    - `preventDefault(data)` allows you to suppress the need for an AJAX request, commanding Taunus to use the response data you've provided instead\n    - `defaultPrevented` tells you if some other handler has prevented the default behavior\n    - `canPreventDefault` tells you if invoking `event.preventDefault` will have any effect\n    - `data` starts as `null`, and it can later become the data passed to `preventDefault`\n\n    Interceptors are asynchronous, but if an interceptor spends longer than 50ms it'll be short-circuited and calling `event.preventDefault` past that point won't have any effect.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.partial(container, action, model)`\n\n    This method provides you with access to the view-rendering engine of Taunus. You can use it to render the `action` view into the `container` DOM element, using the specified `model`. Once the view is rendered, the `render` event will be fired _(with `container, model` as arguments)_ and the client-side controller for that view will be executed.\n\n    Note that the partial may be rendered asynchronously if the `action` is [deferred](#-defer-actions-) and its components (view template, controller) aren't readily available in the client yet.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.navigate(url, options)`\n\n    Whenever you want to navigate to a URL, say when an AJAX call finishes after a button click, you can use `taunus.navigate` passing it a plain URL or anything that would cause `taunus.route(url, startIndex?)` to return a valid route.\n\n    By default, if `taunus.navigate(url, options)` is called with an `url` that doesn't match any client-side route, then the user will be redirected via `location.href`. In cases where the browser doesn't support the history API, `location.href` will be used as well.\n\n    There's a few options you can use to tweak the behavior of `taunus.navigate`.\n\n    Option           | Description\n    -----------------|-------------------------------------------------------------------\n    `context`        | A DOM element that caused the navigation event, used when emitting events\n    `strict`         | If set to `true` and the URL doesn't match any route, then the navigation attempt must be ignored\n    `scroll`         | When this is set to `false`, elements aren't scrolled into view after navigation\n    `force`          | Unless this is set to `true`, navigation won't _fetch a model_ if the route matches the current route, and `state.model` will be reused instead\n    `replaceState`   | Use `replaceState` instead of `pushState` when changing history\n\n    Note that the notion of _fetching a model_ might be deceiving as the model could be pulled from the cache even if `force` is set to `true`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.route(url, startIndex?)`\n\n    This convenience method allows you to break down a URL into its individual components. The method accepts any of the following URL patterns, and it returns a Taunus route object. The optional `startIndex` argument specifies what index to start at, as seen on `taunus.state.routes`.\n\n    - A fully qualified URL on the same origin, e.g `http://taunus.bevacqua.io/api`\n    - An absolute URL without an origin, e.g `/api`\n    - Just a hash, e.g `#foo` _(`location.href` is used)_\n    - Falsy values, e.g `null` _(`location.href` is used)_\n\n    Relative URLs are not supported _(anything that doesn't have a leading slash)_, e.g `files/data.json`. Anything that's not on the same origin or doesn't match one of the registered routes is going to yield `null`.\n\n    _This method is particularly useful when debugging your routing tables, as it gives you direct access to the router used internally by Taunus._\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### `taunus.route.equals(route, route)`\n\n    Compares two routes and returns `true` if they would fetch the same model. Note that different URLs may still return `true`. For instance, `/foo` and `/foo#bar` would fetch the same model even if they're different URLs.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.resolve` on the client\n\n    This method is identical to the server-side flavor of [`taunus.resolve(action, data)`](#-taunus-resolve-action-data-), but available on the client-side.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.state`\n\n    This is an internal state variable, and it contains a lot of useful debugging information.\n\n    - `container` is the DOM element passed to `taunus.mount`\n    - `controllers` are all the controllers, as defined in the wiring module\n    - `templates` are all the templates, as defined in the wiring module\n    - `routes` are all the routes, as defined in the wiring module\n    - `route` is a reference to the current route\n    - `model` is a reference to the model used to render the current view\n    - `prefetch` exposes whether prefetching is turned on\n    - `cache` exposes whether caching is enabled\n    - `version` exposes the version string that's currently in use\n\n    There's also a `clear` method accessible through `taunus.state.clear`, which will empty the cache, as well as remove from the `state` any controllers and templates that were lazy loaded.\n\n    Of course, you're not supposed to meddle with it, so be a good citizen and just inspect its values!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.xhr(url, options?, done)`\n\n    This method allows you to issue your own AJAX requests through the `xhr` module. It sets a few convenient defaults, _listed below_, where `url` refers to the URL passed as the first parameter.\n\n    ```js\n    {\n      url: url,\n      json: true,\n      headers: { Accept: 'application/json' }\n    }\n    ```\n\n    The `done(err, body, res)` callback will be invoked when the request finishes, and it'll be passed three parameters, an optional error if something went wrong _(request failed, was aborted, etc.)_ and a `body` parameter containing the response body. The raw `res` object that's typically provided by [`xhr`][16] as the second parameter is provided as the third parameter instead.\n\n    As an example, here is a `GET` request.\n\n    ```js\n    taunus.xhr('/api/places', function (err, body) {\n      console.log(body);\n      // <- { places: ['underwater fortress', 'island mansion'] }\n    });\n    ```\n\n    Always remember to handle the case where `err` is set!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Using `taunus.prefetch(url, element)`\n\n    The prefetcher API allows you to start fetching an `url`, provided that it matches a known Taunus view route and that [the cache](#caching) is enabled. The `element` is used mostly as context during event emission, and it can be useful for debugging as well.\n\n    Use cases for prefetching are further discussed in the [Performance Optimization][19] guide.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Debugging Taunus\n\n    On the client-side, you will typically `require` Taunus using the statement below.\n\n    ```js\n    var taunus = require('taunus');\n    ```\n\n    However, you could also turn on the internal debug logger simply by using another entry point!\n\n    ```js\n    var taunus = require('taunus/browser/debug');\n    ```\n\n    The screenshot below contains an example of this mechanism, where using [`taunus.partial`](#-taunus-partial-container-action-model-) triggers a flurry of debug messages.\n\n    ![debug.png][17]\n\n    This is particularly helpful during development, but also useful if you don't understand exactly how Taunus is doing something, as the logger is pretty verbose.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Client-Side Controllers\n\n    Client-side controllers are executed right after a view is rendered, even in the case of [partial views](#-taunus-partial-container-action-model-). These controllers are used to progressively add behavior on top of the HTML for that view.\n\n    View controllers take three parameters.\n\n    Parameter   | Description\n    ------------|--------------------------\n    `model`     | Model that was used to render the view\n    `container` | The DOM element where the view was rendered\n    `route?`    | Route that triggered the rendering engine. May be `null`\n\n    Note that Taunus will [emit a `render` event](#-taunus-on-type-fn-) right before the view controller gets executed, giving you a chance to react to views getting rendered.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # The `.taunusrc` manifest\n\n    If you want to use values other than the conventional defaults shown in the table below, then you should create a `.taunusrc` file. Note that the defaults need to be overwritten in a case-by-case basis. These options can also be configured in your `package.json`, under the `taunus` property.\n\n    ```json\n    {\n      \"views\": \".bin/views\",\n      \"server_routes\": \"controllers/routes.js\",\n      \"server_controllers\": \"controllers\",\n      \"client_controllers\": \"client/js/controllers\",\n      \"client_wiring\": \".bin/wiring.js\"\n    }\n    ```\n\n    - The `views` directory is where your views _(already compiled into JavaScript)_ are placed. These views are used directly on both the server-side and the client-side\n    - The `server_routes` file is the module where you export a collection of routes. The CLI will pull these routes when creating the client-side routes for the wiring module\n    - The `server_controllers` directory is the root directory where your server-side controllers live. It's used when setting up the server-side router\n    - The `client_controllers` directory is where your client-side controller modules live. The CLI will `require` these controllers in its resulting wiring module\n    - The `client_wiring` file is where your wiring module will be placed by the CLI. You'll then have to `require` it in your application when booting up Taunus\n\n    Here is where things get [a little conventional][12]. Views, and both server-side and client-side controllers are expected to be organized by following the `{root}/{controller}/{action}` pattern, but you could change that using `resolvers` when invoking the CLI and using the server-side API.\n\n    Views and controllers are also expected to be CommonJS modules that export a single method.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    [1]: /getting-started\n    [2]: http://expressjs.com\n    [3]: http://hapijs.com\n    [4]: https://github.com/ponyfoo/ponyfoo/blob/33271751312db6e92059d98293d0a7ac6e9e8e5b/views/server/layout/layout.jade\n    [5]: https://github.com/bevacqua/hget\n    [6]: https://github.com/ponyfoo/ponyfoo/blob/f6d6b5068ff03a387f503900160d9fdc1e749750/controllers/routing.js#L70-L72\n    [7]: https://github.com/taunus/taunus-express\n    [8]: https://github.com/taunus/taunus-hapi\n    [9]: https://github.com/taunus/hapiify\n    [10]: https://github.com/umdjs/umd\n    [11]: http://browserify.org\n    [12]: http://en.wikipedia.org/wiki/Convention_over_configuration\n    [13]: http://en.wikipedia.org/wiki/Single-page_application\n    [14]: http://caniuse.com/#feat=indexeddb\n    [15]: /getting-started#versioning\n    [16]: https://github.com/Raynos/xhr\n    [17]: http://i.imgur.com/CjbIHy0.png\n    [18]: /performance#use-versioning-to-ensure-cache-validity\n    [19]: /performance#enable-prefetching-for-predictive-cache-loading\n    [20]: /performance#send-views-and-controllers-to-the-client-selectively\n");
}
}
},{"jadum/runtime":32}],8:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function complements(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/complements.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/complements.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/complements.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/complements.jade" });
buf.push("<h1 id=\"complementary-modules\">Complementary Modules</h1>\n<p>Taunus is a small library by MVC framework standards, sitting <strong>below 15kB minified and gzipped</strong>. It is designed to be small. It is also designed to do one thing well, and that&#39;s <em>being a shared-rendering MVC engine</em>.</p>\n<p>Taunus can be used for routing, putting together controllers, models and views to handle human interaction. If you <a href=\"/api\">head over to the API documentation</a>, you&#39;ll notice that the server-side API, the command-line interface, and the <code>.taunusrc</code> manifest are only concerned with providing a conventional shared-rendering MVC engine.</p>\n<p>In the server-side you might need to do other things besides routing and rendering views, and other modules can take care of that. However, you&#39;re used to having database access, search, logging, and a variety of services handled by separate libraries, instead of a single behemoth that tries to do everything.</p>\n<blockquote>\n<p>In the client-side, you might be used to your MVC framework of choice resolving everything on your behalf, from DOM manipulation and data-binding to hooking up with a REST API, and everywhere in between.</p>\n</blockquote>\n<p>Taunus attempts to bring the server-side mentality of <em>&quot;not doing everything is okay&quot;</em> into the world of client-side web application development as well. To that end, Taunus recommends that you give a shot to libraries that also do <strong>one thing well</strong>.</p>\n<p>In this brief article we&#39;ll recommend a couple different libraries that play well with Taunus, and you&#39;ll also learn how to search for modules that can give you access to other functionality you may be interested in.</p>\n<h1 id=\"using-dominus-for-dom-querying\">Using <code>dominus</code> for DOM querying</h1>\n<p><a href=\"https://github.com/bevacqua/dominus\">Dominus</a> is an extra-small DOM querying library, currently clocking around <strong>4kB minified and gzipped</strong>, almost <em>ten times smaller</em> than it&#39;s competition. Unlike jQuery and popular friends, Dominus doesn&#39;t provide AJAX features, layout math, <code>&lt;form&gt;</code> manipulation, promises, tens of event binding methods, a selector engine written in plain JavaScript, nor a myriad of utility functions. Instead, Dominus focuses solely on providing a rich DOM querying and manipulation API that gets rid of inconsistencies across browsers.</p>\n<p>While the API isn&#39;t exactly compatible with jQuery, it is definitely familiar to the jQuery adept. Chaining, versatility, expressiveness, and raw power are all core concerns for Dominus. You&#39;ll find that Dominus has more consistently named methods, given that it was built with a concise API in mind.</p>\n<p>There&#39;s a few differences in semantics, and I believe that&#39;s a good thing. For instance, if you do <code>.value</code> on a checkbox or radio button you&#39;ll get back whether the input is checked. Similarly, if you call <code>.text</code> on the input you&#39;ll get the text back, which is most often what you wanted to get.</p>\n<pre><code class=\"lang-js\">var a = require(&#39;dominus&#39;);\nvar b = jQuery;\n\na(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, value: &#39;Foo&#39; }).text();\n// &lt;- &#39;Foo&#39;\n\na(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, checked: true }).value();\n// &lt;- true\n\nb(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, value: &#39;Foo&#39; }).text();\n// &lt;- &#39;&#39;\n\nb(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, checked: true }).val();\n// &lt;- &#39;Foo&#39;\n</code></pre>\n<p>One of the best aspects of Dominus, <em>besides its small size</em>, is the fact that it extends native JavaScript arrays <em>(using <a href=\"https://github.com/bevacqua/poser\"><code>poser</code></a>)</em>. That means you have access to all of the <code>Array</code> functional methods on any <code>Dominus</code> collections, such as <code>.forEach</code>, <code>.map</code>, <code>.filter</code>, <code>.sort</code> and so on.</p>\n<p>Taunus doesn&#39;t make any extensive DOM manipulation <em>(nor querying)</em> and doesn&#39;t need to use Dominus, but it may find a home in your application.</p>\n<p>You can check out the <em>complete API documentation</em> for <code>dominus</code> on <a href=\"https://github.com/bevacqua/dominus\">its GitHub repository</a>.</p>\n<h1 id=\"using-xhr-to-make-ajax-requests\">Using <code>xhr</code> to make AJAX requests</h1>\n<p>A small program called <a href=\"https://github.com/Raynos/xhr\"><code>xhr</code></a> can be used to make AJAX requests and it&#39;s bundled with Taunus, because it needs it internally to communicate with the server. As such, it was trivial for Taunus to expose this engine and give you the ability to make AJAX calls of your own using it as well.</p>\n<p>You can check out <a href=\"/api#-taunus-xhr-url-options-done-\">the API documentation</a> for an explanation of how our interface to <code>xhr</code> works, or you could also <a href=\"https://github.com/Raynos/xhr\">see their API documentation</a> and use that directly instead.</p>\n<h1 id=\"complementing-your-code-with-small-modules\">Complementing your code with small modules</h1>\n<p>There&#39;s an infinite number of modules that do just one thing well and are eager to be part of your applications. Leverage the Internet to find what you need. Small libraries tend to be better documented, concise to use, and simpler.</p>\n<p>Here&#39;s a few examples of modules you could consider.</p>\n<ul>\n<li><a href=\"https://github.com/yyx990803/vue\"><code>vue</code></a> gives you MVVM capabilities</li>\n<li><a href=\"https://github.com/polymer/observe-js\"><code>observe-js</code></a> to get data-binding</li>\n<li><a href=\"https://github.com/Matt-Esch/virtual-dom\"><code>virtual-dom</code></a> to use a virtual DOM diffing algorithm a la <a href=\"https://github.com/facebook/react\">Facebook React</a></li>\n<li><a href=\"https://github.com/bevacqua/hint\"><code>hint</code></a> progressively enhances your HTML giving you more colorful tooltips</li>\n<li><a href=\"https://github.com/bevacqua/rome\"><code>rome</code></a> is a small calendar component</li>\n</ul>\n<p>You can look for relevant modules using <a href=\"http://browserifysearch.org/\">BrowserifySearch.org</a>, the <a href=\"https://www.npmjs.org/\"><code>npm</code> search</a>, asking around on Twitter, or just by Googling!</p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # Complementary Modules\n\n    Taunus is a small library by MVC framework standards, sitting **below 15kB minified and gzipped**. It is designed to be small. It is also designed to do one thing well, and that's _being a shared-rendering MVC engine_.\n\n    Taunus can be used for routing, putting together controllers, models and views to handle human interaction. If you [head over to the API documentation][1], you'll notice that the server-side API, the command-line interface, and the `.taunusrc` manifest are only concerned with providing a conventional shared-rendering MVC engine.\n\n    In the server-side you might need to do other things besides routing and rendering views, and other modules can take care of that. However, you're used to having database access, search, logging, and a variety of services handled by separate libraries, instead of a single behemoth that tries to do everything.\n\n    > In the client-side, you might be used to your MVC framework of choice resolving everything on your behalf, from DOM manipulation and data-binding to hooking up with a REST API, and everywhere in between.\n\n    Taunus attempts to bring the server-side mentality of _\"not doing everything is okay\"_ into the world of client-side web application development as well. To that end, Taunus recommends that you give a shot to libraries that also do **one thing well**.\n\n    In this brief article we'll recommend a couple different libraries that play well with Taunus, and you'll also learn how to search for modules that can give you access to other functionality you may be interested in.\n\n    # Using `dominus` for DOM querying\n\n    [Dominus][2] is an extra-small DOM querying library, currently clocking around **4kB minified and gzipped**, almost _ten times smaller_ than it's competition. Unlike jQuery and popular friends, Dominus doesn't provide AJAX features, layout math, `<form>` manipulation, promises, tens of event binding methods, a selector engine written in plain JavaScript, nor a myriad of utility functions. Instead, Dominus focuses solely on providing a rich DOM querying and manipulation API that gets rid of inconsistencies across browsers.\n\n    While the API isn't exactly compatible with jQuery, it is definitely familiar to the jQuery adept. Chaining, versatility, expressiveness, and raw power are all core concerns for Dominus. You'll find that Dominus has more consistently named methods, given that it was built with a concise API in mind.\n\n    There's a few differences in semantics, and I believe that's a good thing. For instance, if you do `.value` on a checkbox or radio button you'll get back whether the input is checked. Similarly, if you call `.text` on the input you'll get the text back, which is most often what you wanted to get.\n\n    ```js\n    var a = require('dominus');\n    var b = jQuery;\n\n    a('<input>').attr({ type: 'radio', value: 'Foo' }).text();\n    // <- 'Foo'\n\n    a('<input>').attr({ type: 'radio', checked: true }).value();\n    // <- true\n\n    b('<input>').attr({ type: 'radio', value: 'Foo' }).text();\n    // <- ''\n\n    b('<input>').attr({ type: 'radio', checked: true }).val();\n    // <- 'Foo'\n    ```\n\n    One of the best aspects of Dominus, _besides its small size_, is the fact that it extends native JavaScript arrays _(using [`poser`][5])_. That means you have access to all of the `Array` functional methods on any `Dominus` collections, such as `.forEach`, `.map`, `.filter`, `.sort` and so on.\n\n    Taunus doesn't make any extensive DOM manipulation _(nor querying)_ and doesn't need to use Dominus, but it may find a home in your application.\n\n    You can check out the _complete API documentation_ for `dominus` on [its GitHub repository][2].\n\n    # Using `xhr` to make AJAX requests\n\n    A small program called [`xhr`][4] can be used to make AJAX requests and it's bundled with Taunus, because it needs it internally to communicate with the server. As such, it was trivial for Taunus to expose this engine and give you the ability to make AJAX calls of your own using it as well.\n\n    You can check out [the API documentation][6] for an explanation of how our interface to `xhr` works, or you could also [see their API documentation][4] and use that directly instead.\n\n    # Complementing your code with small modules\n\n    There's an infinite number of modules that do just one thing well and are eager to be part of your applications. Leverage the Internet to find what you need. Small libraries tend to be better documented, concise to use, and simpler.\n\n    Here's a few examples of modules you could consider.\n\n    - [`vue`][15] gives you MVVM capabilities\n    - [`observe-js`][7] to get data-binding\n    - [`virtual-dom`][8] to use a virtual DOM diffing algorithm a la [Facebook React][9]\n    - [`hint`][10] progressively enhances your HTML giving you more colorful tooltips\n    - [`rome`][11] is a small calendar component\n\n    You can look for relevant modules using [BrowserifySearch.org][13], the [`npm` search][14], asking around on Twitter, or just by Googling!\n\n    [1]: /api\n    [2]: https://github.com/bevacqua/dominus\n    [4]: https://github.com/Raynos/xhr\n    [5]: https://github.com/bevacqua/poser\n    [6]: /api#-taunus-xhr-url-options-done-\n    [7]: https://github.com/polymer/observe-js\n    [8]: https://github.com/Matt-Esch/virtual-dom\n    [9]: https://github.com/facebook/react\n    [10]: https://github.com/bevacqua/hint\n    [11]: https://github.com/bevacqua/rome\n    [12]: https://github.com/bevacqua/hint\n    [13]: http://browserifysearch.org/\n    [14]: https://www.npmjs.org/\n    [15]: https://github.com/yyx990803/vue\n");
}
}
},{"jadum/runtime":32}],9:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function gettingStarted(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/getting-started.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/getting-started.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/getting-started.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/getting-started.jade" });
buf.push("<h1 id=\"getting-started\">Getting Started</h1>\n<p>Taunus is a shared-rendering MVC engine for Node.js, and it&#39;s <em>up to you how to use it</em>. In fact, it might be a good idea for you to <strong>set up just the server-side aspect first</strong>, as that&#39;ll teach you how it works even when JavaScript never gets to the client.</p>\n<h1 id=\"table-of-contents\">Table of Contents</h1>\n<ul>\n<li><a href=\"#how-it-works\">How it works</a></li>\n<li><a href=\"#installing-taunus\">Installing Taunus</a></li>\n<li><a href=\"#setting-up-the-server-side\">Setting up the server-side</a><ul>\n<li><a href=\"#your-first-route\">Your first route</a></li>\n<li><a href=\"#creating-a-layout\">Creating a layout</a></li>\n<li><a href=\"#using-jade-as-your-view-engine\">Using Jade as your view engine</a></li>\n<li><a href=\"#throwing-in-a-controller\">Throwing in a controller</a></li>\n</ul>\n</li>\n<li><a href=\"#taunus-in-the-client\">Taunus in the client</a><ul>\n<li><a href=\"#using-the-taunus-cli\">Using the Taunus CLI</a></li>\n<li><a href=\"#booting-up-the-client-side-router\">Booting up the client-side router</a></li>\n<li><a href=\"#adding-functionality-in-a-client-side-controller\">Adding functionality in a client-side controller</a></li>\n<li><a href=\"#compiling-your-client-side-javascript\">Compiling your client-side JavaScript</a></li>\n<li><a href=\"#using-the-client-side-taunus-api\">Using the client-side Taunus API</a></li>\n<li><a href=\"#caching-and-prefetching\">Caching and Prefetching</a></li>\n<li><a href=\"#versioning\">Versioning</a></li>\n</ul>\n</li>\n<li><a href=\"#the-sky-is-the-limit-\">The sky is the limit!</a></li>\n</ul>\n<h1 id=\"how-it-works\">How it works</h1>\n<p>Taunus follows a simple but <strong>proven</strong> set of rules.</p>\n<ul>\n<li>Define a <code>function(model)</code> for each your views</li>\n<li>Put these views in both the server and the client</li>\n<li>Define routes for your application</li>\n<li>Put those routes in both the server and the client</li>\n<li>Ensure route matches work the same way on both ends</li>\n<li>Create server-side controllers that yield the model for your views</li>\n<li>Create client-side controllers if you need to add client-side functionality to a particular view</li>\n<li>For the first request, always render views on the server-side</li>\n<li>When rendering a view on the server-side, include the full layout as well!</li>\n<li>Once the client-side code kicks in, <strong>hijack link clicks</strong> and make AJAX requests instead</li>\n<li>When you get the JSON model back, render views on the client-side</li>\n<li>If the <code>history</code> API is unavailable, fall back to good old request-response. <strong>Don&#39;t confuse your humans with obscure hash routers!</strong></li>\n</ul>\n<p>I&#39;ll step you through these, but rather than looking at implementation details, I&#39;ll walk you through the steps you need to take in order to make this flow happen.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"installing-taunus\">Installing Taunus</h1>\n<p>First off, you&#39;ll need to choose a HTTP server framework for your application. At the moment Taunus supports only a couple of HTTP frameworks, but more may be added if they are popular enough.</p>\n<ul>\n<li><a href=\"http://expressjs.com\">Express</a>, through <a href=\"https://github.com/taunus/taunus-express\">taunus-express</a></li>\n<li><a href=\"http://hapijs.com\">Hapi</a>, through <a href=\"https://github.com/taunus/taunus-hapi\">taunus-hapi</a> and the <a href=\"https://github.com/taunus/hapiify\">hapiify</a> transform</li>\n</ul>\n<blockquote>\n<p>If you&#39;re more of a <em>&quot;rummage through someone else&#39;s code&quot;</em> type of developer, you may feel comfortable <a href=\"https://github.com/taunus/taunus.bevacqua.io\">going through this website&#39;s source code</a>, which uses the <a href=\"http://hapijs.com\">Hapi</a> flavor of Taunus. Alternatively you can look at the source code for <a href=\"https://github.com/ponyfoo/ponyfoo\">ponyfoo.com</a>, which is <strong>a more advanced use-case</strong> under the <a href=\"http://expressjs.com\">Express</a> flavor. Or, you could just keep on reading this page, that&#39;s okay too.</p>\n<p>There&#39;s also <a href=\"https://github.com/taunus/generator-taunus\">a Yeoman generator named <code>generator-taunus</code></a> you could use to get started, instead.</p>\n</blockquote>\n<p>Once you&#39;ve settled for either <a href=\"http://expressjs.com\">Express</a> or <a href=\"http://hapijs.com\">Hapi</a> you&#39;ll be able to proceed. For the purposes of this guide, we&#39;ll use <a href=\"http://expressjs.com\">Express</a>. Switching between one of the different HTTP flavors is strikingly easy, though.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"setting-up-the-server-side\">Setting up the server-side</h4>\n<p>Naturally, you&#39;ll need to install all of the following modules from <code>npm</code> to get started.</p>\n<pre><code class=\"lang-shell\">mkdir getting-started\ncd getting-started\nnpm init\nnpm install --save taunus taunus-express express\n</code></pre>\n<p><img src=\"http://i.imgur.com/4P8vNe9.png\" alt=\"Screenshot with `npm init` output\"></p>\n<p>Let&#39;s build our application step-by-step, and I&#39;ll walk you through them as we go along. First of all, you&#39;ll need the famous <code>app.js</code> file.</p>\n<pre><code class=\"lang-shell\">touch app.js\n</code></pre>\n<p>It&#39;s probably a good idea to put something in your <code>app.js</code> file, let&#39;s do that now.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {};\n\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>All <code>taunus-express</code> really does is add a bunch of routes to your Express <code>app</code>. You should note that any middleware and API routes should probably come before the <code>taunusExpress</code> invocation. You&#39;ll probably be using a catch-all view route that renders a <em>&quot;Not Found&quot;</em> view, blocking any routing beyond that route.</p>\n<p>If you were to run the application now you would get a friendly remined from Taunus letting you know that you forgot to declare any view routes. Silly you!</p>\n<pre><code class=\"lang-shell\">node app\n</code></pre>\n<p><img src=\"http://i.imgur.com/n8mH4mN.png\" alt=\"Screenshot with `node app` output\"></p>\n<p>The <code>options</code> object passed to <code>taunusExpress</code> let&#39;s you configure Taunus. Instead of discussing every single configuration option you could set here, let&#39;s discuss what matters: the <em>required configuration</em>. There&#39;s two options that you must set if you want your Taunus application to make any sense.</p>\n<ul>\n<li><code>routes</code> should be an array of view routes</li>\n<li><code>layout</code> should be a function that takes a single <code>model</code> argument and returns an entire HTML document</li>\n</ul>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"your-first-route\">Your first route</h4>\n<p>Routes need to be placed in its own dedicated module, so that you can reuse it later on <strong>when setting up client-side routing</strong>. Let&#39;s create that module and add a route to it.</p>\n<pre><code class=\"lang-shell\">touch routes.js\n</code></pre>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nmodule.exports = [\n  { route: &#39;/&#39;, action: &#39;home/index&#39; }\n];\n</code></pre>\n<p>Each item in the exported array is a route. In this case, we only have the <code>/</code> route with the <code>home/index</code> action. Taunus follows the well known <a href=\"http://en.wikipedia.org/wiki/Convention_over_configuration\">convention over configuration pattern</a>, which made <a href=\"http://en.wikipedia.org/wiki/Ruby_on_Rails\">Ruby on Rails</a> famous. <em>Maybe one day Taunus will be famous too!</em> By convention, Taunus will assume that the <code>home/index</code> action uses the <code>home/index</code> controller and renders the <code>home/index</code> view. Of course, <em>all of that can be changed using configuration</em>.</p>\n<p>Time to go back to <code>app.js</code> and update the <code>options</code> object.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {\n  routes: require(&#39;./routes&#39;)\n};\n\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>It&#39;s important to know that if you omit the creation of a controller then Taunus will skip that step, and render the view passing it whatever the default model is <em>(more on that <a href=\"/api\">in the API documentation</a>, but it defaults to <code>{}</code>)</em>.</p>\n<p>Here&#39;s what you&#39;d get if you attempted to run the application at this point.</p>\n<pre><code class=\"lang-shell\">node app &amp;\ncurl localhost:3000\n</code></pre>\n<p><img src=\"http://i.imgur.com/08lnCec.png\" alt=\"Screenshot with `node app` results\"></p>\n<p>Turns out you&#39;re missing a lot of things! Taunus is quite lenient and it&#39;ll try its best to let you know what you might be missing, though. Apparently you don&#39;t have a layout, a server-side controller, or even a view! <em>That&#39;s rough.</em></p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"creating-a-layout\">Creating a layout</h4>\n<p>Let&#39;s also create a layout. For the purposes of making our way through this guide, it&#39;ll just be a plain JavaScript function.</p>\n<pre><code class=\"lang-shell\">touch layout.js\n</code></pre>\n<p>Note that the <code>partial</code> property in the <code>model</code> <em>(as seen below)</em> is created on the fly after rendering partial views. The layout function we&#39;ll be using here effectively means <em>&quot;use the following combination of plain text and the <strong>(maybe HTML)</strong> partial view&quot;</em>.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nmodule.exports = function (model) {\n  return &#39;This is the partial: &quot;&#39; + model.partial + &#39;&quot;&#39;;\n};\n</code></pre>\n<p>Of course, if you were developing a real application, then you probably wouldn&#39;t want to write views as JavaScript functions as that&#39;s unproductive, confusing, and hard to maintain. What you could do instead, is use a view-rendering engine that allows you to compile your view templates into JavaScript functions.</p>\n<ul>\n<li><a href=\"https://github.com/janl/mustache.js\">Mustache</a> is a templating engine that can compile your views into plain functions, using a syntax that&#39;s minimally different from HTML</li>\n<li><a href=\"https://github.com/jadejs/jade\">Jade</a> is another option, and it has a terse syntax where spacing matters but there&#39;s no closing tags</li>\n<li>There&#39;s many more alternatives like <a href=\"http://mozilla.github.io/nunjucks/\">Mozilla&#39;s Nunjucks</a>, <a href=\"http://handlebarsjs.com/\">Handlebars</a>, and <a href=\"http://www.embeddedjs.com/\">EJS</a>.</li>\n</ul>\n<p>Remember to add the <code>layout</code> under the <code>options</code> object passed to <code>taunusExpress</code>!</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {\n  routes: require(&#39;./routes&#39;),\n  layout: require(&#39;./layout&#39;)\n};\n\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>Here&#39;s what you&#39;d get if you ran the application at this point.</p>\n<pre><code class=\"lang-shell\">node app &amp;\ncurl localhost:3000\n</code></pre>\n<p><img src=\"http://i.imgur.com/wUbnCyk.png\" alt=\"Screenshot with `node app` output\"></p>\n<p>At this point we have a layout, but we&#39;re still missing the partial view and the server-side controller. We can do without the controller, but having no views is kind of pointless when you&#39;re trying to get an MVC engine up and running, right?</p>\n<p>You&#39;ll find tools related to view templating in the <a href=\"/complements\">complementary modules section</a>. If you don&#39;t provide a <code>layout</code> property at all, Taunus will render your model in a response by wrapping it in <code>&lt;pre&gt;</code> and <code>&lt;code&gt;</code> tags, which may aid you when getting started.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-jade-as-your-view-engine\">Using Jade as your view engine</h4>\n<p>Let&#39;s go ahead and use Jade as the view-rendering engine of choice for our views.</p>\n<pre><code class=\"lang-shell\">mkdir -p views/home\ntouch views/home/index.jade\n</code></pre>\n<p>Since we&#39;re just getting started, the view will just have some basic static content, and that&#39;s it.</p>\n<pre><code class=\"lang-jade\">p Hello Taunus!\n</code></pre>\n<p>Next you&#39;ll want to compile the view into a function. To do that you can use <a href=\"https://github.com/bevacqua/jadum\">jadum</a>, a specialized Jade compiler that plays well with Taunus by being aware of <code>require</code> statements, and thus saving bytes when it comes to client-side rendering. Let&#39;s install it globally, for the sake of this exercise <em>(you should install it locally when you&#39;re developing a real application)</em>.</p>\n<pre><code class=\"lang-shell\">npm install --global jadum\n</code></pre>\n<p>To compile every view in the <code>views</code> directory into functions that work well with Taunus, you can use the command below. The <code>--output</code> flag indicates where you want the views to be placed. We chose to use <code>.bin</code> because that&#39;s where Taunus expects your compiled views to be by default. But since Taunus follows the <a href=\"http://ponyfoo.com/stop-breaking-the-web\">convention over configuration</a> approach, you could change that if you wanted to.</p>\n<pre><code class=\"lang-shell\">jadum views/** --output .bin\n</code></pre>\n<p>Congratulations! Your first view is now operational and built using a full-fledged templating engine! All that&#39;s left is for you to run the application and visit it on port <code>3000</code>.</p>\n<pre><code class=\"lang-shell\">node app &amp;\nopen http://localhost:3000\n</code></pre>\n<p><img src=\"http://i.imgur.com/zjaJYCq.png\" alt=\"Screenshot with `node app` output\"></p>\n<p>Granted, you should <em>probably</em> move the layout into a Jade <em>(any view engine will do)</em> template as well.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"throwing-in-a-controller\">Throwing in a controller</h4>\n<p>Controllers are indeed optional, but an application that renders every view using the same model won&#39;t get you very far. Controllers allow you to handle the request and put together the model to be used when sending a response. Contrary to what most frameworks propose, Taunus expects every action to have its own individual controller. Since Node.js makes it easy to import components, this setup helps you keep your code modular while still being able to reuse logic by sharing modules across different controllers. Let&#39;s create a controller for the <code>home/view</code> action.</p>\n<pre><code class=\"lang-shell\">mkdir -p controllers/home\ntouch controllers/home/index.js\n</code></pre>\n<p>The controller module should merely export a function. <em>Started noticing the pattern?</em> The signature for the controller is the same signature as that of any other middleware passed to <a href=\"http://expressjs.com\">Express</a> <em>(or any route handler passed to <a href=\"http://hapijs.com\">Hapi</a> in the case of <code>taunus-hapi</code>)</em>.</p>\n<p>As you may have noticed in the examples so far, you haven&#39;t even set a document title for your HTML pages! Turns out, there&#39;s a few model properties <em>(very few)</em> that Taunus is aware of. One of those is the <code>title</code> property, and it&#39;ll be used to change the <code>document.title</code> in your pages when navigating through the client-side. Keep in mind that anything that&#39;s not in the <code>model</code> property won&#39;t be trasmitted to the client, and will just be accessible to the layout.</p>\n<p>Here is our newfangled <code>home/index</code> controller. As you&#39;ll notice, it doesn&#39;t disrupt any of the typical Express experience, but merely builds upon it. When <code>next</code> is called, the Taunus view-rendering handler will kick in, and render the view using the information that was assigned to <code>res.viewModel</code>.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nmodule.exports = function (req, res, next) {\n  res.viewModel = {\n    model: {\n      title: &#39;Welcome Home, Taunus!&#39;\n    }\n  };\n  next();\n};\n</code></pre>\n<p>Of course, relying on the client-side changes to your page in order to set the view title <em>wouldn&#39;t be progressive</em>, and thus <a href=\"http://ponyfoo.com/stop-breaking-the-web\">it would be really, <em>really</em> bad</a>. We should update the layout to use whatever <code>title</code> has been passed to the model. In fact, let&#39;s go back to the drawing board and make the layout into a Jade template!</p>\n<pre><code class=\"lang-shell\">rm layout.js\ntouch views/layout.jade\njadum views/** --output .bin\n</code></pre>\n<p>You should also remember to update the <code>app.js</code> module once again!</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {\n  routes: require(&#39;./routes&#39;),\n  layout: require(&#39;./.bin/views/layout&#39;)\n};\n\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>The <code>!=</code> syntax below means that whatever is in the value assigned to the element won&#39;t be escaped. That&#39;s okay because <code>partial</code> is a view where Jade escaped anything that needed escaping, but we wouldn&#39;t want HTML tags to be escaped!</p>\n<pre><code class=\"lang-jade\">title=model.title\nmain!=partial\n</code></pre>\n<p>By the way, did you know that <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code> are all optional in HTML 5, and that you can safely omit them in your HTML? Of course, rendering engines will still insert those elements automatically into the DOM for you! <em>How cool is that?</em></p>\n<pre><code class=\"lang-shell\">node app\n</code></pre>\n<p><img src=\"http://i.imgur.com/NvEWx9z.png\" alt=\"Screenshot with `node app` output\"></p>\n<p>You can now visit <code>localhost:3000</code> with your favorite web browser and you&#39;ll notice that the view renders as you&#39;d expect. The title will be properly set, and a <code>&lt;main&gt;</code> element will have the contents of your view.</p>\n<p><img src=\"http://i.imgur.com/LgZRFn5.png\" alt=\"Screenshot with application running on Google Chrome\"></p>\n<p>That&#39;s it, now your view has a title. Of course, there&#39;s nothing stopping you from adding database calls to fetch bits and pieces of the model before invoking <code>next</code> to render the view.</p>\n<p>Then there&#39;s also the client-side aspect of setting up Taunus. Let&#39;s set it up and see how it opens up our possibilities.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"taunus-in-the-client\">Taunus in the client</h1>\n<p>You already know how to set up the basics for server-side rendering, and you know that you should <a href=\"/api\">check out the API documentation</a> to get a more thorough understanding of the public interface on Taunus, and what it enables you to do.</p>\n<p>The way Taunus works on the client-side is so that once you set it up, it will hijack link clicks and use AJAX to fetch models and render those views in the client. If the JavaScript code fails to load, <em>or if it hasn&#39;t loaded yet due to a slow connection such as those in unstable mobile networks</em>, the regular link would be followed instead and no harm would be unleashed upon the human, except they would get a slightly less fancy experience.</p>\n<p>Setting up the client-side involves a few different steps. Firstly, we&#39;ll have to compile the application&#39;s wiring <em>(the routes and JavaScript view functions)</em> into something the browser understands. Then, you&#39;ll have to mount Taunus on the client-side, passing the wiring so that it knows which routes it should respond to, and which others it should merely ignore. Once that&#39;s out of the way, client-side routing would be set up.</p>\n<p>As sugar coating on top of that, you may add client-side functionality using controllers. These controllers would be executed even if the view was rendered on the server-side. They can access the Taunus API directly, in case you need to navigate to another view in some way other than by having humans click on anchor tags. The API, as you&#39;ll learn, will also let you render partial views using the powerful Taunus engine, listen for events that may occur at key stages of the view-rendering process, and even intercept AJAX requests blocking them before they ever happen.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-the-taunus-cli\">Using the Taunus CLI</h4>\n<p>Taunus comes with a CLI that can be used to wire your Node.js routes and views into the client-side. The same CLI can be used to wire up the client-side controllers as well. The main reason why the Taunus CLI exists is so that you don&#39;t have to <code>require</code> every single view and controller, undoing a lot of the work that was put into code reuse. Just like we did with <code>jadum</code> earlier, we&#39;ll install the <code>taunus</code> CLI globally for the sake of exercising, but we understand that relying on globally installed modules is insufficient for production-grade applications.</p>\n<pre><code class=\"lang-shell\">npm install --global taunus\n</code></pre>\n<p>Before you can use the CLI, you should move the route definitions to <code>controllers/routes.js</code>. That&#39;s where Taunus expects them to be. If you want to place them something else, <a href=\"/api\">the API documentation can help you</a>.</p>\n<pre><code class=\"lang-shell\">mv routes.js controllers/routes.js\n</code></pre>\n<p>Since you moved the routes you should also update the <code>require</code> statement in the <code>app.js</code> module.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar app = express();\nvar options = {\n  routes: require(&#39;./controllers/routes&#39;),\n  layout: require(&#39;./.bin/views/layout&#39;)\n};\n\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>The CLI is terse in both its inputs and its outputs. If you run it without any arguments it&#39;ll print out the wiring module, and if you want to persist it you should provide the <code>--output</code> flag. In typical <a href=\"http://en.wikipedia.org/wiki/Convention_over_configuration\">convention-over-configuration</a> fashion, the CLI will default to inferring your views are located in <code>.bin/views</code> and that you want the wiring module to be placed in <code>.bin/wiring.js</code>, but you&#39;ll be able to change that if it doesn&#39;t meet your needs.</p>\n<pre><code class=\"lang-shell\">taunus --output\n</code></pre>\n<p>At this point in our example, the CLI should create a <code>.bin/wiring.js</code> file with the contents detailed below. As you can see, even if <code>taunus</code> is an automated code-generation tool, it&#39;s output is as human readable as any other module.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar templates = {\n  &#39;home/index&#39;: require(&#39;./views/home/index.js&#39;),\n  &#39;layout&#39;: require(&#39;./views/layout.js&#39;)\n};\n\nvar controllers = {\n};\n\nvar routes = [\n  {\n    route: &#39;/&#39;,\n    action: &#39;home/index&#39;\n  }\n];\n\nmodule.exports = {\n  templates: templates,\n  controllers: controllers,\n  routes: routes\n};\n</code></pre>\n<p><img src=\"http://i.imgur.com/fIEe5Tm.png\" alt=\"Screenshot with `taunus` output\"></p>\n<p>Note that the <code>controllers</code> object is empty because you haven&#39;t created any <em>client-side controllers</em> yet. We created server-side controllers but those don&#39;t have any effect in the client-side, besides determining what gets sent to the client.</p>\n<blockquote>\n<p><strong>The CLI can be entirely ignored</strong>. You could write these definitions by yourself, but you would have to remember to update the wiring module whenever you add, change, or remove a view, a client-side controller, or a route. Doing that would be cumbersome, and the CLI solves that problem for us at the expense of one additional build step.</p>\n</blockquote>\n<p>During development, you can also add the <code>--watch</code> flag, which will rebuild the wiring module if a relevant file changes.</p>\n<pre><code class=\"lang-shell\">taunus --output --watch\n</code></pre>\n<p>If you&#39;re using Hapi instead of Express, you&#39;ll also need to pass in the <code>hapiify</code> transform so that routes get converted into something the client-side routing module understand.</p>\n<pre><code class=\"lang-shell\">taunus --output --transform hapiify\n</code></pre>\n<p>Now that you understand how to use the CLI or build the wiring module on your own, booting up Taunus on the client-side will be an easy thing to do!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"booting-up-the-client-side-router\">Booting up the client-side router</h4>\n<p>Once we have the wiring module, booting up the client-side engine is pretty easy. Taunus suggests you use <code>client/js</code> to keep all of your client-side JavaScript logic, but that is up to you too. For the sake of this guide, let&#39;s stick to the conventions.</p>\n<pre><code class=\"lang-shell\">mkdir -p client/js\ntouch client/js/main.js\n</code></pre>\n<p>The <code>main</code> module will be used as the <em>entry point</em> of your application on the client-side. Here you&#39;ll need to import <code>taunus</code>, the wiring module we&#39;ve just built, and a reference to the DOM element where you are rendering your partial views. Once you have all that, you can invoke <code>taunus.mount</code>.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar wiring = require(&#39;../../.bin/wiring&#39;);\nvar main = document.getElementsByTagName(&#39;main&#39;)[0];\n\ntaunus.mount(main, wiring);\n</code></pre>\n<p>The mountpoint will set up the client-side Taunus router and fire the client-side view controller for the view that has been rendered in the server-side. Whenever an anchor link is clicked, Taunus will be able to hijack that click and request the model using AJAX, but only if it matches a view route. Otherwise the link will behave just like any normal link would.</p>\n<p>By default, the mountpoint will issue an AJAX request for the view model of the server-side rendered view. This is akin to what dedicated client-side rendering frameworks such as AngularJS do, where views are only rendered after all the JavaScript has been downloaded, parsed, and executed. Except Taunus provides human-readable content faster, before the JavaScript even begins downloading, although it won&#39;t be functional until the client-side controller runs.</p>\n<p>An alternative is to inline the view model alongside the views in a <code>&lt;script type=&#39;text/taunus&#39;&gt;</code> tag, but this tends to slow down the initial response (models are <em>typically larger</em> than the resulting views).</p>\n<p>A third strategy is that you request the model asynchronously outside of Taunus, allowing you to fetch both the view model and Taunus itself concurrently, but that&#39;s harder to set up.</p>\n<p>The three booting strategies are explained in <a href=\"/api\">the API documentation</a> and further discussed in <a href=\"/performance\">the optimization guide</a>. For now, the default strategy <em>(<code>&#39;auto&#39;</code>)</em> should suffice. It fetches the view model using an AJAX request right after Taunus loads.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"adding-functionality-in-a-client-side-controller\">Adding functionality in a client-side controller</h4>\n<p>Client-side controllers run whenever a view is rendered, even if it&#39;s a partial. The controller is passed the <code>model</code>, containing the model that was used to render the view; the <code>route</code>, broken down into its components; and the <code>container</code>, which is whatever DOM element the view was rendered into.</p>\n<p>These controllers are entirely optional, which makes sense since we&#39;re progressively enhancing the application: it might not even be necessary! Let&#39;s add some client-side functionality to the example we&#39;ve been building.</p>\n<pre><code class=\"lang-shell\">mkdir -p client/js/controllers/home\ntouch client/js/controllers/home/index.js\n</code></pre>\n<p>Guess what? The controller should be a module which exports a function. That function will be called whenever the view is rendered. For the sake of simplicity we&#39;ll just print the action and the model to the console. If there&#39;s one place where you&#39;d want to enhance the experience, client-side controllers are where you want to put your code.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nmodule.exports = function (model, container, route) {\n  console.log(&#39;Rendered view %s using model:\\n%s&#39;, route.action, JSON.stringify(model, null, 2));\n};\n</code></pre>\n<p>Since we weren&#39;t using the <code>--watch</code> flag from the Taunus CLI, you&#39;ll have to recompile the wiring at this point, so that the controller gets added to that manifest.</p>\n<pre><code class=\"lang-shell\">taunus --output\n</code></pre>\n<p>Of course, you&#39;ll now have to wire up the client-side JavaScript using <a href=\"http://browserify.org/\">Browserify</a>!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"compiling-your-client-side-javascript\">Compiling your client-side JavaScript</h4>\n<p>You&#39;ll need to compile the <code>client/js/main.js</code> module, our client-side application&#39;s entry point, using Browserify since the code is written using CommonJS. In this example you&#39;ll install <code>browserify</code> globally to compile the code, but naturally you&#39;ll install it locally when working on a real-world application.</p>\n<pre><code class=\"lang-shell\">npm install --global browserify\n</code></pre>\n<p>Once you have the Browserify CLI, you&#39;ll be able to compile the code right from your command line. The <code>-d</code> flag tells Browserify to add an inline source map into the compiled bundle, making debugging easier for us. The <code>-o</code> flag redirects output to the indicated file, whereas the output is printed to standard output by default.</p>\n<pre><code class=\"lang-shell\">mkdir -p .bin/public/js\nbrowserify client/js/main.js -do .bin/public/js/all.js\n</code></pre>\n<p>We haven&#39;t done much of anything with the Express application, so you&#39;ll need to adjust the <code>app.js</code> module to serve static assets. If you&#39;re used to Express, you&#39;ll notice there&#39;s nothing special about how we&#39;re using <code>serve-static</code>.</p>\n<pre><code class=\"lang-shell\">npm install --save serve-static\n</code></pre>\n<p>Let&#39;s configure the application to serve static assets from <code>.bin/public</code>.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\nvar taunus = require(&#39;taunus&#39;);\nvar taunusExpress = require(&#39;taunus-express&#39;);\nvar express = require(&#39;express&#39;);\nvar serveStatic = require(&#39;serve-static&#39;);\nvar app = express();\nvar options = {\n  routes: require(&#39;./controllers/routes&#39;),\n  layout: require(&#39;./.bin/views/layout&#39;)\n};\n\napp.use(serveStatic(&#39;.bin/public&#39;));\ntaunusExpress(taunus, app, options);\napp.listen(3000);\n</code></pre>\n<p>Next up, you&#39;ll have to edit the layout to include the compiled JavaScript bundle file.</p>\n<pre><code class=\"lang-jade\">title=model.title\nmain!=partial\nscript(src=&#39;/js/all.js&#39;)\n</code></pre>\n<p>Don&#39;t forget to compile <code>layout.jade</code> again.</p>\n<pre><code class=\"lang-shell\">jadum views/** --output .bin\n</code></pre>\n<p>Lastly, you can execute the application and see it in action!</p>\n<pre><code class=\"lang-shell\">node app\n</code></pre>\n<p><img src=\"http://i.imgur.com/68O84wX.png\" alt=\"Screenshot with `node app` output\"></p>\n<p>If you open the application on a web browser, you&#39;ll notice that the appropriate information will be logged into the developer <code>console</code>.</p>\n<p><img src=\"http://i.imgur.com/ZUF6NFl.png\" alt=\"Screenshot with the application running under Google Chrome\"></p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"using-the-client-side-taunus-api\">Using the client-side Taunus API</h4>\n<p>Taunus does provide <a href=\"/api\">a thin API</a> in the client-side. Usage of that API belongs mostly inside the body of client-side view controllers, but there&#39;s a few methods you can take advantage of on a global scale as well.</p>\n<p>Taunus can notify you whenever important events occur.</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Arguments</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#39;start&#39;</code></td>\n<td><code>container, model, route</code></td>\n<td>Emitted when <code>taunus.mount</code> finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling <code>taunus.mount</code>.</td>\n</tr>\n<tr>\n<td><code>&#39;render&#39;</code></td>\n<td><code>container, model, route</code></td>\n<td>A view has just been rendered and its client-side controller is about to be invoked</td>\n</tr>\n<tr>\n<td><code>&#39;change&#39;</code></td>\n<td><code>route, model</code></td>\n<td>Same as <code>&#39;render&#39;</code>, but only if <code>container</code> is the mountpoint and the route has changed.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.start&#39;</code></td>\n<td><code>route, context</code></td>\n<td>Emitted whenever an XHR request starts.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.done&#39;</code></td>\n<td><code>route, context, data</code></td>\n<td>Emitted whenever an XHR request ends successfully.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.abort&#39;</code></td>\n<td><code>route, context</code></td>\n<td>Emitted whenever an XHR request is purposely aborted.</td>\n</tr>\n<tr>\n<td><code>&#39;fetch.error&#39;</code></td>\n<td><code>route, context, err</code></td>\n<td>Emitted whenever an XHR request results in an HTTP error.</td>\n</tr>\n</tbody>\n</table>\n<p>Besides events, there&#39;s a couple more methods you can use. The <code>taunus.navigate</code> method allows you to navigate to a URL without the need for a human to click on an anchor link. Then there&#39;s <code>taunus.partial</code>, and that allows you to render any partial view on a DOM element of your choosing, and it&#39;ll then invoke its controller. You&#39;ll need to come up with the model yourself, though.</p>\n<p>Astonishingly, the API is further documented in <a href=\"/api\">the API documentation</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"caching-and-prefetching\">Caching and Prefetching</h4>\n<p><a href=\"/performance\">Performance</a> plays an important role in Taunus. That&#39;s why the you can perform caching and prefetching on the client-side just by turning on a pair of flags. But what do these flags do exactly?</p>\n<p>When turned on, by passing <code>{ cache: true }</code> as the third parameter for <code>taunus.mount</code>, the caching layer will make sure that responses are kept around for <code>15</code> seconds. Whenever a route needs a model in order to render a view, it&#39;ll first ask the caching layer for a fresh copy. If the caching layer doesn&#39;t have a copy, or if that copy is stale <em>(in this case, older than <code>15</code> seconds)</em>, then an AJAX request will be issued to the server. Of course, the duration is configurable. If you want to use a value other than the default, you should set <code>cache</code> to a number in seconds instead of just <code>true</code>.</p>\n<p>Since Taunus understands that not every view operates under the same constraints, you&#39;re also able to set a <code>cache</code> freshness duration directly in your routes. The <code>cache</code> property in routes has precedence over the default value.</p>\n<p>There&#39;s currently two caching stores: a raw in-memory store, and an <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\">IndexedDB</a> store. IndexedDB is an embedded database solution, and you can think of it like an asynchronous version of <code>localStorage</code>. It has <a href=\"http://caniuse.com/#feat=indexeddb\">surprisingly broad browser support</a>, and in the cases where it&#39;s not supported then caching is done solely in-memory.</p>\n<p>The prefetching mechanism is an interesting spin-off of caching, and it requires caching to be enabled in order to work. Whenever humans hover over a link, or whenever they put their finger on one of them <em>(the <code>touchstart</code> event)</em>, the prefetcher will issue an AJAX request for the view model for that link.</p>\n<p>If the request ends successfully then the response will be cached in the same way any other view would be cached. If the human hovers over another link while the previous one is still being prefetched, then the old request is aborted, as not to drain their <em>(possibly limited)</em> Internet connection bandwidth.</p>\n<p>If the human clicks on the link before prefetching is completed, he&#39;ll navigate to the view as soon as prefetching ends, rather than firing another request. This helps Taunus save precious milliseconds when dealing with latency-sensitive operations.</p>\n<p>Turning prefetching on is simply a matter of setting <code>prefetch</code> to <code>true</code> in the options passed to <code>taunus.mount</code>. For additional insights into the performance improvements Taunus can offer, head over to the <a href=\"/performance\">Performance Optimizations</a> guide.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4 id=\"versioning\">Versioning</h4>\n<p>When you alter your views, change controllers, or modify the models, chances are the client-side is going to come across one of the following issues.</p>\n<ul>\n<li>Outdated view template functions in the client-side, causing new models to break</li>\n<li>Outdated client-side controllers, causing new models to break or miss out on functionality</li>\n<li>Outdated models in the cache, causing new views or controllers to break</li>\n</ul>\n<p>Versioning handles these issues gracefully on your behalf. The way it works is that whenever you get a response from Taunus, a <em>version string (configured on the server-side)</em> is included with it. If that version string doesn&#39;t match the one stored in the client, then the cache will be flushed and the human will be redirected, forcing a full page reload.</p>\n<blockquote>\n<p>The versioning API is unable to handle changes to routes, and it&#39;s up to you to make sure that the application stays backwards compatible when it comes to routing.</p>\n<p>Versioning can&#39;t intervene when the client-side is heavily relying on cached views and models, and the human is refusing to reload their browser. The server isn&#39;t being accessed and thus it can&#39;t communicate that everything on the cache may have become stale. The good news is that the human won&#39;t notice any oddities, as the site will continue to work as he knows it. When he finally attempts to visit something that isn&#39;t cached, a request is made, and the versioning engine resolves version discrepancies for them.</p>\n</blockquote>\n<p>Making use of versioning involves setting the <code>version</code> field in the options, when invoking <code>taunus.mount</code> <strong>on both the server-side and the client-side, using the same value</strong>. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.</p>\n<p>You may use your build identifier or the <code>version</code> field in <code>package.json</code>, but understand that it may cause the client-side to flush the cache too often <em>(maybe even on every deployment)</em>.</p>\n<p>The default version string is set to <code>1</code>. The Taunus version will be prepended to yours, resulting in a value such as <code>t3.0.0;v1</code> where Taunus is running version <code>3.0.0</code> and your application is running version <code>1</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"the-sky-is-the-limit-\">The sky is the limit!</h1>\n<p>You&#39;re now familiar with how Taunus works on a high-level. You have covered a decent amount of ground, but you shouldn&#39;t stop there.</p>\n<ul>\n<li>Learn more about <a href=\"/api\">the API Taunus has</a> to offer</li>\n<li>Go through the <a href=\"/performance\">performance optimization tips</a>. You may learn something new!</li>\n<li><em>Familiarize yourself with the ways of progressive enhancement</em><ul>\n<li>Jeremy Keith enunciates <a href=\"https://adactio.com/journal/7706\">&quot;Be progressive&quot;</a></li>\n<li>Christian Heilmann advocates for <a href=\"http://icant.co.uk/articles/pragmatic-progressive-enhancement/\">&quot;Pragmatic progressive enhancement&quot;</a></li>\n<li>Jake Archibald explains how <a href=\"http://jakearchibald.com/2013/progressive-enhancement-is-faster/\">&quot;Progressive enhancement is faster&quot;</a></li>\n<li>I blogged about how we should <a href=\"http://ponyfoo.com/stop-breaking-the-web\">&quot;Stop Breaking the Web&quot;</a></li>\n<li>Guillermo Rauch argues for <a href=\"http://rauchg.com/2014/7-principles-of-rich-web-applications/\">&quot;7 Principles of Rich Web Applications&quot;</a></li>\n<li>Aaron Gustafson writes <a href=\"http://alistapart.com/article/understandingprogressiveenhancement\">&quot;Understanding Progressive Enhancement&quot;</a></li>\n<li>Orde Saunders gives his point of view in <a href=\"https://decadecity.net/blog/2013/09/16/progressive-enhancement-for-fault-tolerance\">&quot;Progressive enhancement for fault tolerance&quot;</a></li>\n</ul>\n</li>\n<li>Sift through the <a href=\"/complements\">complementary modules</a>. You may find something you hadn&#39;t thought of!</li>\n</ul>\n<p>Also, get involved!</p>\n<ul>\n<li>Fork this repository and <a href=\"https://github.com/taunus/taunus.bevacqua.io/pulls\">send some pull requests</a> to improve these guides!</li>\n<li>See something, say something! If you detect a bug, <a href=\"https://github.com/taunus/taunus/issues/new\">please create an issue</a>!</li>\n</ul>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<blockquote>\n<p>You&#39;ll find a <a href=\"https://github.com/taunus/getting-started\">full fledged version of the Getting Started</a> tutorial application on GitHub.</p>\n</blockquote>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # Getting Started\n\n    Taunus is a shared-rendering MVC engine for Node.js, and it's _up to you how to use it_. In fact, it might be a good idea for you to **set up just the server-side aspect first**, as that'll teach you how it works even when JavaScript never gets to the client.\n\n    # Table of Contents\n\n    - [How it works](#how-it-works)\n    - [Installing Taunus](#installing-taunus)\n    - [Setting up the server-side](#setting-up-the-server-side)\n      - [Your first route](#your-first-route)\n      - [Creating a layout](#creating-a-layout)\n      - [Using Jade as your view engine](#using-jade-as-your-view-engine)\n      - [Throwing in a controller](#throwing-in-a-controller)\n    - [Taunus in the client](#taunus-in-the-client)\n      - [Using the Taunus CLI](#using-the-taunus-cli)\n      - [Booting up the client-side router](#booting-up-the-client-side-router)\n      - [Adding functionality in a client-side controller](#adding-functionality-in-a-client-side-controller)\n      - [Compiling your client-side JavaScript](#compiling-your-client-side-javascript)\n      - [Using the client-side Taunus API](#using-the-client-side-taunus-api)\n      - [Caching and Prefetching](#caching-and-prefetching)\n      - [Versioning](#versioning)\n    - [The sky is the limit!](#the-sky-is-the-limit-)\n\n    # How it works\n\n    Taunus follows a simple but **proven** set of rules.\n\n    - Define a `function(model)` for each your views\n    - Put these views in both the server and the client\n    - Define routes for your application\n    - Put those routes in both the server and the client\n    - Ensure route matches work the same way on both ends\n    - Create server-side controllers that yield the model for your views\n    - Create client-side controllers if you need to add client-side functionality to a particular view\n    - For the first request, always render views on the server-side\n    - When rendering a view on the server-side, include the full layout as well!\n    - Once the client-side code kicks in, **hijack link clicks** and make AJAX requests instead\n    - When you get the JSON model back, render views on the client-side\n    - If the `history` API is unavailable, fall back to good old request-response. **Don't confuse your humans with obscure hash routers!**\n\n    I'll step you through these, but rather than looking at implementation details, I'll walk you through the steps you need to take in order to make this flow happen.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Installing Taunus\n\n    First off, you'll need to choose a HTTP server framework for your application. At the moment Taunus supports only a couple of HTTP frameworks, but more may be added if they are popular enough.\n\n    - [Express][6], through [taunus-express][1]\n    - [Hapi][7], through [taunus-hapi][2] and the [hapiify][3] transform\n\n    > If you're more of a _\"rummage through someone else's code\"_ type of developer, you may feel comfortable [going through this website's source code][4], which uses the [Hapi][7] flavor of Taunus. Alternatively you can look at the source code for [ponyfoo.com][5], which is **a more advanced use-case** under the [Express][6] flavor. Or, you could just keep on reading this page, that's okay too.\n    >\n    > There's also [a Yeoman generator named `generator-taunus`][42] you could use to get started, instead.\n\n    Once you've settled for either [Express][6] or [Hapi][7] you'll be able to proceed. For the purposes of this guide, we'll use [Express][6]. Switching between one of the different HTTP flavors is strikingly easy, though.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Setting up the server-side\n\n    Naturally, you'll need to install all of the following modules from `npm` to get started.\n\n    ```shell\n    mkdir getting-started\n    cd getting-started\n    npm init\n    npm install --save taunus taunus-express express\n    ```\n\n    ![Screenshot with `npm init` output][30]\n\n    Let's build our application step-by-step, and I'll walk you through them as we go along. First of all, you'll need the famous `app.js` file.\n\n    ```shell\n    touch app.js\n    ```\n\n    It's probably a good idea to put something in your `app.js` file, let's do that now.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {};\n\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    All `taunus-express` really does is add a bunch of routes to your Express `app`. You should note that any middleware and API routes should probably come before the `taunusExpress` invocation. You'll probably be using a catch-all view route that renders a _\"Not Found\"_ view, blocking any routing beyond that route.\n\n    If you were to run the application now you would get a friendly remined from Taunus letting you know that you forgot to declare any view routes. Silly you!\n\n    ```shell\n    node app\n    ```\n\n    ![Screenshot with `node app` output][31]\n\n    The `options` object passed to `taunusExpress` let's you configure Taunus. Instead of discussing every single configuration option you could set here, let's discuss what matters: the _required configuration_. There's two options that you must set if you want your Taunus application to make any sense.\n\n    - `routes` should be an array of view routes\n    - `layout` should be a function that takes a single `model` argument and returns an entire HTML document\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Your first route\n\n    Routes need to be placed in its own dedicated module, so that you can reuse it later on **when setting up client-side routing**. Let's create that module and add a route to it.\n\n    ```shell\n    touch routes.js\n    ```\n\n    ```js\n    'use strict';\n\n    module.exports = [\n      { route: '/', action: 'home/index' }\n    ];\n    ```\n\n    Each item in the exported array is a route. In this case, we only have the `/` route with the `home/index` action. Taunus follows the well known [convention over configuration pattern][8], which made [Ruby on Rails][9] famous. _Maybe one day Taunus will be famous too!_ By convention, Taunus will assume that the `home/index` action uses the `home/index` controller and renders the `home/index` view. Of course, _all of that can be changed using configuration_.\n\n    Time to go back to `app.js` and update the `options` object.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      routes: require('./routes')\n    };\n\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    It's important to know that if you omit the creation of a controller then Taunus will skip that step, and render the view passing it whatever the default model is _(more on that [in the API documentation][18], but it defaults to `{}`)_.\n\n    Here's what you'd get if you attempted to run the application at this point.\n\n    ```shell\n    node app &\n    curl localhost:3000\n    ```\n\n    ![Screenshot with `node app` results][32]\n\n    Turns out you're missing a lot of things! Taunus is quite lenient and it'll try its best to let you know what you might be missing, though. Apparently you don't have a layout, a server-side controller, or even a view! _That's rough._\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Creating a layout\n\n    Let's also create a layout. For the purposes of making our way through this guide, it'll just be a plain JavaScript function.\n\n    ```shell\n    touch layout.js\n    ```\n\n    Note that the `partial` property in the `model` _(as seen below)_ is created on the fly after rendering partial views. The layout function we'll be using here effectively means _\"use the following combination of plain text and the **(maybe HTML)** partial view\"_.\n\n    ```js\n    'use strict';\n\n    module.exports = function (model) {\n      return 'This is the partial: \"' + model.partial + '\"';\n    };\n    ```\n\n    Of course, if you were developing a real application, then you probably wouldn't want to write views as JavaScript functions as that's unproductive, confusing, and hard to maintain. What you could do instead, is use a view-rendering engine that allows you to compile your view templates into JavaScript functions.\n\n    - [Mustache][10] is a templating engine that can compile your views into plain functions, using a syntax that's minimally different from HTML\n    - [Jade][11] is another option, and it has a terse syntax where spacing matters but there's no closing tags\n    - There's many more alternatives like [Mozilla's Nunjucks][12], [Handlebars][13], and [EJS][14].\n\n    Remember to add the `layout` under the `options` object passed to `taunusExpress`!\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      routes: require('./routes'),\n      layout: require('./layout')\n    };\n\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    Here's what you'd get if you ran the application at this point.\n\n    ```shell\n    node app &\n    curl localhost:3000\n    ```\n\n    ![Screenshot with `node app` output][33]\n\n    At this point we have a layout, but we're still missing the partial view and the server-side controller. We can do without the controller, but having no views is kind of pointless when you're trying to get an MVC engine up and running, right?\n\n    You'll find tools related to view templating in the [complementary modules section][15]. If you don't provide a `layout` property at all, Taunus will render your model in a response by wrapping it in `<pre>` and `<code>` tags, which may aid you when getting started.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using Jade as your view engine\n\n    Let's go ahead and use Jade as the view-rendering engine of choice for our views.\n\n    ```shell\n    mkdir -p views/home\n    touch views/home/index.jade\n    ```\n\n    Since we're just getting started, the view will just have some basic static content, and that's it.\n\n    ```jade\n    p Hello Taunus!\n    ```\n\n    Next you'll want to compile the view into a function. To do that you can use [jadum][16], a specialized Jade compiler that plays well with Taunus by being aware of `require` statements, and thus saving bytes when it comes to client-side rendering. Let's install it globally, for the sake of this exercise _(you should install it locally when you're developing a real application)_.\n\n    ```shell\n    npm install --global jadum\n    ```\n\n    To compile every view in the `views` directory into functions that work well with Taunus, you can use the command below. The `--output` flag indicates where you want the views to be placed. We chose to use `.bin` because that's where Taunus expects your compiled views to be by default. But since Taunus follows the [convention over configuration][17] approach, you could change that if you wanted to.\n\n    ```shell\n    jadum views/** --output .bin\n    ```\n\n    Congratulations! Your first view is now operational and built using a full-fledged templating engine! All that's left is for you to run the application and visit it on port `3000`.\n\n    ```shell\n    node app &\n    open http://localhost:3000\n    ```\n\n    ![Screenshot with `node app` output][34]\n\n    Granted, you should _probably_ move the layout into a Jade _(any view engine will do)_ template as well.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Throwing in a controller\n\n    Controllers are indeed optional, but an application that renders every view using the same model won't get you very far. Controllers allow you to handle the request and put together the model to be used when sending a response. Contrary to what most frameworks propose, Taunus expects every action to have its own individual controller. Since Node.js makes it easy to import components, this setup helps you keep your code modular while still being able to reuse logic by sharing modules across different controllers. Let's create a controller for the `home/view` action.\n\n    ```shell\n    mkdir -p controllers/home\n    touch controllers/home/index.js\n    ```\n\n    The controller module should merely export a function. _Started noticing the pattern?_ The signature for the controller is the same signature as that of any other middleware passed to [Express][6] _(or any route handler passed to [Hapi][7] in the case of `taunus-hapi`)_.\n\n    As you may have noticed in the examples so far, you haven't even set a document title for your HTML pages! Turns out, there's a few model properties _(very few)_ that Taunus is aware of. One of those is the `title` property, and it'll be used to change the `document.title` in your pages when navigating through the client-side. Keep in mind that anything that's not in the `model` property won't be trasmitted to the client, and will just be accessible to the layout.\n\n    Here is our newfangled `home/index` controller. As you'll notice, it doesn't disrupt any of the typical Express experience, but merely builds upon it. When `next` is called, the Taunus view-rendering handler will kick in, and render the view using the information that was assigned to `res.viewModel`.\n\n    ```js\n    'use strict';\n\n    module.exports = function (req, res, next) {\n      res.viewModel = {\n        model: {\n          title: 'Welcome Home, Taunus!'\n        }\n      };\n      next();\n    };\n    ```\n\n    Of course, relying on the client-side changes to your page in order to set the view title _wouldn't be progressive_, and thus [it would be really, _really_ bad][17]. We should update the layout to use whatever `title` has been passed to the model. In fact, let's go back to the drawing board and make the layout into a Jade template!\n\n    ```shell\n    rm layout.js\n    touch views/layout.jade\n    jadum views/** --output .bin\n    ```\n\n    You should also remember to update the `app.js` module once again!\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      routes: require('./routes'),\n      layout: require('./.bin/views/layout')\n    };\n\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    The `!=` syntax below means that whatever is in the value assigned to the element won't be escaped. That's okay because `partial` is a view where Jade escaped anything that needed escaping, but we wouldn't want HTML tags to be escaped!\n\n    ```jade\n    title=model.title\n    main!=partial\n    ```\n\n    By the way, did you know that `<html>`, `<head>`, and `<body>` are all optional in HTML 5, and that you can safely omit them in your HTML? Of course, rendering engines will still insert those elements automatically into the DOM for you! _How cool is that?_\n\n    ```shell\n    node app\n    ```\n\n    ![Screenshot with `node app` output][35]\n\n    You can now visit `localhost:3000` with your favorite web browser and you'll notice that the view renders as you'd expect. The title will be properly set, and a `<main>` element will have the contents of your view.\n\n    ![Screenshot with application running on Google Chrome][36]\n\n    That's it, now your view has a title. Of course, there's nothing stopping you from adding database calls to fetch bits and pieces of the model before invoking `next` to render the view.\n\n    Then there's also the client-side aspect of setting up Taunus. Let's set it up and see how it opens up our possibilities.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Taunus in the client\n\n    You already know how to set up the basics for server-side rendering, and you know that you should [check out the API documentation][18] to get a more thorough understanding of the public interface on Taunus, and what it enables you to do.\n\n    The way Taunus works on the client-side is so that once you set it up, it will hijack link clicks and use AJAX to fetch models and render those views in the client. If the JavaScript code fails to load, _or if it hasn't loaded yet due to a slow connection such as those in unstable mobile networks_, the regular link would be followed instead and no harm would be unleashed upon the human, except they would get a slightly less fancy experience.\n\n    Setting up the client-side involves a few different steps. Firstly, we'll have to compile the application's wiring _(the routes and JavaScript view functions)_ into something the browser understands. Then, you'll have to mount Taunus on the client-side, passing the wiring so that it knows which routes it should respond to, and which others it should merely ignore. Once that's out of the way, client-side routing would be set up.\n\n    As sugar coating on top of that, you may add client-side functionality using controllers. These controllers would be executed even if the view was rendered on the server-side. They can access the Taunus API directly, in case you need to navigate to another view in some way other than by having humans click on anchor tags. The API, as you'll learn, will also let you render partial views using the powerful Taunus engine, listen for events that may occur at key stages of the view-rendering process, and even intercept AJAX requests blocking them before they ever happen.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the Taunus CLI\n\n    Taunus comes with a CLI that can be used to wire your Node.js routes and views into the client-side. The same CLI can be used to wire up the client-side controllers as well. The main reason why the Taunus CLI exists is so that you don't have to `require` every single view and controller, undoing a lot of the work that was put into code reuse. Just like we did with `jadum` earlier, we'll install the `taunus` CLI globally for the sake of exercising, but we understand that relying on globally installed modules is insufficient for production-grade applications.\n\n    ```shell\n    npm install --global taunus\n    ```\n\n    Before you can use the CLI, you should move the route definitions to `controllers/routes.js`. That's where Taunus expects them to be. If you want to place them something else, [the API documentation can help you][18].\n\n    ```shell\n    mv routes.js controllers/routes.js\n    ```\n\n    Since you moved the routes you should also update the `require` statement in the `app.js` module.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      routes: require('./controllers/routes'),\n      layout: require('./.bin/views/layout')\n    };\n\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    The CLI is terse in both its inputs and its outputs. If you run it without any arguments it'll print out the wiring module, and if you want to persist it you should provide the `--output` flag. In typical [convention-over-configuration][8] fashion, the CLI will default to inferring your views are located in `.bin/views` and that you want the wiring module to be placed in `.bin/wiring.js`, but you'll be able to change that if it doesn't meet your needs.\n\n    ```shell\n    taunus --output\n    ```\n\n    At this point in our example, the CLI should create a `.bin/wiring.js` file with the contents detailed below. As you can see, even if `taunus` is an automated code-generation tool, it's output is as human readable as any other module.\n\n    ```js\n    'use strict';\n\n    var templates = {\n      'home/index': require('./views/home/index.js'),\n      'layout': require('./views/layout.js')\n    };\n\n    var controllers = {\n    };\n\n    var routes = [\n      {\n        route: '/',\n        action: 'home/index'\n      }\n    ];\n\n    module.exports = {\n      templates: templates,\n      controllers: controllers,\n      routes: routes\n    };\n    ```\n\n    ![Screenshot with `taunus` output][37]\n\n    Note that the `controllers` object is empty because you haven't created any _client-side controllers_ yet. We created server-side controllers but those don't have any effect in the client-side, besides determining what gets sent to the client.\n\n    > **The CLI can be entirely ignored**. You could write these definitions by yourself, but you would have to remember to update the wiring module whenever you add, change, or remove a view, a client-side controller, or a route. Doing that would be cumbersome, and the CLI solves that problem for us at the expense of one additional build step.\n\n    During development, you can also add the `--watch` flag, which will rebuild the wiring module if a relevant file changes.\n\n    ```shell\n    taunus --output --watch\n    ```\n\n    If you're using Hapi instead of Express, you'll also need to pass in the `hapiify` transform so that routes get converted into something the client-side routing module understand.\n\n    ```shell\n    taunus --output --transform hapiify\n    ```\n\n    Now that you understand how to use the CLI or build the wiring module on your own, booting up Taunus on the client-side will be an easy thing to do!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Booting up the client-side router\n\n    Once we have the wiring module, booting up the client-side engine is pretty easy. Taunus suggests you use `client/js` to keep all of your client-side JavaScript logic, but that is up to you too. For the sake of this guide, let's stick to the conventions.\n\n    ```shell\n    mkdir -p client/js\n    touch client/js/main.js\n    ```\n\n    The `main` module will be used as the _entry point_ of your application on the client-side. Here you'll need to import `taunus`, the wiring module we've just built, and a reference to the DOM element where you are rendering your partial views. Once you have all that, you can invoke `taunus.mount`.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var wiring = require('../../.bin/wiring');\n    var main = document.getElementsByTagName('main')[0];\n\n    taunus.mount(main, wiring);\n    ```\n\n    The mountpoint will set up the client-side Taunus router and fire the client-side view controller for the view that has been rendered in the server-side. Whenever an anchor link is clicked, Taunus will be able to hijack that click and request the model using AJAX, but only if it matches a view route. Otherwise the link will behave just like any normal link would.\n\n    By default, the mountpoint will issue an AJAX request for the view model of the server-side rendered view. This is akin to what dedicated client-side rendering frameworks such as AngularJS do, where views are only rendered after all the JavaScript has been downloaded, parsed, and executed. Except Taunus provides human-readable content faster, before the JavaScript even begins downloading, although it won't be functional until the client-side controller runs.\n\n    An alternative is to inline the view model alongside the views in a `<script type='text/taunus'>` tag, but this tends to slow down the initial response (models are _typically larger_ than the resulting views).\n\n    A third strategy is that you request the model asynchronously outside of Taunus, allowing you to fetch both the view model and Taunus itself concurrently, but that's harder to set up.\n\n    The three booting strategies are explained in [the API documentation][18] and further discussed in [the optimization guide][25]. For now, the default strategy _(`'auto'`)_ should suffice. It fetches the view model using an AJAX request right after Taunus loads.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Adding functionality in a client-side controller\n\n    Client-side controllers run whenever a view is rendered, even if it's a partial. The controller is passed the `model`, containing the model that was used to render the view; the `route`, broken down into its components; and the `container`, which is whatever DOM element the view was rendered into.\n\n    These controllers are entirely optional, which makes sense since we're progressively enhancing the application: it might not even be necessary! Let's add some client-side functionality to the example we've been building.\n\n    ```shell\n    mkdir -p client/js/controllers/home\n    touch client/js/controllers/home/index.js\n    ```\n\n    Guess what? The controller should be a module which exports a function. That function will be called whenever the view is rendered. For the sake of simplicity we'll just print the action and the model to the console. If there's one place where you'd want to enhance the experience, client-side controllers are where you want to put your code.\n\n    ```js\n    'use strict';\n\n    module.exports = function (model, container, route) {\n      console.log('Rendered view %s using model:\\n%s', route.action, JSON.stringify(model, null, 2));\n    };\n    ```\n\n    Since we weren't using the `--watch` flag from the Taunus CLI, you'll have to recompile the wiring at this point, so that the controller gets added to that manifest.\n\n    ```shell\n    taunus --output\n    ```\n\n    Of course, you'll now have to wire up the client-side JavaScript using [Browserify][38]!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Compiling your client-side JavaScript\n\n    You'll need to compile the `client/js/main.js` module, our client-side application's entry point, using Browserify since the code is written using CommonJS. In this example you'll install `browserify` globally to compile the code, but naturally you'll install it locally when working on a real-world application.\n\n    ```shell\n    npm install --global browserify\n    ```\n\n    Once you have the Browserify CLI, you'll be able to compile the code right from your command line. The `-d` flag tells Browserify to add an inline source map into the compiled bundle, making debugging easier for us. The `-o` flag redirects output to the indicated file, whereas the output is printed to standard output by default.\n\n    ```shell\n    mkdir -p .bin/public/js\n    browserify client/js/main.js -do .bin/public/js/all.js\n    ```\n\n    We haven't done much of anything with the Express application, so you'll need to adjust the `app.js` module to serve static assets. If you're used to Express, you'll notice there's nothing special about how we're using `serve-static`.\n\n    ```shell\n    npm install --save serve-static\n    ```\n\n    Let's configure the application to serve static assets from `.bin/public`.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var serveStatic = require('serve-static');\n    var app = express();\n    var options = {\n      routes: require('./controllers/routes'),\n      layout: require('./.bin/views/layout')\n    };\n\n    app.use(serveStatic('.bin/public'));\n    taunusExpress(taunus, app, options);\n    app.listen(3000);\n    ```\n\n    Next up, you'll have to edit the layout to include the compiled JavaScript bundle file.\n\n    ```jade\n    title=model.title\n    main!=partial\n    script(src='/js/all.js')\n    ```\n\n    Don't forget to compile `layout.jade` again.\n\n    ```shell\n    jadum views/** --output .bin\n    ```\n\n    Lastly, you can execute the application and see it in action!\n\n    ```shell\n    node app\n    ```\n\n    ![Screenshot with `node app` output][39]\n\n    If you open the application on a web browser, you'll notice that the appropriate information will be logged into the developer `console`.\n\n    ![Screenshot with the application running under Google Chrome][40]\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the client-side Taunus API\n\n    Taunus does provide [a thin API][18] in the client-side. Usage of that API belongs mostly inside the body of client-side view controllers, but there's a few methods you can take advantage of on a global scale as well.\n\n    Taunus can notify you whenever important events occur.\n\n    Event            | Arguments                 | Description\n    -----------------|---------------------------|------------------------------------\n    `'start'`        | `container, model, route` | Emitted when `taunus.mount` finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling `taunus.mount`.\n    `'render'`       | `container, model, route` | A view has just been rendered and its client-side controller is about to be invoked\n    `'change'`       | `route, model`            | Same as `'render'`, but only if `container` is the mountpoint and the route has changed.\n    `'fetch.start'`  |  `route, context`         | Emitted whenever an XHR request starts.\n    `'fetch.done'`   |  `route, context, data`   | Emitted whenever an XHR request ends successfully.\n    `'fetch.abort'`  |  `route, context`         | Emitted whenever an XHR request is purposely aborted.\n    `'fetch.error'`  |  `route, context, err`    | Emitted whenever an XHR request results in an HTTP error.\n\n    Besides events, there's a couple more methods you can use. The `taunus.navigate` method allows you to navigate to a URL without the need for a human to click on an anchor link. Then there's `taunus.partial`, and that allows you to render any partial view on a DOM element of your choosing, and it'll then invoke its controller. You'll need to come up with the model yourself, though.\n\n    Astonishingly, the API is further documented in [the API documentation][18].\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Caching and Prefetching\n\n    [Performance][25] plays an important role in Taunus. That's why the you can perform caching and prefetching on the client-side just by turning on a pair of flags. But what do these flags do exactly?\n\n    When turned on, by passing `{ cache: true }` as the third parameter for `taunus.mount`, the caching layer will make sure that responses are kept around for `15` seconds. Whenever a route needs a model in order to render a view, it'll first ask the caching layer for a fresh copy. If the caching layer doesn't have a copy, or if that copy is stale _(in this case, older than `15` seconds)_, then an AJAX request will be issued to the server. Of course, the duration is configurable. If you want to use a value other than the default, you should set `cache` to a number in seconds instead of just `true`.\n\n    Since Taunus understands that not every view operates under the same constraints, you're also able to set a `cache` freshness duration directly in your routes. The `cache` property in routes has precedence over the default value.\n\n    There's currently two caching stores: a raw in-memory store, and an [IndexedDB][28] store. IndexedDB is an embedded database solution, and you can think of it like an asynchronous version of `localStorage`. It has [surprisingly broad browser support][29], and in the cases where it's not supported then caching is done solely in-memory.\n\n    The prefetching mechanism is an interesting spin-off of caching, and it requires caching to be enabled in order to work. Whenever humans hover over a link, or whenever they put their finger on one of them _(the `touchstart` event)_, the prefetcher will issue an AJAX request for the view model for that link.\n\n    If the request ends successfully then the response will be cached in the same way any other view would be cached. If the human hovers over another link while the previous one is still being prefetched, then the old request is aborted, as not to drain their _(possibly limited)_ Internet connection bandwidth.\n\n    If the human clicks on the link before prefetching is completed, he'll navigate to the view as soon as prefetching ends, rather than firing another request. This helps Taunus save precious milliseconds when dealing with latency-sensitive operations.\n\n    Turning prefetching on is simply a matter of setting `prefetch` to `true` in the options passed to `taunus.mount`. For additional insights into the performance improvements Taunus can offer, head over to the [Performance Optimizations][25] guide.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Versioning\n\n    When you alter your views, change controllers, or modify the models, chances are the client-side is going to come across one of the following issues.\n\n    - Outdated view template functions in the client-side, causing new models to break\n    - Outdated client-side controllers, causing new models to break or miss out on functionality\n    - Outdated models in the cache, causing new views or controllers to break\n\n    Versioning handles these issues gracefully on your behalf. The way it works is that whenever you get a response from Taunus, a _version string (configured on the server-side)_ is included with it. If that version string doesn't match the one stored in the client, then the cache will be flushed and the human will be redirected, forcing a full page reload.\n\n    > The versioning API is unable to handle changes to routes, and it's up to you to make sure that the application stays backwards compatible when it comes to routing.\n    >\n    > Versioning can't intervene when the client-side is heavily relying on cached views and models, and the human is refusing to reload their browser. The server isn't being accessed and thus it can't communicate that everything on the cache may have become stale. The good news is that the human won't notice any oddities, as the site will continue to work as he knows it. When he finally attempts to visit something that isn't cached, a request is made, and the versioning engine resolves version discrepancies for them.\n\n    Making use of versioning involves setting the `version` field in the options, when invoking `taunus.mount` **on both the server-side and the client-side, using the same value**. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.\n\n    You may use your build identifier or the `version` field in `package.json`, but understand that it may cause the client-side to flush the cache too often _(maybe even on every deployment)_.\n\n    The default version string is set to `1`. The Taunus version will be prepended to yours, resulting in a value such as `t3.0.0;v1` where Taunus is running version `3.0.0` and your application is running version `1`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # The sky is the limit!\n\n    You're now familiar with how Taunus works on a high-level. You have covered a decent amount of ground, but you shouldn't stop there.\n\n    - Learn more about [the API Taunus has][18] to offer\n    - Go through the [performance optimization tips][25]. You may learn something new!\n    - _Familiarize yourself with the ways of progressive enhancement_\n      - Jeremy Keith enunciates [\"Be progressive\"][20]\n      - Christian Heilmann advocates for [\"Pragmatic progressive enhancement\"][26]\n      - Jake Archibald explains how [\"Progressive enhancement is faster\"][22]\n      - I blogged about how we should [\"Stop Breaking the Web\"][17]\n      - Guillermo Rauch argues for [\"7 Principles of Rich Web Applications\"][24]\n      - Aaron Gustafson writes [\"Understanding Progressive Enhancement\"][21]\n      - Orde Saunders gives his point of view in [\"Progressive enhancement for fault tolerance\"][23]\n    - Sift through the [complementary modules][15]. You may find something you hadn't thought of!\n\n    Also, get involved!\n\n    - Fork this repository and [send some pull requests][19] to improve these guides!\n    - See something, say something! If you detect a bug, [please create an issue][27]!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    > You'll find a [full fledged version of the Getting Started][41] tutorial application on GitHub.\n\n    [1]: https://github.com/taunus/taunus-express\n    [2]: https://github.com/taunus/taunus-hapi\n    [3]: https://github.com/taunus/hapiify\n    [4]: https://github.com/taunus/taunus.bevacqua.io\n    [5]: https://github.com/ponyfoo/ponyfoo\n    [6]: http://expressjs.com\n    [7]: http://hapijs.com\n    [8]: http://en.wikipedia.org/wiki/Convention_over_configuration\n    [9]: http://en.wikipedia.org/wiki/Ruby_on_Rails\n    [10]: https://github.com/janl/mustache.js\n    [11]: https://github.com/jadejs/jade\n    [12]: http://mozilla.github.io/nunjucks/\n    [13]: http://handlebarsjs.com/\n    [14]: http://www.embeddedjs.com/\n    [15]: /complements\n    [16]: https://github.com/bevacqua/jadum\n    [17]: http://ponyfoo.com/stop-breaking-the-web\n    [18]: /api\n    [19]: https://github.com/taunus/taunus.bevacqua.io/pulls\n    [20]: https://adactio.com/journal/7706\n    [21]: http://alistapart.com/article/understandingprogressiveenhancement\n    [22]: http://jakearchibald.com/2013/progressive-enhancement-is-faster/\n    [23]: https://decadecity.net/blog/2013/09/16/progressive-enhancement-for-fault-tolerance\n    [24]: http://rauchg.com/2014/7-principles-of-rich-web-applications/\n    [25]: /performance\n    [26]: http://icant.co.uk/articles/pragmatic-progressive-enhancement/\n    [27]: https://github.com/taunus/taunus/issues/new\n    [28]: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\n    [29]: http://caniuse.com/#feat=indexeddb\n    [30]: http://i.imgur.com/4P8vNe9.png\n    [31]: http://i.imgur.com/n8mH4mN.png\n    [32]: http://i.imgur.com/08lnCec.png\n    [33]: http://i.imgur.com/wUbnCyk.png\n    [34]: http://i.imgur.com/zjaJYCq.png\n    [35]: http://i.imgur.com/NvEWx9z.png\n    [36]: http://i.imgur.com/LgZRFn5.png\n    [37]: http://i.imgur.com/fIEe5Tm.png\n    [38]: http://browserify.org/\n    [39]: http://i.imgur.com/68O84wX.png\n    [40]: http://i.imgur.com/ZUF6NFl.png\n    [41]: https://github.com/taunus/getting-started\n    [42]: https://github.com/taunus/generator-taunus\n");
}
}
},{"jadum/runtime":32}],10:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function performance(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/performance.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/performance.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/performance.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/performance.jade" });
buf.push("<h1 id=\"performance-optimization\">Performance Optimization</h1>\n<p>Given that performance is one of the core values in both Taunus and User Experience, it deserved a first-class article on this site as well.</p>\n<p>There&#39;s a few things to take into account when developing an application if we want to strive for performance, and this article aims to be a collection of web performance best practices along with tips on how to improve performance especifically for applications built on top of Taunus.</p>\n<h1 id=\"performance-checklist\">Performance Checklist</h1>\n<p>If you haven&#39;t, you should read <a href=\"http://ponyfoo.com/articles/critical-path-performance-optimization\">&quot;Critical Path Performance Optimization&quot;</a> as a small guide of performance optimizations you should already be doing. The list below contains some of what&#39;s discussed in that article.</p>\n<ul>\n<li>Move away from dedicated client-side rendering</li>\n<li>Use <a href=\"http://nginx.org/\"><code>nginx</code></a> as a reverse proxy for your front-end servers</li>\n<li>Resize and optimize images</li>\n<li>Defer non-critical static asset loading</li>\n<li>Inline critical CSS and JavaScript</li>\n<li>Cache responses aggressively</li>\n<li>Ditch large libraries and frameworks</li>\n</ul>\n<h1 id=\"boosting-performance-with-taunus\">Boosting Performance with Taunus</h1>\n<p>When it comes to Taunus, there&#39;s a few more performance tweaks you should consider implementing.</p>\n<ul>\n<li>Choose <a href=\"#choose-the-right-boot-strategy\">the right boot strategy</a></li>\n<li>Turn on client-side <a href=\"#turn-on-client-side-caching\">caching</a></li>\n<li><a href=\"#use-versioning-to-ensure-cache-validity\">Use versioning</a> to ensure cache validity</li>\n<li>Enable prefetching for <a href=\"#enable-prefetching-for-predictive-cache-loading\">predictive cache loading</a></li>\n<li><a href=\"#send-views-and-controllers-to-the-client-selectively\">Send views and controllers to the client selectively</a></li>\n</ul>\n<p>Given that this site is about Taunus, we&#39;ll focus on the Taunus tweaks, as you can readily scour the web for general web performance advice.</p>\n<h1 id=\"choose-the-right-boot-strategy\">Choose the right boot strategy</h1>\n<p>Taunus needs to conjure up a view model so that you have access to its properties in the client-side view controller. To that end, Taunus offers three different boot strategies because there isn&#39;t a one-size-fits-all answer to the question <em>&quot;which boot strategy is the best one for me?&quot;</em>.</p>\n<p>When you want a relaxed approach to using Taunus, you should go for the <a href=\"/api#using-the-auto-strategy\"><code>auto</code></a> strategy. Maybe you&#39;re just getting started or you&#39;re not as concerned about performance just yet. Here Taunus will wait on you to call <a href=\"/api#-taunus-mount-container-wiring-options-\"><code>taunus.mount</code></a>, and then make an AJAX request to get the model for that view on your behalf. <em>This is the strategy that Taunus uses by default.</em></p>\n<p>If your models are consistently small because you have little dynamic content, or if you want to <em>execute the client-side controller as quickly as possible</em>, then the <a href=\"/api#using-the-inline-strategy\"><code>inline</code></a> strategy might be the best for you. Here you&#39;re expected to place the model in a <code>&lt;script&gt;</code> tag inside the view layout, and Taunus takes care of the rest.</p>\n<p>The third strategy is <a href=\"/api#using-the-manual-strategy\"><code>manual</code></a>, where you are supposed to somehow get a model, presumably using AJAX or script loading, and then letting Taunus know that you&#39;re done. This might be faster than the <a href=\"/api#using-the-auto-strategy\"><code>auto</code></a> approach, because you could write an inline script to fetch the model as Taunus is being downloaded. It also might be slower than <code>auto</code> in those cases where <code>auto</code> would&#39;ve used a cached copy of the model instead of making a request, so <em>your mileage may vary</em>.</p>\n<p>For more complex use cases, you may want to consider mixing different boot strategies, choosing the one that makes the most sense in each case. In these cases, you need to pay attention to having an agreement between what&#39;s being done in the view layout <em>(script inlining, AJAX call, or doing nothing)</em> and the <a href=\"/api#-taunus-mount-container-wiring-options-\"><code>taunus.mount</code></a> call <em>(picking a boot strategy that matches what&#39;s being done on the layout)</em>.</p>\n<p><sub><a href=\"#boosting-performance-with-taunus\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"turn-on-client-side-caching\">Turn on client-side caching</h1>\n<p>A caching engine is built into Taunus, and it&#39;s very easy to set up, you just have to ask for it by passing <a href=\"/api#caching\"><code>cache: true</code></a> to the client-side mountpoint. The cache can be used as a means to avoid making expensive AJAX calls for well-defined periods of time. You can determine how long an item will be cached for on a global level, as well as on a route-by-route basis.</p>\n<p>Taunus implements a two-tiered cache in which items are persisted both in-memory and in an IndexedDB database. This provides faster access to the cache while ensuring that data persists across browser reloads. In browsers that don&#39;t support IndexedDB, only the in-memory cache will be used.</p>\n<blockquote>\n<p>You can also use a <a href=\"/api#-taunus-intercept-action-fn-\">custom request interceptor</a> to listen for requests before they become AJAX calls and prevent that from happenning. The caching layer is in fact built as a request interceptor. You may want to use other mechanisms for preventing AJAX requests from being made, such as inferring a model from the models that were fetched so far for other views, or maybe simply preventing the request for views that don&#39;t need a model from the server at all.</p>\n</blockquote>\n<p>The <strong>cache can significantly improve your application&#39;s perceived responsiveness</strong>, but it could also do damage if your application is updated too frequently but you cache responses for long periods of time. It can also prove problematic if the models are highly volatile, as a cached response might be used for a view that expects some value to change every time. While caching isn&#39;t the solution to the latter, the former can be addressed using <a href=\"#use-versioning-to-ensure-cache-validity\">versioning</a>.</p>\n<p><sub><a href=\"#boosting-performance-with-taunus\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"use-versioning-to-ensure-cache-validity\">Use versioning to ensure cache validity</h1>\n<p>Versioning is a tough problem that single-page application frameworks don&#39;t address. If your framework of choice renders your application as a SPA, how exactly will it behave when you push updates to the server, <a href=\"http://bevacqua.io/bf\">many times a day</a>? Is it well defined? Will views received before the deployment be updated to the latest version? Will models cached in the old version of the application be invalidated? Will new views and client-side controllers make it to the user?</p>\n<p>Taunus handles all of these scenarios for you. Every response from the server contains the current version string for your app. If a response updates the version number stored in the client, cached views, controllers, and models, will become invalidated.</p>\n<p>If at any point Taunus is relying solely on the cache to render a view, then yes, the user will see the same view with the same model and the same controller that he saw a few seconds ago. But whenever a request hits the server and gets back to the client with an updated version number, Taunus will know to redirect the user <em>(or re-fetch each view)</em> so that the user gets the upgraded experience.</p>\n<blockquote>\n<p>Most importantly, versioning means that responses from the server will never break communication with clients that were connected before a deployment introduced an update, changing the models that the server returns, while the client expected models using a different structure.</p>\n</blockquote>\n<p>To <a href=\"/api#versioning\">enable versioning</a> you just have to choose a version number on both the server and the client mountpoints. This number should be updated with discretion, as frequent changes to the version number may defeat the performance improvements of client-side rendering.</p>\n<p><sub><a href=\"#boosting-performance-with-taunus\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"enable-prefetching-for-predictive-cache-loading\">Enable prefetching for predictive cache loading</h1>\n<blockquote>\n<p>Prefetching can yield huge performance boosts by simply issuing requests as soon as the human hints at his interest to load a view.</p>\n</blockquote>\n<p>By default Taunus ships with an <em>&quot;on-hover/on-touch-start&quot;</em> prefetcher that you can enable just by <a href=\"/api#prefetching\">setting the <code>prefetch: true</code> option</a> on the client-side mountpoint. It works by starting to fetch the model for a view as soon as humans hover over an anchor link, or put their finger on it on mobile devices. When the human does decide to click on the link, the prefetcher may be done, meaning that they&#39;ll be instantly redirected. If the prefetcher is still working, you&#39;d still be making a shortcut, as the user will be redirected as soon as the prefetcher finishes, giving you a head start and representing a perceived performance boost.</p>\n<p>You can also create your own prefetching rules. Maybe you&#39;d like to start prefetching a view as soon as humans start moving the mouse cursor towards a link. When you consider that a user shows intent to navigate to an action, you can call <a href=\"/api#using-taunus-prefetch-url-element-\"><code>taunus.prefetch</code></a> and start loading everything necessary for the view to be immediately loaded.</p>\n<p>Note that <strong>the prefetcher can only load <em>one route</em> at a time</strong>. This is by design, as prefetching lots of links would interfere with the human&#39;s connectivity, doing more harm than good. If the prefetcher is already loading a route when another attempt to prefetch is registered, the old request will be aborted to make room for the new one.</p>\n<p><sub><a href=\"#boosting-performance-with-taunus\"><em>(back to table of contents)</em></a></sub></p>\n<h1 id=\"send-views-and-controllers-to-the-client-selectively\">Send views and controllers to the client selectively</h1>\n<p>The most ambitious performance optimization that can be done with Taunus is deferring client-side views and controllers. The default behavior is to compile every view and controller, alongside routes and Taunus itself, and send everything in a single bundle to the client. As your application grows, it might no longer be practical to send everything together in a huge bundle, as performance would suffer.</p>\n<p>Taunus offers a mechanism through which you can defer specific actions, or parts of the application. When one of those parts of the application needs to be loaded, even when using <a href=\"/api#-taunus-partial-container-action-model-\"><code>taunus.partial</code></a>, the server-side will bundle the view template module and the client-side controller module and send that to the client. The client then runs <code>eval</code> on the bundle and proceeds to store it in its cache, using the same caching mechanism that&#39;s used for models <em>(except that views and controllers only go stale due to version changes, and never because of durations)</em>.</p>\n<p>To make use of the deferral mechanism you have to take a few things into consideration. First off, you&#39;ll have to use the <a href=\"/api#-defer-actions-\"><code>--defer</code></a> flag in the CLI to select the actions you want to defer. For instance, doing <code>taunus --defer admin</code> will defer all actions for the <code>admin</code> controller.</p>\n<p>Deferred modules are bundled with Browserify and get <strong>source maps by default</strong>, so debugging them during development is as easy as debugging non-deferred controllers or view template functions. You can change this behavior by <a href=\"/api#-options-deferminified-\">setting <code>deferMinified: true</code> at the server-side mountpoint</a>, which will minify the bundle and also remove the sourcemap. These bundles are generated the first time that they get requested, and subsequent requests for the same bundle will receive a copy that gets cached in memory.</p>\n<p>You have to be careful when deferring views and controllers, as the bundle for every component will be compiled independently. Here&#39;s a few considerations to take in mind.</p>\n<ul>\n<li>Use <code>require(&#39;taunus/global&#39;)</code> instead of <code>require(&#39;taunus&#39;)</code>. This way you&#39;ll access Taunus globally without embedding the entire library again. This is <strong>mandatory for deferred components</strong> that need to access the <code>taunus</code> public API</li>\n<li>Similarly, try and make use of globals for any large libraries you plan to use on deferred components. Each module you reference globally is a module that&#39;s not compiled on every component that <code>require</code>s it. This translates into leaner responses when clients need to fetch a template and a client-side controller</li>\n<li>Avoid maintaining global state across view controllers using modules. If you need to do so, consider using events instead. Deferred modules are self-contained, meaning that even if two separate controllers require a <code>./state</code> module, each controller will get its own copy of the <code>./state</code> module, and nothing will be shared.</li>\n</ul>\n<p>In the future, transports other than CommonJS may be available for defining controllers and view templates that can be deferred, but for now that&#39;s the only viable transport when it comes to deferred execution in Taunus.</p>\n<p><sub><a href=\"#boosting-performance-with-taunus\"><em>(back to table of contents)</em></a></sub></p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # Performance Optimization\n\n    Given that performance is one of the core values in both Taunus and User Experience, it deserved a first-class article on this site as well.\n\n    There's a few things to take into account when developing an application if we want to strive for performance, and this article aims to be a collection of web performance best practices along with tips on how to improve performance especifically for applications built on top of Taunus.\n\n    # Performance Checklist\n\n    If you haven't, you should read [\"Critical Path Performance Optimization\"][1] as a small guide of performance optimizations you should already be doing. The list below contains some of what's discussed in that article.\n\n    - Move away from dedicated client-side rendering\n    - Use [`nginx`][2] as a reverse proxy for your front-end servers\n    - Resize and optimize images\n    - Defer non-critical static asset loading\n    - Inline critical CSS and JavaScript\n    - Cache responses aggressively\n    - Ditch large libraries and frameworks\n\n    # Boosting Performance with Taunus\n\n    When it comes to Taunus, there's a few more performance tweaks you should consider implementing.\n\n    - Choose [the right boot strategy](#choose-the-right-boot-strategy)\n    - Turn on client-side [caching](#turn-on-client-side-caching)\n    - [Use versioning](#use-versioning-to-ensure-cache-validity) to ensure cache validity\n    - Enable prefetching for [predictive cache loading](#enable-prefetching-for-predictive-cache-loading)\n    - [Send views and controllers to the client selectively](#send-views-and-controllers-to-the-client-selectively)\n\n    Given that this site is about Taunus, we'll focus on the Taunus tweaks, as you can readily scour the web for general web performance advice.\n\n    # Choose the right boot strategy\n\n    Taunus needs to conjure up a view model so that you have access to its properties in the client-side view controller. To that end, Taunus offers three different boot strategies because there isn't a one-size-fits-all answer to the question _\"which boot strategy is the best one for me?\"_.\n\n    When you want a relaxed approach to using Taunus, you should go for the [`auto`][3] strategy. Maybe you're just getting started or you're not as concerned about performance just yet. Here Taunus will wait on you to call [`taunus.mount`][5], and then make an AJAX request to get the model for that view on your behalf. _This is the strategy that Taunus uses by default._\n\n    If your models are consistently small because you have little dynamic content, or if you want to _execute the client-side controller as quickly as possible_, then the [`inline`][4] strategy might be the best for you. Here you're expected to place the model in a `<script>` tag inside the view layout, and Taunus takes care of the rest.\n\n    The third strategy is [`manual`][6], where you are supposed to somehow get a model, presumably using AJAX or script loading, and then letting Taunus know that you're done. This might be faster than the [`auto`][3] approach, because you could write an inline script to fetch the model as Taunus is being downloaded. It also might be slower than `auto` in those cases where `auto` would've used a cached copy of the model instead of making a request, so _your mileage may vary_.\n\n    For more complex use cases, you may want to consider mixing different boot strategies, choosing the one that makes the most sense in each case. In these cases, you need to pay attention to having an agreement between what's being done in the view layout _(script inlining, AJAX call, or doing nothing)_ and the [`taunus.mount`][5] call _(picking a boot strategy that matches what's being done on the layout)_.\n\n    <sub>[_(back to table of contents)_](#boosting-performance-with-taunus)</sub>\n\n    # Turn on client-side caching\n\n    A caching engine is built into Taunus, and it's very easy to set up, you just have to ask for it by passing [`cache: true`][7] to the client-side mountpoint. The cache can be used as a means to avoid making expensive AJAX calls for well-defined periods of time. You can determine how long an item will be cached for on a global level, as well as on a route-by-route basis.\n\n    Taunus implements a two-tiered cache in which items are persisted both in-memory and in an IndexedDB database. This provides faster access to the cache while ensuring that data persists across browser reloads. In browsers that don't support IndexedDB, only the in-memory cache will be used.\n\n    > You can also use a [custom request interceptor][8] to listen for requests before they become AJAX calls and prevent that from happenning. The caching layer is in fact built as a request interceptor. You may want to use other mechanisms for preventing AJAX requests from being made, such as inferring a model from the models that were fetched so far for other views, or maybe simply preventing the request for views that don't need a model from the server at all.\n\n    The **cache can significantly improve your application's perceived responsiveness**, but it could also do damage if your application is updated too frequently but you cache responses for long periods of time. It can also prove problematic if the models are highly volatile, as a cached response might be used for a view that expects some value to change every time. While caching isn't the solution to the latter, the former can be addressed using [versioning](#use-versioning-to-ensure-cache-validity).\n\n    <sub>[_(back to table of contents)_](#boosting-performance-with-taunus)</sub>\n\n    # Use versioning to ensure cache validity\n\n    Versioning is a tough problem that single-page application frameworks don't address. If your framework of choice renders your application as a SPA, how exactly will it behave when you push updates to the server, [many times a day][10]? Is it well defined? Will views received before the deployment be updated to the latest version? Will models cached in the old version of the application be invalidated? Will new views and client-side controllers make it to the user?\n\n    Taunus handles all of these scenarios for you. Every response from the server contains the current version string for your app. If a response updates the version number stored in the client, cached views, controllers, and models, will become invalidated.\n\n    If at any point Taunus is relying solely on the cache to render a view, then yes, the user will see the same view with the same model and the same controller that he saw a few seconds ago. But whenever a request hits the server and gets back to the client with an updated version number, Taunus will know to redirect the user _(or re-fetch each view)_ so that the user gets the upgraded experience.\n\n    > Most importantly, versioning means that responses from the server will never break communication with clients that were connected before a deployment introduced an update, changing the models that the server returns, while the client expected models using a different structure.\n\n    To [enable versioning][11] you just have to choose a version number on both the server and the client mountpoints. This number should be updated with discretion, as frequent changes to the version number may defeat the performance improvements of client-side rendering.\n\n    <sub>[_(back to table of contents)_](#boosting-performance-with-taunus)</sub>\n\n    # Enable prefetching for predictive cache loading\n\n    > Prefetching can yield huge performance boosts by simply issuing requests as soon as the human hints at his interest to load a view.\n\n    By default Taunus ships with an _\"on-hover/on-touch-start\"_ prefetcher that you can enable just by [setting the `prefetch: true` option][12] on the client-side mountpoint. It works by starting to fetch the model for a view as soon as humans hover over an anchor link, or put their finger on it on mobile devices. When the human does decide to click on the link, the prefetcher may be done, meaning that they'll be instantly redirected. If the prefetcher is still working, you'd still be making a shortcut, as the user will be redirected as soon as the prefetcher finishes, giving you a head start and representing a perceived performance boost.\n\n    You can also create your own prefetching rules. Maybe you'd like to start prefetching a view as soon as humans start moving the mouse cursor towards a link. When you consider that a user shows intent to navigate to an action, you can call [`taunus.prefetch`][13] and start loading everything necessary for the view to be immediately loaded.\n\n    Note that **the prefetcher can only load _one route_ at a time**. This is by design, as prefetching lots of links would interfere with the human's connectivity, doing more harm than good. If the prefetcher is already loading a route when another attempt to prefetch is registered, the old request will be aborted to make room for the new one.\n\n    <sub>[_(back to table of contents)_](#boosting-performance-with-taunus)</sub>\n\n    # Send views and controllers to the client selectively\n\n    The most ambitious performance optimization that can be done with Taunus is deferring client-side views and controllers. The default behavior is to compile every view and controller, alongside routes and Taunus itself, and send everything in a single bundle to the client. As your application grows, it might no longer be practical to send everything together in a huge bundle, as performance would suffer.\n\n    Taunus offers a mechanism through which you can defer specific actions, or parts of the application. When one of those parts of the application needs to be loaded, even when using [`taunus.partial`][14], the server-side will bundle the view template module and the client-side controller module and send that to the client. The client then runs `eval` on the bundle and proceeds to store it in its cache, using the same caching mechanism that's used for models _(except that views and controllers only go stale due to version changes, and never because of durations)_.\n\n    To make use of the deferral mechanism you have to take a few things into consideration. First off, you'll have to use the [`--defer`][15] flag in the CLI to select the actions you want to defer. For instance, doing `taunus --defer admin` will defer all actions for the `admin` controller.\n\n    Deferred modules are bundled with Browserify and get **source maps by default**, so debugging them during development is as easy as debugging non-deferred controllers or view template functions. You can change this behavior by [setting `deferMinified: true` at the server-side mountpoint][16], which will minify the bundle and also remove the sourcemap. These bundles are generated the first time that they get requested, and subsequent requests for the same bundle will receive a copy that gets cached in memory.\n\n    You have to be careful when deferring views and controllers, as the bundle for every component will be compiled independently. Here's a few considerations to take in mind.\n\n    - Use `require('taunus/global')` instead of `require('taunus')`. This way you'll access Taunus globally without embedding the entire library again. This is **mandatory for deferred components** that need to access the `taunus` public API\n    - Similarly, try and make use of globals for any large libraries you plan to use on deferred components. Each module you reference globally is a module that's not compiled on every component that `require`s it. This translates into leaner responses when clients need to fetch a template and a client-side controller\n    - Avoid maintaining global state across view controllers using modules. If you need to do so, consider using events instead. Deferred modules are self-contained, meaning that even if two separate controllers require a `./state` module, each controller will get its own copy of the `./state` module, and nothing will be shared.\n\n    In the future, transports other than CommonJS may be available for defining controllers and view templates that can be deferred, but for now that's the only viable transport when it comes to deferred execution in Taunus.\n\n    <sub>[_(back to table of contents)_](#boosting-performance-with-taunus)</sub>\n\n    [1]: http://ponyfoo.com/articles/critical-path-performance-optimization\n    [2]: http://nginx.org/\n    [3]: /api#using-the-auto-strategy\n    [4]: /api#using-the-inline-strategy\n    [5]: /api#-taunus-mount-container-wiring-options-\n    [6]: /api#using-the-manual-strategy\n    [7]: /api#caching\n    [8]: /api#-taunus-intercept-action-fn-\n    [9]: http://rauchg.com/2014/7-principles-of-rich-web-applications/\n    [10]: http://bevacqua.io/bf\n    [11]: /api#versioning\n    [12]: /api#prefetching\n    [13]: /api#using-taunus-prefetch-url-element-\n    [14]: /api#-taunus-partial-container-action-model-\n    [15]: /api#-defer-actions-\n    [16]: /api#-options-deferminified-\n");
}
}
},{"jadum/runtime":32}],11:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function notFound(locals) {
var jade_debug = [{ lineno: 1, filename: "views/error/not-found.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/error/not-found.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/error/not-found.jade" });
buf.push("<h1>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 1, filename: jade_debug[0].filename });
buf.push("Not Found");
jade_debug.shift();
jade_debug.shift();
buf.push("</h1>");
jade_debug.shift();
jade_debug.unshift({ lineno: 3, filename: "views/error/not-found.jade" });
buf.push("<p>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 3, filename: jade_debug[0].filename });
buf.push("There doesn't seem to be anything here yet. If you believe this to be a mistake, please let us know!");
jade_debug.shift();
jade_debug.shift();
buf.push("</p>");
jade_debug.shift();
jade_debug.unshift({ lineno: 4, filename: "views/error/not-found.jade" });
buf.push("<p>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 5, filename: "views/error/not-found.jade" });
buf.push("<a href=\"https://twitter.com/nzgb\" target=\"_blank\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 5, filename: jade_debug[0].filename });
buf.push("&mdash; @nzgb");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</p>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "h1 Not Found\n\np There doesn't seem to be anything here yet. If you believe this to be a mistake, please let us know!\np\n  a(href='https://twitter.com/nzgb', target='_blank') &mdash; @nzgb\n");
}
}
},{"jadum/runtime":32}],12:[function(require,module,exports){
var jade = require("jadum/runtime");
module.exports = function layout(locals) {
var jade_debug = [{ lineno: 1, filename: "views/layout.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined, model, partial) {
jade_debug.unshift({ lineno: 0, filename: "views/layout.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/layout.jade" });
buf.push("<!DOCTYPE html>");
jade_debug.shift();
jade_debug.unshift({ lineno: 2, filename: "views/layout.jade" });
buf.push("<html lang=\"en\" itemscope itemtype=\"http://schema.org/Blog\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 3, filename: "views/layout.jade" });
buf.push("<head>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 4, filename: "views/layout.jade" });
buf.push("<title>" + (jade.escape(null == (jade_interp = model.title) ? "" : jade_interp)));
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.shift();
buf.push("</title>");
jade_debug.shift();
jade_debug.unshift({ lineno: 5, filename: "views/layout.jade" });
buf.push("<meta charset=\"utf-8\">");
jade_debug.shift();
jade_debug.unshift({ lineno: 6, filename: "views/layout.jade" });
buf.push("<link rel=\"shortcut icon\" href=\"/favicon.ico\">");
jade_debug.shift();
jade_debug.unshift({ lineno: 7, filename: "views/layout.jade" });
buf.push("<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">");
jade_debug.shift();
jade_debug.unshift({ lineno: 8, filename: "views/layout.jade" });
buf.push("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">");
jade_debug.shift();
jade_debug.unshift({ lineno: 9, filename: "views/layout.jade" });
buf.push("<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/all.css\">");
jade_debug.shift();
jade_debug.unshift({ lineno: 10, filename: "views/layout.jade" });
buf.push("<link rel=\"stylesheet\" type=\"text/css\" href=\"http://fonts.googleapis.com/css?family=Unica+One:400|Playfair+Display:700|Megrim:700|Fauna+One:400italic,400,700\">");
jade_debug.shift();
jade_debug.shift();
buf.push("</head>");
jade_debug.shift();
jade_debug.unshift({ lineno: 12, filename: "views/layout.jade" });
buf.push("<body id=\"top\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 13, filename: "views/layout.jade" });
buf.push("<header>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 14, filename: "views/layout.jade" });
buf.push("<h1>");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 15, filename: "views/layout.jade" });
buf.push("<a href=\"/\" aria-label=\"Go to home\" class=\"ly-title\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 15, filename: jade_debug[0].filename });
buf.push("Taunus");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</h1>");
jade_debug.shift();
jade_debug.unshift({ lineno: 16, filename: "views/layout.jade" });
buf.push("<h2 class=\"ly-subheading\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 16, filename: jade_debug[0].filename });
buf.push("Micro Isomorphic MVC Engine for Node.js");
jade_debug.shift();
jade_debug.shift();
buf.push("</h2>");
jade_debug.shift();
jade_debug.shift();
buf.push("</header>");
jade_debug.shift();
jade_debug.unshift({ lineno: 18, filename: "views/layout.jade" });
buf.push("<aside class=\"sb-sidebar\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 19, filename: "views/layout.jade" });
buf.push("<nav class=\"sb-container\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 20, filename: "views/layout.jade" });
buf.push("<ul class=\"nv-items\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 21, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 22, filename: "views/layout.jade" });
buf.push("<a href=\"/\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 22, filename: jade_debug[0].filename });
buf.push("About");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 23, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 24, filename: "views/layout.jade" });
buf.push("<a href=\"/getting-started\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 24, filename: jade_debug[0].filename });
buf.push("Getting Started");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 25, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 26, filename: "views/layout.jade" });
buf.push("<a href=\"/api\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 26, filename: jade_debug[0].filename });
buf.push("API Documentation");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 27, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 28, filename: "views/layout.jade" });
buf.push("<a href=\"/complements\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 28, filename: jade_debug[0].filename });
buf.push("Complementary Modules");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 29, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 30, filename: "views/layout.jade" });
buf.push("<a href=\"/performance\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 30, filename: jade_debug[0].filename });
buf.push("Performance Optimization");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 31, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 32, filename: "views/layout.jade" });
buf.push("<a href=\"/source-code\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 32, filename: jade_debug[0].filename });
buf.push("Source Code");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.unshift({ lineno: 33, filename: "views/layout.jade" });
buf.push("<li class=\"nv-item\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 34, filename: "views/layout.jade" });
buf.push("<a href=\"/changelog\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 34, filename: jade_debug[0].filename });
buf.push("Changelog");
jade_debug.shift();
jade_debug.shift();
buf.push("</a>");
jade_debug.shift();
jade_debug.shift();
buf.push("</li>");
jade_debug.shift();
jade_debug.shift();
buf.push("</ul>");
jade_debug.shift();
jade_debug.shift();
buf.push("</nav>");
jade_debug.shift();
jade_debug.shift();
buf.push("</aside>");
jade_debug.shift();
jade_debug.unshift({ lineno: 36, filename: "views/layout.jade" });
buf.push("<main id=\"application-root\" data-taunus=\"model\" class=\"ly-main\">" + (null == (jade_interp = partial) ? "" : jade_interp));
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.shift();
buf.push("</main>");
jade_debug.shift();
jade_debug.unshift({ lineno: 37, filename: "views/layout.jade" });
buf.push("<script src=\"/js/all.js\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.shift();
buf.push("</script>");
jade_debug.shift();
jade_debug.shift();
buf.push("</body>");
jade_debug.shift();
jade_debug.shift();
buf.push("</html>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined,"model" in locals_for_with?locals_for_with.model:typeof model!=="undefined"?model:undefined,"partial" in locals_for_with?locals_for_with.partial:typeof partial!=="undefined"?partial:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "doctype html\nhtml(lang='en', itemscope, itemtype='http://schema.org/Blog')\n  head\n    title=model.title\n    meta(charset='utf-8')\n    link(rel='shortcut icon', href='/favicon.ico')\n    meta(http-equiv='X-UA-Compatible', content='IE=edge,chrome=1')\n    meta(name='viewport', content='width=device-width, initial-scale=1')\n    link(rel='stylesheet', type='text/css', href='/css/all.css')\n    link(rel='stylesheet', type='text/css', href='http://fonts.googleapis.com/css?family=Unica+One:400|Playfair+Display:700|Megrim:700|Fauna+One:400italic,400,700')\n\n  body#top\n    header\n      h1\n        a.ly-title(href='/', aria-label='Go to home') Taunus\n      h2.ly-subheading Micro Isomorphic MVC Engine for Node.js\n\n    aside.sb-sidebar\n      nav.sb-container\n        ul.nv-items\n          li.nv-item\n            a(href='/') About\n          li.nv-item\n            a(href='/getting-started') Getting Started\n          li.nv-item\n            a(href='/api') API Documentation\n          li.nv-item\n            a(href='/complements') Complementary Modules\n          li.nv-item\n            a(href='/performance') Performance Optimization\n          li.nv-item\n            a(href='/source-code') Source Code\n          li.nv-item\n            a(href='/changelog') Changelog\n\n    main.ly-main#application-root(data-taunus='model')!=partial\n    script(src='/js/all.js')\n");
}
}
},{"jadum/runtime":32}],13:[function(require,module,exports){
'use strict';

var templates = {
  'documentation/about': require('./views/documentation/about.js'),
  'documentation/api': require('./views/documentation/api.js'),
  'documentation/complements': require('./views/documentation/complements.js'),
  'documentation/getting-started': require('./views/documentation/getting-started.js'),
  'documentation/performance': require('./views/documentation/performance.js'),
  'error/not-found': require('./views/error/not-found.js'),
  'layout': require('./views/layout.js')
};

var controllers = {
  'documentation/about': require('../client/js/controllers/documentation/about.js')
};

var routes = [
  {
    route: '/',
    action: 'documentation/about'
  },
  {
    route: '/getting-started',
    action: 'documentation/getting-started'
  },
  {
    route: '/api',
    action: 'documentation/api'
  },
  {
    route: '/complements',
    action: 'documentation/complements'
  },
  {
    route: '/performance',
    action: 'documentation/performance'
  },
  {
    route: '/source-code',
    ignore: true
  },
  {
    route: '/changelog',
    ignore: true
  },
  {
    route: '/:catchall*',
    action: 'error/not-found'
  }
];

module.exports = {
  templates: templates,
  controllers: controllers,
  routes: routes
};

},{"../client/js/controllers/documentation/about.js":14,"./views/documentation/about.js":6,"./views/documentation/api.js":7,"./views/documentation/complements.js":8,"./views/documentation/getting-started.js":9,"./views/documentation/performance.js":10,"./views/error/not-found.js":11,"./views/layout.js":12}],14:[function(require,module,exports){
'use strict';

module.exports = function () {
  console.log('Welcome to Taunus documentation mini-site!');
};

},{}],15:[function(require,module,exports){
'use strict';

var $ = require('dominus');
var raf = require('raf');
var taunus = require('taunus');
var throttle = require('./throttle');
var slowScrollCheck = throttle(scrollCheck, 50);
var hx = /^h[1-6]$/i;
var heading;

function conventions (container) {
  $('body').on('click', 'h1,h2,h3,h4,h5,h6', headingClick);

  raf(scroll);
}

function scroll () {
  slowScrollCheck();
  raf(scroll);
}

function scrollCheck () {
  var found = $('main').find('h1,h2,h3,h4,h5,h6').filter(inViewport);
  if (found.length === 0 || heading && found[0] === heading[0]) {
    return;
  }
  if (heading) {
    heading.removeClass('uv-highlight');
  }
  heading = found.i(0);
  heading.addClass('uv-highlight');
}

function inViewport (element) {
  var rect = element.getBoundingClientRect();
  var viewable = (
    Math.ceil(rect.top) >= 0 &&
    Math.ceil(rect.left) >= 0 &&
    Math.floor(rect.bottom) <= (window.innerHeight || document.documentElement.clientHeight) &&
    Math.floor(rect.right) <= (window.innerWidth || document.documentElement.clientWidth)
  );
  return viewable;
}

function findHeading (e) {
  var h = e.target;
  while (h && !hx.test(h.tagName)) {
    h = h.parentElement;
  }
  return h;
}

function headingClick (e) {
  var h = findHeading(e);
  if (h && h.id) {
    taunus.navigate('#' + h.id);
  }
}

module.exports = conventions;

},{"./throttle":17,"dominus":26,"raf":33,"taunus":48}],16:[function(require,module,exports){
(function (global){
'use strict';

// import the taunus module
var taunus = require('taunus');

// import the wiring module exported by Taunus
var wiring = require('../../.bin/wiring');

// import conventions
var conventions = require('./conventions');

// get the <main> element
var main = document.getElementById('application-root');

// set up conventions that get executed for every view
taunus.on('render', conventions);

// mount taunus so it starts its routing engine
taunus.mount(main, wiring);

// create globals to make it easy to debug
// don't do this in production!
global.$ = require('dominus');
global.taunus = taunus;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../.bin/wiring":13,"./conventions":15,"dominus":26,"taunus":48}],17:[function(require,module,exports){
(function (global){
'use strict';

function throttle (fn, t) {
  var cache;
  var last = -1;
  return function throttled () {
    var now = Date.now();
    if (now - last > t) {
      cache = fn.apply(this, arguments);
      last = now;
    }
    return cache;
  };
}

module.exports = throttle;
global.throttle=throttle;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],18:[function(require,module,exports){
var poser = require('./src/node');

module.exports = poser;

['Array', 'Function', 'Object', 'Date', 'String'].forEach(pose);

function pose (type) {
  poser[type] = function poseComputedType () { return poser(type); };
}

},{"./src/node":19}],19:[function(require,module,exports){
(function (global){
'use strict';

var d = global.document;

function poser (type) {
  var iframe = d.createElement('iframe');

  iframe.style.display = 'none';
  d.body.appendChild(iframe);

  return map(type, iframe.contentWindow);
}

function map (type, source) { // forward polyfills to the stolen reference!
  var original = window[type].prototype;
  var value = source[type];
  var prop;

  for (prop in original) {
    value.prototype[prop] = original[prop];
  }

  return value;
}

module.exports = poser;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],20:[function(require,module,exports){
(function (global){
'use strict';

var expando = 'sektor-' + Date.now();
var rsiblings = /[+~]/;
var document = global.document;
var del = document.documentElement;
var match = del.matches ||
            del.webkitMatchesSelector ||
            del.mozMatchesSelector ||
            del.oMatchesSelector ||
            del.msMatchesSelector;

function qsa (selector, context) {
  var existed, id, prefix, prefixed, adapter, hack = context !== document;
  if (hack) { // id hack for context-rooted queries
    existed = context.getAttribute('id');
    id = existed || expando;
    prefix = '#' + id + ' ';
    prefixed = prefix + selector.replace(/,/g, ',' + prefix);
    adapter = rsiblings.test(selector) && context.parentNode;
    if (!existed) { context.setAttribute('id', id); }
  }
  try {
    return (adapter || context).querySelectorAll(prefixed || selector);
  } catch (e) {
    return [];
  } finally {
    if (existed === null) { context.removeAttribute('id'); }
  }
}

function find (selector, ctx, collection, seed) {
  var element;
  var context = ctx || document;
  var results = collection || [];
  var i = 0;
  if (typeof selector !== 'string') {
    return results;
  }
  if (context.nodeType !== 1 && context.nodeType !== 9) {
    return []; // bail if context is not an element or document
  }
  if (seed) {
    while ((element = seed[i++])) {
      if (matchesSelector(element, selector)) {
        results.push(element);
      }
    }
  } else {
    results.push.apply(results, qsa(selector, context));
  }
  return results;
}

function matches (selector, elements) {
  return find(selector, null, null, elements);
}

function matchesSelector (element, selector) {
  return match.call(element, selector);
}

module.exports = find;

find.matches = matches;
find.matchesSelector = matchesSelector;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],21:[function(require,module,exports){
'use strict';

var poser = require('poser');
var Dominus = poser.Array();

module.exports = Dominus;

},{"poser":18}],22:[function(require,module,exports){
'use strict';

var $ = require('./public');
var core = require('./core');
var dom = require('./dom');
var classes = require('./classes');
var Dominus = require('./Dominus.ctor');

function equals (selector) {
  return function equals (elem) {
    return dom.matches(elem, selector);
  };
}

function straight (prop, one) {
  return function domMapping (selector) {
    var result = this.map(function (elem) {
      return dom[prop](elem, selector);
    });
    var results = core.flatten(result);
    return one ? results[0] : results;
  };
}

Dominus.prototype.prev = straight('prev');
Dominus.prototype.next = straight('next');
Dominus.prototype.parent = straight('parent');
Dominus.prototype.parents = straight('parents');
Dominus.prototype.children = straight('children');
Dominus.prototype.find = straight('qsa');
Dominus.prototype.findOne = straight('qs', true);

Dominus.prototype.where = function (selector) {
  return this.filter(equals(selector));
};

Dominus.prototype.is = function (selector) {
  return this.some(equals(selector));
};

Dominus.prototype.i = function (index) {
  return new Dominus(this[index]);
};

function compareFactory (fn) {
  return function compare () {
    $.apply(null, arguments).forEach(fn, this);
    return this;
  };
}

Dominus.prototype.and = compareFactory(function addOne (elem) {
  if (this.indexOf(elem) === -1) {
    this.push(elem);
  }
  return this;
});

Dominus.prototype.but = compareFactory(function addOne (elem) {
  var index = this.indexOf(elem);
  if (index !== -1) {
    this.splice(index, 1);
  }
  return this;
});

Dominus.prototype.css = function (name, value) {
  var props;
  var many = name && typeof name === 'object';
  var getter = !many && !value;
  if (getter) {
    return this.length ? dom.getCss(this[0], name) : null;
  }
  if (many) {
    props = name;
  } else {
    props = {};
    props[name] = value;
  }
  this.forEach(dom.setCss(props));
  return this;
};

Dominus.prototype.on = function (types, filter, fn) {
  this.forEach(function (elem) {
    types.split(' ').forEach(function (type) {
      dom.on(elem, type, filter, fn);
    });
  });
  return this;
};

Dominus.prototype.off = function (types, filter, fn) {
  this.forEach(function (elem) {
    types.split(' ').forEach(function (type) {
      dom.off(elem, type, filter, fn);
    });
  });
  return this;
};

[
  ['addClass', classes.add],
  ['removeClass', classes.remove],
  ['setClass', classes.set],
  ['removeClass', classes.remove],
  ['remove', dom.remove]
].forEach(mapMethods);

function mapMethods (data) {
  Dominus.prototype[data[0]] = function (value) {
    this.forEach(function (elem) {
      data[1](elem, value);
    });
    return this;
  };
}

[
  ['append', dom.append],
  ['appendTo', dom.appendTo],
  ['prepend', dom.prepend],
  ['prependTo', dom.prependTo],
  ['before', dom.before],
  ['beforeOf', dom.beforeOf],
  ['after', dom.after],
  ['afterOf', dom.afterOf],
  ['show', dom.show],
  ['hide', dom.hide]
].forEach(mapManipulation);

function mapManipulation (data) {
  Dominus.prototype[data[0]] = function (value) {
    data[1](this, value);
    return this;
  };
}

Dominus.prototype.hasClass = function (value) {
  return this.some(function (elem) {
    return classes.contains(elem, value);
  });
};

Dominus.prototype.attr = function (name, value) {
  var hash = name && typeof name === 'object';
  var set = hash ? setMany : setSingle;
  var setter = hash || arguments.length > 1;
  if (setter) {
    this.forEach(set);
    return this;
  } else {
    return this.length ? dom.getAttr(this[0], name) : null;
  }
  function setMany (elem) {
    dom.manyAttr(elem, name);
  }
  function setSingle (elem) {
    dom.attr(elem, name, value);
  }
};

function keyValue (key, value) {
  var getter = arguments.length < 2;
  if (getter) {
    return this.length ? dom[key](this[0]) : '';
  }
  this.forEach(function (elem) {
    dom[key](elem, value);
  });
  return this;
}

function keyValueProperty (prop) {
  Dominus.prototype[prop] = function accessor (value) {
    var getter = arguments.length < 1;
    if (getter) {
      return keyValue.call(this, prop);
    }
    return keyValue.call(this, prop, value);
  };
}

['html', 'text', 'value'].forEach(keyValueProperty);

Dominus.prototype.clone = function () {
  return this.map(function (elem) {
    return dom.clone(elem);
  });
};

module.exports = require('./public');

},{"./Dominus.ctor":21,"./classes":23,"./core":24,"./dom":25,"./public":28}],23:[function(require,module,exports){
'use strict';

var trim = /^\s+|\s+$/g;
var whitespace = /\s+/g;

function interpret (input) {
  return typeof input === 'string' ? input.replace(trim, '').split(whitespace) : input;
}

function classes (node) {
  return node.className.replace(trim, '').split(whitespace);
}

function set (node, input) {
  node.className = interpret(input).join(' ');
}

function add (node, input) {
  var current = remove(node, input);
  var values = interpret(input);
  current.push.apply(current, values);
  set(node, current);
  return current;
}

function remove (node, input) {
  var current = classes(node);
  var values = interpret(input);
  values.forEach(function (value) {
    var i = current.indexOf(value);
    if (i !== -1) {
      current.splice(i, 1);
    }
  });
  set(node, current);
  return current;
}

function contains (node, input) {
  var current = classes(node);
  var values = interpret(input);

  return values.every(function (value) {
    return current.indexOf(value) !== -1;
  });
}

module.exports = {
  add: add,
  remove: remove,
  contains: contains,
  set: set,
  get: classes
};

},{}],24:[function(require,module,exports){
'use strict';

var test = require('./test');
var Dominus = require('./Dominus.ctor');
var proto = Dominus.prototype;

function Applied (args) {
  return Dominus.apply(this, args);
}

Applied.prototype = proto;

['map', 'filter', 'concat'].forEach(ensure);

function ensure (key) {
  var original = proto[key];
  proto[key] = function applied () {
    return apply(original.apply(this, arguments));
  };
}

function apply (a) {
  return new Applied(a);
}

function cast (a) {
  if (a instanceof Dominus) {
    return a;
  }
  if (!a) {
    return new Dominus();
  }
  if (test.isElement(a)) {
    return new Dominus(a);
  }
  if (!test.isArray(a)) {
    return new Dominus();
  }
  return apply(a).filter(function (i) {
    return test.isElement(i);
  });
}

function flatten (a, cache) {
  return a.reduce(function (current, item) {
    if (Dominus.isArray(item)) {
      return flatten(item, current);
    } else if (current.indexOf(item) === -1) {
      return current.concat(item);
    }
    return current;
  }, cache || new Dominus());
}

module.exports = {
  apply: apply,
  cast: cast,
  flatten: flatten
};

},{"./Dominus.ctor":21,"./test":29}],25:[function(require,module,exports){
'use strict';

var sektor = require('sektor');
var Dominus = require('./Dominus.ctor');
var core = require('./core');
var events = require('./events');
var text = require('./text');
var test = require('./test');
var api = module.exports = {};
var delegates = {};

function castContext (context) {
  if (typeof context === 'string') {
    return api.qs(null, context);
  }
  if (test.isElement(context)) {
    return context;
  }
  if (context instanceof Dominus) {
    return context[0];
  }
  return null;
}

api.qsa = function (elem, selector) {
  var results = new Dominus();
  return sektor(selector, castContext(elem), results);
};

api.qs = function (elem, selector) {
  return api.qsa(elem, selector)[0];
};

api.matches = function (elem, selector) {
  return sektor.matchesSelector(elem, selector);
};

function relatedFactory (prop) {
  return function related (elem, selector) {
    var relative = elem[prop];
    if (relative) {
      if (!selector || api.matches(relative, selector)) {
        return core.cast(relative);
      }
    }
    return new Dominus();
  };
}

api.prev = relatedFactory('previousElementSibling');
api.next = relatedFactory('nextElementSibling');
api.parent = relatedFactory('parentElement');

function matches (elem, value) {
  if (!value) {
    return true;
  }
  if (value instanceof Dominus) {
    return value.indexOf(elem) !== -1;
  }
  if (test.isElement(value)) {
    return elem === value;
  }
  return api.matches(elem, value);
}

api.parents = function (elem, value) {
  var nodes = [];
  var node = elem;
  while (node.parentElement) {
    if (matches(node.parentElement, value)) {
      nodes.push(node.parentElement);
    }
    node = node.parentElement;
  }
  return core.apply(nodes);
};

api.children = function (elem, value) {
  var nodes = [];
  var children = elem.children;
  var child;
  var i;
  for (i = 0; i < children.length; i++) {
    child = children[i];
    if (matches(child, value)) {
      nodes.push(child);
    }
  }
  return core.apply(nodes);
};

// this method caches delegates so that .off() works seamlessly
function delegate (root, filter, fn) {
  if (delegates[fn._dd]) {
    return delegates[fn._dd];
  }
  fn._dd = Date.now();
  delegates[fn._dd] = delegator;
  function delegator (e) {
    var elem = e.target;
    while (elem && elem !== root) {
      if (api.matches(elem, filter)) {
        fn.apply(this, arguments); return;
      }
      elem = elem.parentElement;
    }
  }
  return delegator;
}

api.on = function (elem, type, filter, fn) {
  if (fn === void 0) {
    events.add(elem, type, filter); // filter _is_ fn
  } else {
    events.add(elem, type, delegate(elem, filter, fn));
  }
};

api.off = function (elem, type, filter, fn) {
  if (fn === void 0) {
    events.remove(elem, type, filter); // filter _is_ fn
  } else {
    events.remove(elem, type, delegate(elem, filter, fn));
  }
};

api.html = function (elem, html) {
  var getter = arguments.length < 2;
  if (getter) {
    return elem.innerHTML;
  } else {
    elem.innerHTML = html;
  }
};

api.text = function (elem, text) {
  var checkable = test.isCheckable(elem);
  var getter = arguments.length < 2;
  if (getter) {
    return checkable ? elem.value : elem.innerText || elem.textContent;
  } else if (checkable) {
    elem.value = text;
  } else {
    elem.innerText = elem.textContent = text;
  }
};

api.value = function (elem, value) {
  var checkable = test.isCheckable(elem);
  var getter = arguments.length < 2;
  if (getter) {
    return checkable ? elem.checked : elem.value;
  } else if (checkable) {
    elem.checked = value;
  } else {
    elem.value = value;
  }
};

api.attr = function (elem, name, value) {
  var camel = text.hyphenToCamel(name);
  if (camel in elem) {
    elem[camel] = value;
  } else if (value === null || value === void 0) {
    elem.removeAttribute(name);
  } else {
    elem.setAttribute(name, value);
  }
};

api.getAttr = function (elem, name) {
  var camel = text.hyphenToCamel(name);
  if (camel in elem) {
    return elem[camel];
  } else {
    return elem.getAttribute(name);
  }
};

api.manyAttr = function (elem, attrs) {
  Object.keys(attrs).forEach(function (attr) {
    api.attr(elem, attr, attrs[attr]);
  });
};

api.make = function (type) {
  return new Dominus(document.createElement(type));
};

api.clone = function (elem) {
  return elem.cloneNode(true);
};

api.remove = function (elem) {
  if (elem.parentElement) {
    elem.parentElement.removeChild(elem);
  }
};

api.append = function (elem, target) {
  if (manipulationGuard(elem, target, api.append)) {
    return;
  }
  elem.appendChild(target);
};

api.prepend = function (elem, target) {
  if (manipulationGuard(elem, target, api.prepend)) {
    return;
  }
  elem.insertBefore(target, elem.firstChild);
};

api.before = function (elem, target) {
  if (manipulationGuard(elem, target, api.before)) {
    return;
  }
  if (elem.parentElement) {
    elem.parentElement.insertBefore(target, elem);
  }
};

api.after = function (elem, target) {
  if (manipulationGuard(elem, target, api.after)) {
    return;
  }
  if (elem.parentElement) {
    elem.parentElement.insertBefore(target, elem.nextSibling);
  }
};

function manipulationGuard (elem, target, fn) {
  var right = target instanceof Dominus;
  var left = elem instanceof Dominus;
  if (left) {
    elem.forEach(manipulateMany);
  } else if (right) {
    manipulate(elem, true);
  }
  return left || right;

  function manipulate (elem, precondition) {
    if (right) {
      target.forEach(function (target, j) {
        fn(elem, cloneUnless(target, precondition && j === 0));
      });
    } else {
      fn(elem, cloneUnless(target, precondition));
    }
  }

  function manipulateMany (elem, i) {
    manipulate(elem, i === 0);
  }
}

function cloneUnless (target, condition) {
  return condition ? target : api.clone(target);
}

['appendTo', 'prependTo', 'beforeOf', 'afterOf'].forEach(flip);

function flip (key) {
  var original = key.split(/[A-Z]/)[0];
  api[key] = function (elem, target) {
    api[original](target, elem);
  };
}

api.show = function (elem, should, invert) {
  if (elem instanceof Dominus) {
    elem.forEach(showTest);
  } else {
    showTest(elem);
  }

  function showTest (current) {
    var ok = should === void 0 || should === true || typeof should === 'function' && should.call(current);
    display(current, invert ? !ok : ok);
  }
};

api.hide = function (elem, should) {
  api.show(elem, should, true);
};

function display (elem, should) {
  elem.style.display = should ? 'block' : 'none';
}

var numericCssProperties = {
  'column-count': true,
  'fill-opacity': true,
  'flex-grow': true,
  'flex-shrink': true,
  'font-weight': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'widows': true,
  'z-index': true,
  'zoom': true
};
var numeric = /^\d+$/;
var canFloat = 'float' in document.body.style;

api.getCss = function (elem, prop) {
  var hprop = text.hyphenate(prop);
  var fprop = !canFloat && hprop === 'float' ? 'cssFloat' : hprop;
  var result = window.getComputedStyle(elem)[hprop];
  if (prop === 'opacity' && result === '') {
    return 1;
  }
  if (result.substr(-2) === 'px' || numeric.test(result)) {
    return parseFloat(result, 10);
  }
  return result;
};

api.setCss = function (props) {
  var mapped = Object.keys(props).filter(bad).map(expand);
  function bad (prop) {
    var value = props[prop];
    return value !== null && value === value;
  }
  function expand (prop) {
    var hprop = text.hyphenate(prop);
    var value = props[prop];
    if (typeof value === 'number' && !numericCssProperties[hprop]) {
      value += 'px';
    }
    return {
      name: hprop, value: value
    };
  }
  return function (elem) {
    mapped.forEach(function (prop) {
      elem.style[prop.name] = prop.value;
    });
  };
};

},{"./Dominus.ctor":21,"./core":24,"./events":27,"./test":29,"./text":30,"sektor":20}],26:[function(require,module,exports){
'use strict';

module.exports = require('./Dominus.prototype');

},{"./Dominus.prototype":22}],27:[function(require,module,exports){
'use strict';

var addEvent = addEventEasy;
var removeEvent = removeEventEasy;
var hardCache = [];

if (!window.addEventListener) {
  addEvent = addEventHard;
}

if (!window.removeEventListener) {
  removeEvent = removeEventHard;
}

function addEventEasy (element, evt, fn) {
  return element.addEventListener(evt, fn);
}

function addEventHard (element, evt, fn) {
  return element.attachEvent('on' + evt, wrap(element, evt, fn));
}

function removeEventEasy (element, evt, fn) {
  return element.removeEventListener(evt, fn);
}

function removeEventHard (element, evt, fn) {
  return element.detachEvent('on' + evt, unwrap(element, evt, fn));
}

function wrapperFactory (element, evt, fn) {
  return function wrapper (originalEvent) {
    var e = originalEvent || window.event;
    e.target = e.target || e.srcElement;
    e.preventDefault  = e.preventDefault  || function preventDefault () { e.returnValue = false; };
    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
    fn.call(element, e);
  };
}

function wrap (element, evt, fn) {
  var wrapper = unwrap(element, evt, fn) || wrapperFactory(element, evt, fn);
  hardCache.push({
    wrapper: wrapper,
    element: element,
    evt: evt,
    fn: fn
  });
  return wrapper;
}

function unwrap (element, evt, fn) {
  var i = find(element, evt, fn);
  if (i) {
    var wrapper = hardCache[i].wrapper;
    hardCache.splice(i, 1); // free up a tad of memory
    return wrapper;
  }
}

function find (element, evt, fn) {
  var i, item;
  for (i = 0; i < hardCache.length; i++) {
    item = hardCache[i];
    if (item.element === element && item.evt === evt && item.fn === fn) {
      return i;
    }
  }
}

module.exports = {
  add: addEvent,
  remove: removeEvent
};

},{}],28:[function(require,module,exports){
'use strict';

var dom = require('./dom');
var core = require('./core');
var Dominus = require('./Dominus.ctor');
var tag = /^\s*<([a-z]+(?:-[a-z]+)?)\s*\/?>\s*$/i;

function api (selector, context) {
  var notText = typeof selector !== 'string';
  if (notText && arguments.length < 2) {
    return core.cast(selector);
  }
  if (notText) {
    return new Dominus();
  }
  var matches = selector.match(tag);
  if (matches) {
    return dom.make(matches[1]);
  }
  return api.find(selector, context);
}

api.find = function (selector, context) {
  return dom.qsa(context, selector);
};

api.findOne = function (selector, context) {
  return dom.qs(context, selector);
};

module.exports = api;

},{"./Dominus.ctor":21,"./core":24,"./dom":25}],29:[function(require,module,exports){
'use strict';

var nodeObjects = typeof Node === 'object';
var elementObjects = typeof HTMLElement === 'object';

function isNode (o) {
  return nodeObjects ? o instanceof Node : isNodeObject(o);
}

function isNodeObject (o) {
  return o &&
    typeof o === 'object' &&
    typeof o.nodeName === 'string' &&
    typeof o.nodeType === 'number';
}

function isElement (o) {
  return elementObjects ? o instanceof HTMLElement : isElementObject(o);
}

function isElementObject (o) {
  return o &&
    typeof o === 'object' &&
    typeof o.nodeName === 'string' &&
    o.nodeType === 1;
}

function isArray (a) {
  return Object.prototype.toString.call(a) === '[object Array]';
}

function isCheckable (elem) {
  return 'checked' in elem && elem.type === 'radio' || elem.type === 'checkbox';
}

module.exports = {
  isNode: isNode,
  isElement: isElement,
  isArray: isArray,
  isCheckable: isCheckable
};

},{}],30:[function(require,module,exports){
'use strict';

function hyphenToCamel (hyphens) {
  var part = /-([a-z])/g;
  return hyphens.replace(part, function (g, m) {
    return m.toUpperCase();
  });
}

function hyphenate (text) {
  var camel = /([a-z])([A-Z])/g;
  return text.replace(camel, '$1-$2').toLowerCase();
}

module.exports = {
  hyphenToCamel: hyphenToCamel,
  hyphenate: hyphenate
};

},{}],31:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jade=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i < a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */

function nulls(val) {
  return val != null && val !== '';
}

/**
 * join array as classes.
 *
 * @param {*} val
 * @return {String}
 */
exports.joinClasses = joinClasses;
function joinClasses(val) {
  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;
}

/**
 * Render the given classes.
 *
 * @param {Array} classes
 * @param {Array.<Boolean>} escaped
 * @return {String}
 */
exports.cls = function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i < classes.length; i++) {
    if (escaped && escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return ' class="' + text + '"';
  } else {
    return '';
  }
};

/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */
exports.attr = function attr(key, val, escaped, terse) {
  if ('boolean' == typeof val || null == val) {
    if (val) {
      return ' ' + (terse ? key : key + '="' + key + '"');
    } else {
      return '';
    }
  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
  } else if (escaped) {
    return ' ' + key + '="' + exports.escape(val) + '"';
  } else {
    return ' ' + key + '="' + val + '"';
  }
};

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 */
exports.attrs = function attrs(obj, terse){
  var buf = [];

  var keys = Object.keys(obj);

  if (keys.length) {
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('class' == key) {
        if (val = joinClasses(val)) {
          buf.push(' ' + key + '="' + val + '"');
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }

  return buf.join('');
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function escape(html){
  var result = String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
  if (result === '' + html) return html;
  else return result;
};

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) && !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str = str || _dereq_('fs').readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};

},{"fs":2}],2:[function(_dereq_,module,exports){

},{}]},{},[1])
(1)
});
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(require,module,exports){
module.exports = require('jade/runtime');

},{"jade/runtime":31}],33:[function(require,module,exports){
var now = require('performance-now')
  , global = typeof window === 'undefined' ? {} : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = global['request' + suffix]
  , caf = global['cancel' + suffix] || global['cancelRequest' + suffix]
  , isNative = true

for(var i = 0; i < vendors.length && !raf; i++) {
  raf = global[vendors[i] + 'Request' + suffix]
  caf = global[vendors[i] + 'Cancel' + suffix]
      || global[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  isNative = false

  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  if(!isNative) {
    return raf.call(global, fn)
  }
  return raf.call(global, function() {
    try{
      fn.apply(this, arguments)
    } catch(e) {
      setTimeout(function() { throw e }, 0)
    }
  })
}
module.exports.cancel = function() {
  caf.apply(global, arguments)
}

},{"performance-now":34}],34:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.6.3
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/*
//@ sourceMappingURL=performance-now.map
*/

}).call(this,require("/Users/nico/.nvm/v0.10.26/lib/node_modules/watchify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/nico/.nvm/v0.10.26/lib/node_modules/watchify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":1}],35:[function(require,module,exports){
(function (global){
'use strict';

var raf = require('raf');
var clone = require('./clone');
var emitter = require('./emitter');
var fetcher = require('./fetcher');
var prefetcher = require('./prefetcher');
var view = require('./view');
var router = require('./router');
var state = require('./state');
var document = require('./global/document');
var location = require('./global/location');
var history = require('./global/history');
var versioning = require('../versioning');

function modern () { // needs to be a function because testing
  return history && history.modern !== false;
}

function go (url, options) {
  var o = options || {};
  var direction = o.replaceState ? 'replaceState' : 'pushState';
  var context = o.context || null;
  var route = router(url);
  if (!route) {
    if (o.strict !== true) {
      global.DEBUG && global.DEBUG('[activator] redirecting to %s', url);
      location.href = url;
    }
    return;
  }

  global.DEBUG && global.DEBUG('[activator] route matches %s', route.route);

  var notForced = o.force !== true;
  var same = router.equals(route, state.route);
  if (same && notForced) {
    if (route.parts.hash) {
      global.DEBUG && global.DEBUG('[activator] same route and hash, updating scroll position');
      scrollInto(id(route.parts.hash), o.scroll);
      navigation(route, state.model, direction);
      return; // anchor hash-navigation on same page ignores router
    }
    global.DEBUG && global.DEBUG('[activator] same route, resolving');
    resolved(state.model);
    return;
  }

  global.DEBUG && global.DEBUG('[activator] %s', notForced ? 'not same route as before' : 'forced to fetch same route');

  if (!modern()) {
    global.DEBUG && global.DEBUG('[activator] not modern, redirecting to %s', url);
    location.href = url;
    return;
  }

  global.DEBUG && global.DEBUG('[activator] fetching %s', route.url);
  prefetcher.abortIntent();
  fetcher.abortPending();
  fetcher(route, { element: context, source: 'intent' }, maybeResolved);

  function maybeResolved (err, data) {
    if (err) {
      return;
    }
    if (data.version !== state.version) {
      global.DEBUG && global.DEBUG('[activator] version change (is "%s", was "%s"), redirecting to %s', data.version, state.version, url);
      location.href = url; // version change demands fallback to strict navigation
      return;
    }
    if ('redirectTo' in data) {
      global.DEBUG && global.DEBUG('[activator] redirect detected in response, redirecting to %s', data.redirectTo);
      location.href = data.redirectTo; // redirects typically represent layout changes, we should follow them
      return;
    }
    resolved(data.model);
  }

  function resolved (model) {
    var same = router.equals(route, state.route);
    navigation(route, model, same ? 'replaceState' : direction);
    view(state.container, null, model, route);
    scrollInto(id(route.parts.hash), o.scroll);
  }
}

function start (data) {
  if (data.version !== state.version) {
    global.DEBUG && global.DEBUG('[activator] version change, reloading browser');
    location.reload(); // version may change between Taunus loading and a model becoming available
    return;
  }
  var model = data.model;
  var route = router(location.href);
  navigation(route, model, 'replaceState');
  emitter.emit('start', state.container, model, route);
  global.DEBUG && global.DEBUG('[activator] started, executing client-side controller');
  view(state.container, null, model, route, { render: false });
  global.onpopstate = back;
}

function back (e) {
  var s = e.state;
  var empty = !s || !s.__taunus;
  if (empty) {
    return;
  }
  global.DEBUG && global.DEBUG('[activator] backwards history navigation with state', s);
  var model = s.model;
  var route = router(location.href);
  navigation(route, model, 'replaceState');
  view(state.container, null, model, route);
  scrollInto(id(route.parts.hash));
}

function scrollInto (id, enabled) {
  if (enabled === false) {
    return;
  }
  global.DEBUG && global.DEBUG('[activator] scrolling into "%s"', id || '#document');

  var elem = id && document.getElementById(id) || document.documentElement;
  if (elem && elem.scrollIntoView) {
    raf(scrollSoon);
  }

  function scrollSoon () {
    elem.scrollIntoView();
  }
}

function id (hash) {
  return orEmpty(hash).substr(1);
}

function orEmpty (value) {
  return value || '';
}

function navigation (route, model, direction) {
  var data;

  global.DEBUG && global.DEBUG('[activator] history :%s %s', direction.replace('State', ''), route.url);
  state.route = route;
  state.model = clone(model);
  if (model.title) {
    document.title = model.title;
  }
  if (modern() && history[direction]) {
    data = {
      __taunus: true,
      model: model
    };
    history[direction](data, model.title, route.url);
  }
}

module.exports = {
  start: start,
  go: go
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../versioning":81,"./clone":38,"./emitter":41,"./fetcher":43,"./global/document":44,"./global/history":45,"./global/location":46,"./prefetcher":54,"./router":55,"./state":56,"./view":64,"raf":33}],36:[function(require,module,exports){
'use strict';

var clone = require('./clone');
var once = require('./once');
var state = require('./state');
var raw = require('./stores/raw');
var idb = require('./stores/idb');
var versioning = require('../versioning');
var stores = [raw, idb];

function get (type, key, done) {
  var i = 0;

  function next () {
    var gotOnce = once(got);
    var store = stores[i++];
    if (store) {
      store.get(type, key, gotOnce);
      setTimeout(gotOnce, store === idb ? 35 : 5); // at worst, spend 40ms on caching layers
    } else {
      done(true);
    }

    function got (err, item) {
      if (err) {
        next();
      } else if (valid(item)) {
        done(false, blob(item)); // always return a unique copy
      } else {
        next();
      }
    }

    function valid (item) {
      if (!item) {
        return false; // cache must have item
      }
      var mismatch = typeof item.version !== 'string' || item.version !== state.version;
      if (mismatch) {
        return false; // cache must match current version
      }
      var stale = typeof item.expires !== 'number' || Date.now() >= item.expires;
      if (stale) {
        return false; // cache must be fresh
      }
      return true;
    }

    function blob (item) {
      var singular = type.substr(0, type.length - 1);
      var data = clone(item.data);
      var response = {
        version: item.version
      };
      response[singular] = data;
      return response;
    }
  }

  next();
}

function set (type, key, data, duration) {
  if (duration < 1) { // sanity
    return;
  }
  var cloned = clone(data); // freeze a copy for our records
  stores.forEach(store);
  function store (s) {
    s.set(type, key, {
      data: cloned,
      version: state.version,
      expires: Date.now() + duration
    });
  }
}

module.exports = {
  get: get,
  set: set
};

},{"../versioning":81,"./clone":38,"./once":53,"./state":56,"./stores/idb":58,"./stores/raw":59}],37:[function(require,module,exports){
(function (global){
'use strict';

var cache = require('./cache');
var idb = require('./stores/idb');
var state = require('./state');
var emitter = require('./emitter');
var interceptor = require('./interceptor');
var defaults = 15;
var baseline;

function e (value) {
  return value || '';
}

function setup (duration, route) {
  baseline = parseDuration(duration);
  if (baseline < 1) {
    state.cache = false;
    return;
  }
  interceptor.add(intercept);
  emitter.on('fetch.done', persist);
  state.cache = true;
}

function intercept (e) {
  global.DEBUG && global.DEBUG('[cache] attempting to intercept %s', e.route.url);
  cache.get('models', e.route.parts.path, result);

  function result (err, data) {
    global.DEBUG && global.DEBUG('[cache] interception for %s %s', e.route.url, err || !data ? 'failed' : 'succeeded');
    if (!err && data) {
      e.preventDefault(data);
    }
  }
}

function parseDuration (value) {
  if (value === true) {
    return baseline || defaults;
  }
  if (typeof value === 'number') {
    return value;
  }
  return 0;
}

function persist (route, context, data) {
  if (!state.cache) {
    return;
  }
  if (route.cache === false) {
    return;
  }
  var d = baseline;
  if (typeof route.cache === 'number') {
    d = route.cache;
  }
  var target = context.hijacker || route.action;
  var freshness = parseDuration(d) * 1000;
  if ('model' in data) {
    global.DEBUG && global.DEBUG('[cache] saving model for %s', route.parts.path);
    cache.set('models', route.parts.path, data.model, freshness);
  }
  if ('template' in data) {
    global.DEBUG && global.DEBUG('[cache] saving template for %s', target);
    cache.set('templates', target, data.template, Infinity);
  }
  if ('controller' in data) {
    global.DEBUG && global.DEBUG('[cache] saving controller for %s', target);
    cache.set('controllers', target, data.controller, Infinity);
  }
}

function ready (fn) {
  if (state.cache) {
    idb.tested(fn); // wait on idb compatibility tests
  } else {
    fn(false); // caching is a no-op
  }
}

module.exports = {
  setup: setup,
  persist: persist,
  ready: ready
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cache":36,"./emitter":41,"./interceptor":49,"./state":56,"./stores/idb":58}],38:[function(require,module,exports){
'use strict';

function clone (value) {
  return JSON.parse(JSON.stringify(value));
}

module.exports = clone;

},{}],39:[function(require,module,exports){
(function (global){
'use strict';

var state = require('./state');
var caching = require('./caching');
var unstrictEval = require('./unstrictEval');
var idb = require('./stores/idb');
var deferred = require('../lib/deferred');

function set (action, data) {
  store('template');
  store('controller');

  function store (key) {
    var type = key + 's';

    if (key in data) {
      push(type, action, data[key], data.version);
    }
  }
}

function refill () {
  caching.ready(pullComponents);
}

function pullComponents (enabled) {
  if (!enabled) { // bail if caching is turned off
    return;
  }
  idb.get('controllers', pull.bind(null, 'controllers'));
  idb.get('templates', pull.bind(null, 'templates'));
}

function pull (type, err, items) {
  if (err) {
    return;
  }
  items.forEach(pullItem);

  function pullItem (item) {
    push(type, item.key, item.data, item.version);
  }
}

function push (type, action, value, version) {
  var singular = type.substr(0, type.length - 1);
  var is = deferred(action, state.deferrals);
  if (is === false) {
    global.DEBUG && global.DEBUG('[componentCache] action "%s" is not deferred, not storing %s', action, singular);
    return;
  }
  if (version === state.version) {
    global.DEBUG && global.DEBUG('[componentCache] storing %s for %s in state', singular, action);
    state[type][action] = {
      fn: parse(singular, value),
      version: version
    };
  } else {
    global.DEBUG && global.DEBUG('[componentCache] bad version: %s !== %s', version, state.version);
  }
}

function parse (type, value) {
  if (value) {
    try {
      return unstrictEval(value);
    } catch (e) {
      global.DEBUG && global.DEBUG('[componentCache] %s eval failed', type, e);
    }
  }
}

module.exports = {
  set: set,
  refill: refill
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lib/deferred":66,"./caching":37,"./state":56,"./stores/idb":58,"./unstrictEval":63}],40:[function(require,module,exports){
(function (global){
'use strict';

var state = require('./state');
var deferred = require('../lib/deferred');

function needs (action) {
  var demands = [];
  var is = deferred(action, state.deferrals);
  if (is) {
    if (invalid('templates')) {
      demands.push('template');
    }
    if (invalid('controllers')) {
      demands.push('controller');
    }
  }

  function invalid (type) {
    var store = state[type];
    var fail = !store[action] || store[action].version !== state.version;
    if (fail) {
      global.DEBUG && global.DEBUG('[deferral] deferred %s %s not found', action, type.substr(0, type.length - 1));
      return true;
    }
    return false;
  }

  return demands;
}

module.exports = {
  needs: needs
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lib/deferred":66,"./state":56}],41:[function(require,module,exports){
'use strict';

var emitter = require('contra.emitter');

module.exports = emitter({}, { throws: false });

},{"contra.emitter":68}],42:[function(require,module,exports){
(function (global){
'use strict';

function add (element, type, fn) {
  if (element.addEventListener) {
    element.addEventListener(type, fn);
  } else if (element.attachEvent) {
    element.attachEvent('on' + type, wrapperFactory(element, fn));
  } else {
    element['on' + type] = fn;
  }
}

function wrapperFactory (element, fn) {
  return function wrapper (originalEvent) {
    var e = originalEvent || global.event;
    e.target = e.target || e.srcElement;
    e.preventDefault  = e.preventDefault  || function preventDefault () { e.returnValue = false; };
    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
    fn.call(element, e);
  };
}

module.exports = {
  add: add
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],43:[function(require,module,exports){
(function (global){
'use strict';

var xhr = require('./xhr');
var state = require('./state');
var router = require('./router');
var emitter = require('./emitter');
var deferral = require('./deferral');
var interceptor = require('./interceptor');
var componentCache = require('./componentCache');
var lastXhr = {};

function e (value) {
  return value || '';
}

function negotiate (route, context) {
  var parts = route.parts;
  var qs = e(parts.search);
  var p = qs ? '&' : '?';
  var target = context.hijacker || route.action;
  var demands = ['json'].concat(deferral.needs(target));
  if (context.hijacker && context.hijacker !== route.action) {
    demands.push('hijacker=' + context.hijacker);
  }
  return parts.pathname + qs + p + demands.join('&');
}

function abort (source) {
  if (lastXhr[source]) {
    lastXhr[source].abort();
  }
}

function abortPending () {
  Object.keys(lastXhr).forEach(abort);
  lastXhr = {};
}

function fetcher (route, context, done) {
  var url = route.url;
  if (lastXhr[context.source]) {
    lastXhr[context.source].abort();
    lastXhr[context.source] = null;
  }

  global.DEBUG && global.DEBUG('[fetcher] requested %s', route.url);

  interceptor.execute(route, afterInterceptors);

  function afterInterceptors (err, result) {
    if (!err && result.defaultPrevented && !context.hijacker) {
      global.DEBUG && global.DEBUG('[fetcher] prevented %s with data', route.url, result.data);
      done(null, result.data);
    } else {
      emitter.emit('fetch.start', route, context);
      lastXhr[context.source] = xhr(negotiate(route, context), notify);
    }
  }

  function notify (err, data, res) {
    if (err) {
      global.DEBUG && global.DEBUG('[fetcher] failed for %s', route.url);
      if (err.message === 'aborted') {
        emitter.emit('fetch.abort', route, context);
      } else {
        emitter.emit('fetch.error', route, context, err);
      }
    } else {
      global.DEBUG && global.DEBUG('[fetcher] succeeded for %s', route.url);
      if (data && data.version) {
        state.version = data.version; // sync version expectation with server-side
        componentCache.set(router(res.url).parts.query.hijacker || route.action, data);
      }
      emitter.emit('fetch.done', route, context, data);
    }
    done(err, data);
  }
}

fetcher.abortPending = abortPending;

module.exports = fetcher;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./componentCache":39,"./deferral":40,"./emitter":41,"./interceptor":49,"./router":55,"./state":56,"./xhr":65}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.document;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],45:[function(require,module,exports){
(function (global){
'use strict';

var modern = 'history' in global && 'pushState' in global.history;
var api = modern && global.history;

// Google Chrome 38 on iOS makes weird changes to history.replaceState, breaking it
var nativeFn = require('../nativeFn');
var nativeReplaceBroken = modern && !nativeFn(api.replaceState);
if (nativeReplaceBroken) {
  api = {
    pushState: api.pushState.bind(api)
  };
}

module.exports = api;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../nativeFn":52}],46:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],47:[function(require,module,exports){
'use strict';

var emitter = require('./emitter');
var links = require('./links');

function attach () {
  emitter.on('start', links);
}

module.exports = {
  attach: attach
};

},{"./emitter":41,"./links":50}],48:[function(require,module,exports){
(function (global){
'use strict';

global.DEBUG && global.DEBUG('[index] loading taunus');

if (global.taunus !== void 0) {
  throw new Error('Use require(\'taunus/global\') after the initial require(\'taunus\') statement!');
}

var state = require('./state');
var stateClear = require('./stateClear');
var interceptor = require('./interceptor');
var activator = require('./activator');
var emitter = require('./emitter');
var hooks = require('./hooks');
var view = require('./view');
var mount = require('./mount');
var router = require('./router');
var xhr = require('./xhr');
var prefetcher = require('./prefetcher');
var resolve = require('../lib/resolve');

state.clear = stateClear;
hooks.attach();

function bind (method) {
  return function () {
    return emitter[method].apply(emitter, arguments);
  };
}

module.exports = global.taunus = {
  mount: mount,
  partial: view.partial,
  on: bind('on'),
  once: bind('once'),
  off: bind('off'),
  intercept: interceptor.add,
  navigate: activator.go,
  prefetch: prefetcher.start,
  state: state,
  route: router,
  resolve: resolve,
  xhr: xhr
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lib/resolve":67,"./activator":35,"./emitter":41,"./hooks":47,"./interceptor":49,"./mount":51,"./prefetcher":54,"./router":55,"./state":56,"./stateClear":57,"./view":64,"./xhr":65}],49:[function(require,module,exports){
(function (global){
'use strict';

var emitter = require('contra.emitter');
var once = require('./once');
var router = require('./router');
var interceptors = emitter({ count: 0 }, { async: true });

function getInterceptorEvent (route) {
  var e = {
    url: route.url,
    route: route,
    parts: route.parts,
    data: null,
    canPreventDefault: true,
    defaultPrevented: false,
    preventDefault: once(preventDefault)
  };

  function preventDefault (data) {
    if (!e.canPreventDefault) {
      return;
    }
    e.canPreventDefault = false;
    e.defaultPrevented = true;
    e.data = data;
  }

  return e;
}

function add (action, fn) {
  if (arguments.length === 1) {
    fn = action;
    action = '*';
  }
  interceptors.count++;
  interceptors.on(action, fn);
}

function execute (route, done) {
  var e = getInterceptorEvent(route);
  if (interceptors.count === 0) { // fail fast
    end(); return;
  }
  var fn = once(end);
  var preventDefaultBase = e.preventDefault;

  e.preventDefault = once(preventDefaultEnds);

  global.DEBUG && global.DEBUG('[interceptor] executing for %s', route.url);

  interceptors.emit('*', e);
  interceptors.emit(route.action, e);

  setTimeout(fn, 50); // at worst, spend 50ms waiting on interceptors

  function preventDefaultEnds () {
    preventDefaultBase.apply(null, arguments);
    fn();
  }

  function end () {
    global.DEBUG && global.DEBUG('[interceptor] %s for %s', interceptors.count === 0 && 'skipped' || e.defaultPrevented && 'prevented' || 'timed out', route.url);
    e.canPreventDefault = false;
    done(null, e);
  }
}

module.exports = {
  add: add,
  execute: execute
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./once":53,"./router":55,"contra.emitter":68}],50:[function(require,module,exports){
(function (global){
'use strict';

var state = require('./state');
var router = require('./router');
var events = require('./events');
var prefetcher = require('./prefetcher');
var activator = require('./activator');
var document = require('./global/document');
var origin = document.location.origin;
var leftClick = 1;
var prefetching = [];
var clicksOnHold = [];

function links () {
  if (state.prefetch && state.cache) { // prefetch without cache makes no sense
    global.DEBUG && global.DEBUG('[links] listening for prefetching opportunities');
    events.add(document.body, 'mouseover', maybePrefetch);
    events.add(document.body, 'touchstart', maybePrefetch);
  }
  global.DEBUG && global.DEBUG('[links] listening for rerouting opportunities');
  events.add(document.body, 'click', maybeReroute);
}

function so (anchor) {
  return anchor.origin === origin;
}

function leftClickOnAnchor (e, anchor) {
  return anchor.pathname && e.which === leftClick && !e.metaKey && !e.ctrlKey;
}

function targetOrAnchor (e) {
  var anchor = e.target;
  while (anchor) {
    if (anchor.tagName === 'A') {
      return anchor;
    }
    anchor = anchor.parentElement;
  }
}

function maybeReroute (e) {
  var anchor = targetOrAnchor(e);
  if (anchor && so(anchor) && leftClickOnAnchor(e, anchor)) {
    reroute(e, anchor);
  }
}

function maybePrefetch (e) {
  var anchor = targetOrAnchor(e);
  if (anchor && so(anchor)) {
    prefetch(e, anchor);
  }
}

function noop () {}

function parse (anchor) {
  return anchor.pathname + anchor.search + anchor.hash;
}

function reroute (e, anchor) {
  var url = parse(anchor);
  var route = router(url);
  if (!route) {
    return;
  }

  prevent();

  if (prefetcher.busy(url)) {
    global.DEBUG && global.DEBUG('[links] navigation to %s blocked by prefetcher', route.url);
    prefetcher.registerIntent(url);
    return;
  }

  global.DEBUG && global.DEBUG('[links] navigating to %s', route.url);
  activator.go(route.url, { context: anchor });

  function prevent () { e.preventDefault(); }
}

function prefetch (e, anchor) {
  prefetcher.start(parse(anchor), anchor);
}

module.exports = links;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./activator":35,"./events":42,"./global/document":44,"./prefetcher":54,"./router":55,"./state":56}],51:[function(require,module,exports){
(function (global){
'use strict';

var unescape = require('./unescape');
var state = require('./state');
var router = require('./router');
var activator = require('./activator');
var caching = require('./caching');
var componentCache = require('./componentCache');
var fetcher = require('./fetcher');
var versioning = require('../versioning');
var document = require('./global/document');
var location = require('./global/location');
var resolve = require('../lib/resolve');
var g = global;
var mounted;
var booted;

function orEmpty (value) {
  return value || '';
}

function mount (container, wiring, options) {
  var o = options || {};
  if (mounted) {
    throw new Error('Taunus already mounted!');
  }
  if (!container || !container.tagName) { // nave is enough
    throw new Error('You must define an application root container!');
  }
  if (!o.bootstrap) { o.bootstrap = 'auto'; }

  mounted = true;

  global.DEBUG && global.DEBUG('[mount] mountpoint invoked using "%s" strategy', o.bootstrap);

  state.container = container;
  state.controllers = wiring.controllers;
  state.templates = wiring.templates;
  state.routes = wiring.routes;
  state.deferrals = wiring.deferrals || [];
  state.prefetch = !!o.prefetch;
  state.version = versioning.get(o.version || '1');

  resolve.set(state.routes);
  router.setup(state.routes);

  var url = location.pathname;
  var query = orEmpty(location.search) + orEmpty(location.hash);
  var route = router(url + query);

  caching.setup(o.cache, route);
  caching.ready(kickstart);
  componentCache.refill();

  function kickstart () {
    if (o.bootstrap === 'auto') {
      autoboot();
    } else if (o.bootstrap === 'inline') {
      inlineboot();
    } else if (o.bootstrap === 'manual') {
      manualboot();
    } else {
      throw new Error(o.bootstrap + ' is not a valid bootstrap mode!');
    }
  }

  function autoboot () {
    fetcher(route, { element: container, source: 'boot' }, fetched);
  }

  function fetched (err, data) {
    if (err) {
      throw new Error('Fetching JSON data model failed at mountpoint.');
    }
    boot(data);
  }

  function inlineboot () {
    var id = container.getAttribute('data-taunus');
    var script = document.getElementById(id);
    var data = JSON.parse(unescape(script.innerText || script.textContent));
    boot(data);
  }

  function manualboot () {
    if (typeof g.taunusReady === 'function') {
      g.taunusReady = boot; // not yet an object? turn it into the boot method
    } else if (g.taunusReady && typeof g.taunusReady === 'object') {
      boot(g.taunusReady); // already an object? boot with that as the data object
    } else {
      throw new Error('Did you forget to add the taunusReady global?');
    }
  }

  function boot (data) {
    if (booted) { // sanity
      return;
    }

    global.DEBUG && global.DEBUG('[mount] mountpoint booted with data', data);

    if (!data) {
      throw new Error('Taunus data is required! Boot failed');
    }
    if (!data.version) {
      throw new Error('Version data is missing! Boot failed');
    }
    if (!data.model || typeof data.model !== 'object') {
      throw new Error('Taunus model must be an object! Boot failed');
    }
    booted = true;
    caching.persist(route, state.container, data);
    activator.start(data);
  }
}

module.exports = mount;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lib/resolve":67,"../versioning":81,"./activator":35,"./caching":37,"./componentCache":39,"./fetcher":43,"./global/document":44,"./global/location":46,"./router":55,"./state":56,"./unescape":62}],52:[function(require,module,exports){
'use strict';

// source: https://gist.github.com/jdalton/5e34d890105aca44399f
// thanks @jdalton!

var toString = Object.prototype.toString; // used to resolve the internal `[[Class]]` of values
var fnToString = Function.prototype.toString; // used to resolve the decompiled source of functions
var host = /^\[object .+?Constructor\]$/; // used to detect host constructors (Safari > 4; really typed array specific)

// Escape any special regexp characters.
var specials = /[.*+?^${}()|[\]\/\\]/g;

// Replace mentions of `toString` with `.*?` to keep the template generic.
// Replace thing like `for ...` to support environments, like Rhino, which add extra
// info such as method arity.
var extras = /toString|(function).*?(?=\\\()| for .+?(?=\\\])/g;

// Compile a regexp using a common native method as a template.
// We chose `Object#toString` because there's a good chance it is not being mucked with.
var fnString = String(toString).replace(specials, '\\$&').replace(extras, '$1.*?');
var reNative = new RegExp('^' + fnString + '$');

function nativeFn (value) {
  var type = typeof value;
  if (type === 'function') {
    // Use `Function#toString` to bypass the value's own `toString` method
    // and avoid being faked out.
    return reNative.test(fnToString.call(value));
  }

  // Fallback to a host object check because some environments will represent
  // things like typed arrays as DOM methods which may not conform to the
  // normal native pattern.
  return (value && type === 'object' && host.test(toString.call(value))) || false;
}

module.exports = nativeFn;

},{}],53:[function(require,module,exports){
'use strict';

module.exports = function disposable (fn) {
  var used;
  var result;
  return function once () {
    if (used) { return result; } used = true;
    return (result = fn.apply(this, arguments));
  };
};

},{}],54:[function(require,module,exports){
(function (global){
'use strict';

var state = require('./state');
var router = require('./router');
var fetcher = require('./fetcher');
var activator = require('./activator');
var jobs = [];
var intent;

function busy (url) {
  return jobs.indexOf(url) !== -1;
}

function registerIntent (url) {
  intent = url;
}

function abortIntent (url) {
  intent = null;
}

function start (url, element) {
  if (state.cache !== true) { // can't prefetch if caching is disabled
    return;
  }
  if (intent) { // don't prefetch if the human wants to navigate: it'd abort the previous attempt
    return;
  }
  var route = router(url);
  if (route === null) { // only prefetch taunus view routes
    return;
  }
  if (busy(url)) { // already prefetching this url
    return;
  }

  global.DEBUG && global.DEBUG('[prefetcher] prefetching %s', route.url);
  jobs.push(url);
  fetcher(route, { element: element, source: 'prefetch' }, fetched);

  function fetched () {
    jobs.splice(jobs.indexOf(url), 1);
    if (intent === url) {
      intent = null;

      global.DEBUG && global.DEBUG('[prefetcher] resumed navigation for %s', route.url);
      activator.go(route.url, { context: element });
    }
  }
}

module.exports = {
  busy: busy,
  start: start,
  registerIntent: registerIntent,
  abortIntent: abortIntent
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./activator":35,"./fetcher":43,"./router":55,"./state":56}],55:[function(require,module,exports){
(function (global){
'use strict';

var url = require('fast-url-parser');
var ruta3 = require('ruta3');
var location = require('./global/location');
var matcher = ruta3();
var protocol = /^[a-z]+?:\/\//i;

function getFullUrl (raw) {
  var base = location.href.substr(location.origin.length);
  var hashless;
  if (!raw) {
    return base;
  }
  if (raw[0] === '#') {
    hashless = base.substr(0, base.length - location.hash.length);
    return hashless + raw;
  }
  if (protocol.test(raw)) {
    if (raw.indexOf(location.origin) === 0) {
      return raw.substr(location.origin.length);
    }
    return null;
  }
  return raw;
}

function router (raw, startIndex) {
  var full = getFullUrl(raw);
  if (full === null) {
    return null;
  }
  var parts = url.parse(full, true);
  var info = matcher.match(parts.pathname, startIndex);

  global.DEBUG && global.DEBUG('[router] %s produces %o', raw, info);

  var route = info ? merge(info) : null;
  if (route === null || route.ignore) {
    return null;
  }

  route.url = full;
  route.parts = parts;

  global.DEBUG && global.DEBUG('[router] %s yields %s', raw, route.route);

  return route;
}

function merge (info) {
  var route = Object.keys(info.action).reduce(copyOver, {
    params: info.params
  });
  info.params.args = info.splats;

  return route;

  function copyOver (route, key) {
    route[key] = info.action[key]; return route;
  }
}

function setup (definitions) {
  definitions.forEach(define);
}

function define (definition) {
  if (typeof definition.action !== 'string') {
    definition.action = null;
  }
  matcher.addRoute(definition.route, definition);
}

function equals (left, right) {
  return (
    left && right &&
    left.route === right.route &&
    JSON.stringify(left.params) === JSON.stringify(right.params)
  );
}

router.setup = setup;
router.equals = equals;

module.exports = router;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./global/location":46,"fast-url-parser":70,"ruta3":71}],56:[function(require,module,exports){
'use strict';

module.exports = {
  container: null
};

},{}],57:[function(require,module,exports){
'use strict';

var state = require('./state');
var raw = require('./stores/raw');
var idb = require('./stores/idb');

function clear () {
  raw.clear();
  idb.clear('models');
  idb.clear('controllers');
  idb.clear('templates');
  clearStore('controllers');
  clearStore('templates');
}

function clearStore (type) {
  var store = state[type];
  Object.keys(store).filter(o).forEach(rm);

  function o (action) {
    return store[action] && typeof store[action] === 'object';
  }
  function rm (action) {
    delete store[action];
  }
}


module.exports = clear;

},{"./state":56,"./stores/idb":58,"./stores/raw":59}],58:[function(require,module,exports){
(function (global){
'use strict';

var api = {};
var idb = require('./underlying_idb');
var supports;
var db;
var dbVersion = 3;
var dbName = 'taunus';
var keyPath = 'key';
var setQueue = [];
var testedQueue = [];

function noop () {}

function test () {
  var key = 'indexed-db-feature-detection';
  var req;
  var db;

  if (!idb || !('deleteDatabase' in idb)) {
    support(false); return;
  }

  try {
    idb.deleteDatabase(key).onsuccess = transactionalTest;
  } catch (e) {
    support(false);
  }

  function transactionalTest () {
    req = idb.open(key, 1);
    req.onupgradeneeded = upgneeded;
    req.onerror = error;
    req.onsuccess = success;

    function upgneeded () {
      req.result.createObjectStore('store');
    }

    function success () {
      db = req.result;
      try {
        db.transaction('store', 'readwrite').objectStore('store').add(new global.Blob(), 'key');
      } catch (e) {
        support(false);
      } finally {
        db.close();
        idb.deleteDatabase(key);
        if (supports !== false) {
          open();
        }
      }
    }

    function error () {
      support(false);
    }
  }
}

function open () {
  var req = idb.open(dbName, dbVersion);
  req.onerror = error;
  req.onupgradeneeded = upgneeded;
  req.onsuccess = success;

  function upgneeded (e) {
    var db = req.result;
    var v = e.oldVersion;
    if (v === 1) {
      db.deleteObjectStore('wildstore');
    }
    if (v < 2) {
      db.createObjectStore('models', { keyPath: keyPath });
      db.createObjectStore('templates', { keyPath: keyPath });
      db.createObjectStore('controllers', { keyPath: keyPath });
    }
  }

  function success () {
    db = req.result;
    api.name = 'IndexedDB';
    api.get = get;
    api.set = set;
    api.clear = clear;
    support(true);
  }

  function error () {
    support(false);
  }
}

function fallback () {
  api.name = 'IndexedDB-fallbackStore';
  api.get = undefinedGet;
  api.set = enqueueSet;
  api.clear = noop;
}

function undefinedGet (store, key, done) {
  (done || key)(null, done ? null : []);
}

function enqueueSet (store, key,  value, done) {
  if (supports === false) {
    done(null); return;
  }
  if (setQueue.length > 10) { // let's not waste any more memory
    done(new Error('EFULLQUEUE')); return;
  }
  setQueue.push({ store: store, key: key, value: value, done: done });
}

function drainSet () {
  if (supports === false) {
    setQueue = [];
    return;
  }
  global.DEBUG && global.DEBUG('[idb] draining setQueue (%s items)', setQueue.length);
  while (setQueue.length) {
    var item = setQueue.shift();
    set(item.store, item.key, item.value, item.done);
  }
}

function query (op, store, value, done) {
  var req = db.transaction(store, 'readwrite').objectStore(store)[op](value);

  req.onsuccess = success;
  req.onerror = error;

  function success () {
    (done || noop)(null, req.result);
  }

  function error () {
    (done || noop)(new Error('Taunus cache query failed at IndexedDB!'));
  }
}

function all (store, done) {
  var tx = db.transaction(store, 'readonly');
  var s = tx.objectStore(store);
  var req = s.openCursor();
  var items = [];

  req.onsuccess = success;
  req.onerror = error;
  tx.oncomplete = complete;

  function complete () {
    (done || noop)(null, items);
  }

  function success (e) {
    var cursor = e.target.result;
    if (cursor) {
      items.push(cursor.value);
      cursor.continue();
    }
  }

  function error () {
    (done || noop)(new Error('Taunus cache query-all failed at IndexedDB!'));
  }
}

function clear (store, done) {
  var tx = db.transaction(store, 'readwrite');
  var s = tx.objectStore(store);
  var req = s.clear();
  var items = [];

  req.onerror = error;
  tx.oncomplete = complete;

  function complete () {
    (done || noop)(null, items);
  }

  function error () {
    (done || noop)(new Error('Taunus cache clear failed at IndexedDB!'));
  }
}

function get (store, key, done) {
  if (done === void 0) {
    all(store, key);
  } else {
    query('get', store, key, done);
  }
}

function set (store, key, value, done) {
  global.DEBUG && global.DEBUG('[idb] storing %s, in %s db', key, store, value);
  value[keyPath] = key;
  query('add', store, value, done); // attempt to insert
  query('put', store, value, done); // attempt to update
}

function drainTested () {
  while (testedQueue.length) {
    testedQueue.shift()(supports);
  }
}

function tested (fn) {
  if (supports !== void 0) {
    fn(supports);
  } else {
    testedQueue.push(fn);
  }
}

function support (value) {
  if (supports !== void 0) {
    return; // sanity
  }
  global.DEBUG && global.DEBUG('[idb] test result %s, db %s', value, value ? 'ready' : 'unavailable');
  supports = value;
  drainTested();
  drainSet();
}

function failed () {
  support(false);
}

fallback();
test();
setTimeout(failed, 600); // the test can take somewhere near 300ms to complete

module.exports = api;

api.tested = tested;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./underlying_idb":60}],59:[function(require,module,exports){
'use strict';

var raw = {};

function noop () {}

function ensure (store) {
  if (!raw[store]) { raw[store] = {}; }
}

function get (store, key, done) {
  ensure(store);
  done(null, raw[store][key]);
}

function set (store, key, value, done) {
  ensure(store);
  raw[store][key] = value;
  (done || noop)(null);
}

function clear () {
  raw = {};
}

module.exports = {
  name: 'memoryStore',
  get: get,
  set: set,
  clear: clear
};

},{}],60:[function(require,module,exports){
(function (global){
'use strict';

var g = global;

// fallback to empty object because tests
module.exports = g.indexedDB || g.mozIndexedDB || g.webkitIndexedDB || g.msIndexedDB || {};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],61:[function(require,module,exports){
'use strict';

var resolve = require('../lib/resolve');

module.exports = {
  resolve: resolve
};

},{"../lib/resolve":67}],62:[function(require,module,exports){
'use strict';

var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g;
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': '\'',
  '&#96;': '`'
};

function unescapeHtmlChar (c) {
  return htmlUnescapes[c];
}

function unescape (input) {
  var data = input == null ? '' : String(input);
  if (data && (reEscapedHtml.lastIndex = 0, reEscapedHtml.test(data))) {
    return data.replace(reEscapedHtml, unescapeHtmlChar);
  }
  return data;
}

module.exports = unescape;

},{}],63:[function(require,module,exports){
/* jshint strict:false */
// this module doesn't use strict, so eval is unstrict.

module.exports = function (code) {
  /* jshint evil:true */
  return eval(code);
};

},{}],64:[function(require,module,exports){
(function (global){
'use strict';

var state = require('./state');
var emitter = require('./emitter');
var fetcher = require('./fetcher');
var deferral = require('./deferral');
var templatingAPI = require('./templatingAPI');

function view (container, enforcedAction, model, route, options) {
  var action = enforcedAction || model && model.action || route && route.action;
  var demands = deferral.needs(action);

  global.DEBUG && global.DEBUG('[view] rendering view %s with [%s] demands', action, demands.join(','));

  if (demands.length) {
    pull();
  } else {
    ready();
  }

  function pull () {
    var victim = route || state.route;
    var context = {
      source: 'hijacking',
      hijacker: action,
      element: container
    };
    global.DEBUG && global.DEBUG('[view] hijacking %s for action %s', victim.url, action);
    fetcher(victim, context, ready);
  }

  function ready () {
    var controller = getComponent('controllers', action);
    var internals = options || {};
    if (internals.render !== false) {
      container.innerHTML = render(action, model);
    } else {
      global.DEBUG && global.DEBUG('[view] not rendering %s', action);
    }
    if (container === state.container) {
      emitter.emit('change', route, model);
    }
    emitter.emit('render', container, model, route || null);
    global.DEBUG && global.DEBUG('[view] %s client-side controller for %s', controller ? 'executing' : 'no', action);
    if (controller) {
      controller(model, container, route || null);
    }
  }
}

function render (action, model) {
  global.DEBUG && global.DEBUG('[view] rendering %s with model', action, model);
  var template = getComponent('templates', action);
  if (typeof template !== 'function') {
    throw new Error('Client-side "' + action + '" template not found');
  }
  model.taunus = templatingAPI;
  try {
    return template(model);
  } catch (e) {
    throw new Error('Error rendering "' + action + '" view template\n' + e.stack);
  }
}

function getComponent (type, action) {
  var component = state[type][action];
  var transport = typeof component;
  if (transport === 'object' && component) {
    return component.fn; // deferreds are stored as {fn,version}
  }
  if (transport === 'function') {
    return component;
  }
}

function partial (container, action, model) {
  global.DEBUG && global.DEBUG('[view] rendering partial %s', action);
  return view(container, action, model, null, { partial: true });
}

view.partial = partial;

module.exports = view;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./deferral":40,"./emitter":41,"./fetcher":43,"./state":56,"./templatingAPI":61}],65:[function(require,module,exports){
(function (global){
'use strict';

var xhr = require('xhr');

function request (url, o, done) {
  var options = {
    url: url,
    json: true,
    headers: { Accept: 'application/json' }
  };
  if (done) {
    Object.keys(o).forEach(overwrite);
  } else {
    done = o;
  }

  global.DEBUG && global.DEBUG('[xhr] %s %s', options.method || 'GET', options.url);

  var req = xhr(options, handle);

  return req;

  function overwrite (prop) {
    options[prop] = o[prop];
  }

  function handle (err, res, body) {
    if (err && !req.getAllResponseHeaders()) {
      global.DEBUG && global.DEBUG('[xhr] %s %s aborted', options.method || 'GET', options.url);
      done(new Error('aborted'), null, res);
    } else {
      global.DEBUG && global.DEBUG('[xhr] %s %s done', options.method || 'GET', options.url);
      done(err, body, res);
    }
  }
}

module.exports = request;

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"xhr":73}],66:[function(require,module,exports){
'use strict';

module.exports = function deferred (action, rules) {
  return rules.some(failed);
  function failed (challenge) {
    var left = challenge.split('/');
    var right = action.split('/');
    var lpart, rpart;
    while (left.length) {
      lpart = left.shift();
      rpart = right.shift();
      if (lpart !== '?' && lpart !== rpart) {
        return false;
      }
    }
    return true;
  }
};

},{}],67:[function(require,module,exports){
'use strict';

/*
 * # a named parameter in the ':name' format
 * :([a-z]+)
 *
 * # matches a regexp that constraints the possible values for this parameter
 * # e.g ':name([a-z+])'
 * (?:\((?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\))?
 *
 * # the parameter may be optional, e.g ':name?'
 * (\?)?
 *
 * - i: routes are typically lower-case but they may be mixed case as well
 * - g: routes may have zero or more named parameters
 *
 * regexper: http://regexper.com/#%2F%3A(%5Ba-z%5D%2B)(%3F%3A%5C((%3F!%5B*%2B%3F%5D)(%3F%3A%5B%5E%5Cr%5Cn%5C%5B%2F%5C%5C%5D%7C%5C%5C.%7C%5C%5B(%3F%3A%5B%5E%5Cr%5Cn%5C%5D%5C%5C%5D%7C%5C%5C.)*%5C%5D)%2B%5C))%3F(%5C%3F)%3F%2Fig
 */

var defaultMatcher = /:([a-z]+)(?:\((?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\))?(\?)?/ig;
var routes;
var matcher;

function find (action) {
  var i;
  for (i = 0; i < routes.length; i++) {
    if (routes[i].action === action) {
      return routes[i].route;
    }
  }
  return null;
}

function use (m) {
  matcher = m || defaultMatcher;
}

function set (r) {
  routes = r || [];
}

function resolve (action, data) {
  var props = data || {};
  var route = find(action);
  if (route === null) {
    return null;
  }
  return route.replace(matcher, replacer) + queryString(props.args);

  function replacer (match, key, optional) {
    var value = props[key];
    if (value !== void 0 && value !== null) {
      return props[key];
    }
    if (key in props || optional) {
      return '';
    }
    throw new Error('Route ' + route + ' expected "' + key + '" parameter.');
  }

  function queryString (args) {
    var parts = args || {};
    var query = Object.keys(parts).map(keyValuePair).join('&');
    if (query) {
      return '?' + query;
    }
    return '';

    function keyValuePair (prop) {
      var value = parts[prop];
      if (value === void 0 || value === null || value === '') {
        return prop;
      }
      return prop + '=' + value;
    }
  }
}

use();
set();

resolve.use = use;
resolve.set = set;

module.exports = resolve;

},{}],68:[function(require,module,exports){
module.exports = require('./src/contra.emitter.js');

},{"./src/contra.emitter.js":69}],69:[function(require,module,exports){
(function (process){
(function (root, undefined) {
  'use strict';

  var undef = '' + undefined;
  function atoa (a, n) { return Array.prototype.slice.call(a, n); }
  function debounce (fn, args, ctx) { if (!fn) { return; } tick(function run () { fn.apply(ctx || null, args || []); }); }

  // cross-platform ticker
  var si = typeof setImmediate === 'function', tick;
  if (si) {
    tick = function (fn) { setImmediate(fn); };
  } else if (typeof process !== undef && process.nextTick) {
    tick = process.nextTick;
  } else {
    tick = function (fn) { setTimeout(fn, 0); };
  }

  function _emitter (thing, options) {
    var opts = options || {};
    var evt = {};
    if (thing === undefined) { thing = {}; }
    thing.on = function (type, fn) {
      if (!evt[type]) {
        evt[type] = [fn];
      } else {
        evt[type].push(fn);
      }
      return thing;
    };
    thing.once = function (type, fn) {
      fn._once = true; // thing.off(fn) still works!
      thing.on(type, fn);
      return thing;
    };
    thing.off = function (type, fn) {
      var c = arguments.length;
      if (c === 1) {
        delete evt[type];
      } else if (c === 0) {
        evt = {};
      } else {
        var et = evt[type];
        if (!et) { return thing; }
        et.splice(et.indexOf(fn), 1);
      }
      return thing;
    };
    thing.emit = function () {
      var ctx = this;
      var args = atoa(arguments);
      var type = args.shift();
      var et = evt[type];
      if (type === 'error' && opts.throws !== false && !et) { throw args.length === 1 ? args[0] : args; }
      if (!et) { return thing; }
      evt[type] = et.filter(function emitter (listen) {
        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }
        return !listen._once;
      });
      return thing;
    };
    return thing;
  }

  // cross-platform export
  if (typeof module !== undef && module.exports) {
    module.exports = _emitter;
  } else {
    root.contra = root.contra || {};
    root.contra.emitter = _emitter;
  }
})(this);

}).call(this,require("/Users/nico/.nvm/v0.10.26/lib/node_modules/watchify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/nico/.nvm/v0.10.26/lib/node_modules/watchify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":1}],70:[function(require,module,exports){
"use strict";
/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;

    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;

    this._prependSlash = false;
}

var querystring = require("querystring");
Url.prototype.parse =
function Url$parse(str, parseQueryString, hostDenotesSlash) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " +
            typeof str);
    }
    var start = 0;
    var end = str.length - 1;

    //Trim leading and trailing ws
    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

    start = this._parseProtocol(str, start, end);

    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname &&
            (this.slashes || (proto && !slashProtocols[proto]))) {
            this.hostname = this.host = "";
        }
    }

    if (start <= end) {
        var ch = str.charCodeAt(start);

        if (ch === 0x2F /*'/'*/) {
            this._parsePath(str, start, end);
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, start, end);
        }
        else if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, start, end);
        }
        else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end);
        }
        else { //For javascript the pathname is just the rest of it
            this.pathname = str.slice(start, end + 1 );
        }

    }

    if (!this.pathname && this.hostname &&
        this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }

    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = querystring.parse(search);
    }
};

Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};

Url.prototype.format = function Url$format() {
    var auth = this.auth || "";

    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }

    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";

    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = querystring.stringify(q);
    }

    if (!search) {
        search = query ? "?" + query : "";
    }

    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)
        protocol += ":";

    if (this.host) {
        host = auth + this.host;
    }
    else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }

    var slashes = this.slashes ||
        ((!protocol ||
        slashProtocols[protocol]) && host !== false);


    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";

    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
        pathname = "/" + pathname;
    }
    else if (!slashes && pathname === "/") {
        pathname = "";
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)
        search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)
        hash = "#" + hash;

    pathname = escapePathName(pathname);
    search = escapeSearch(search);

    return scheme + (host === false ? "" : host) + pathname + search + hash;
};

Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
        relative = Url.parse(relative, false, true);

    var result = this._clone();

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);

        if (slashProtocols[result._protocol] &&
            result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }

    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }

        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }

    var isSourceAbs =
        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);
    var isRelAbs = (
            relative.host ||
            (relative.pathname &&
            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)
        );
    var mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname));

    var removeAllDots = mustEndAbs;

    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }

    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ?
            relative.host : result.host;
        result.hostname = relative.hostname ?
            relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ?
                result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host) && (last === "." || last === "..") ||
        last === "");

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last == ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift("..");
        }
    }

    if (mustEndAbs && srcPath[0] !== "" &&
        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
        srcPath.unshift("");
    }

    if (hasTrailingSlash && (srcPath.join("/").substr(-1) !== "/")) {
        srcPath.push("");
    }

    var isAbsolute = srcPath[0] === "" ||
        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" :
            srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ?
            result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }

    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};

var punycode = require("punycode");
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = hostname.split(".");
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            "xn--" + punycode.encode(s) : s);
    }
    return newOut.join(".");
};

var escapePathName = Url.prototype._escapePathName =
function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};

var escapeSearch = Url.prototype._escapeSearch =
function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};

Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        }
        else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/)
                doLowerCase = true;
        }
        else {
            return start;
        }

    }
    return start;
};

Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};

Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
            port = (10 * port) + (ch - 0x30 /*'0'*/);
            hadChars = true;
        }
        else break;

    }
    if (port === 0 && !hadChars) {
        return 0;
    }

    this._port = port;
    return i - start;
};

Url.prototype._parseHost =
function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    if (str.charCodeAt(start) === 0x2F /*'/'*/ &&
        str.charCodeAt(start + 1) === 0x2F /*'/'*/) {
        this.slashes = true;

        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth =
                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    }
    //If there is no slashes, there is no hostname if
    //1. there was no protocol at all
    else if (!this._protocol ||
        //2. there was a protocol that requires slashes
        //e.g. in 'http:asd' 'asd' is not a hostname
        slashProtocols[this._protocol]
    ) {
        return start;
    }

    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;

    var j = -1;

    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x40 /*'@'*/) {
            j = i;
        }
        //This check is very, very cheap. Unneeded decodeURIComponent is very
        //very expensive
        else if (ch === 0x25 /*'%'*/) {
            authNeedsDecoding = true;
        }
        else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }

    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }

    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/) {
        for (var i = start + 1; i <= end; ++i) {
            var ch = str.charCodeAt(i);

            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0
                    ? "[" + hostname + "]:" + this._port
                    : "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }

    for (var i = start; i <= end; ++i) {
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        }
        else if (ch < 0x61 /*'a'*/) {
            if (ch === 0x2E /*'.'*/) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */
                charsAfterDot = -1;
            }
            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                doLowerCase = true;
            }
            else if (!(ch === 0x2D /*'-'*/ || ch === 0x5F /*'_'*/ ||
                (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))) {
                if (hostEndingCharacters[ch] === 0 &&
                    this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        }
        else if (ch >= 0x7B /*'{'*/) {
            if (ch <= 0x7E /*'~'*/) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }

    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */

    if (hostNameEnd + 1 !== start &&
        hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }

    return hostNameEnd + 1 + portLength;

};

Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};

Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};

Url.prototype._getComponentEscaped =
function Url$_getComponentEscaped(str, start, end) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = this._autoEscapeMap;
    for (; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];

        if (escaped !== "") {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};

Url.prototype._parsePath =
function Url$_parsePath(str, start, end) {
    var pathStart = start;
    var pathEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end);
            pathEnd = i - 1;
            break;
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, i, end);
            pathEnd = i - 1;
            break;
        }
        else if (!escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (pathStart > pathEnd) {
        this.pathname = "/";
        return;
    }

    var path;
    if (escape) {
        path = this._getComponentEscaped(str, pathStart, pathEnd);
    }
    else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = this._prependSlash ? "/" + path : path;
};

Url.prototype._parseQuery = function Url$_parseQuery(str, start, end) {
    var queryStart = start;
    var queryEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end);
            queryEnd = i - 1;
            break;
        }
        else if (!escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }

    var query;
    if (escape) {
        query = this._getComponentEscaped(str, queryStart, queryEnd);
    }
    else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};

Url.prototype._parseHash = function Url$_parseHash(str, start, end) {
    if (start > end) {
        this.hash = "";
        return;
    }
    this.hash = this._getComponentEscaped(str, start, end);
};

Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return ("" + this._port);
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        }
        else {
            this._port = parseInt(v, 10);
        }
    }
});

Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;

        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});

Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return (p == null && s) ? ("/" + s) : null;
    },
    set: function() {}
});

Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/) {
                this._protocol = v.slice(0, end);
            }
            else {
                this._protocol = v;
            }
        }
        else if (v == null) {
            this._protocol = null;
        }
    }
});

Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});

Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash);
    return ret;
};

Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};

Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};

Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};

function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}

function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}

//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for (var i = fromIndex; i < len; ++i) {
        var ch = string.charCodeAt(i);

        if (ch === char1) {
            return true;
        }
        else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}

//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for (var i = 0, len = string.length; i < len; ++i) {
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}

//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]

//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item){
        if (typeof item === "number") {
            ret[item] = 1;
        }
        else {
            var start = item[0];
            var end = item[1];
            for (var j = start; j <= end; ++j) {
                ret[j] = 1;
            }
        }
    });

    return ret;
}


var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"];

var autoEscapeMap = new Array(128);



for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
    autoEscapeMap[i] = "";
}

for (var i = 0, len = autoEscape.length; i < len; ++i) {
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}


var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,

    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};

//Optimize back from normalized object caused by non-identifier keys
function f(){}
f.prototype = slashProtocols;

Url.prototype._protocolCharacters = makeAsciiTable([
    [0x61 /*'a'*/, 0x7A /*'z'*/],
    [0x41 /*'A'*/, 0x5A /*'Z'*/],
    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
]);

Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/
]);

Url.prototype._autoEscapeCharacters = makeAsciiTable(
    autoEscape.map(function(v) {
        return v.charCodeAt(0);
    })
);

//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
    [
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|", "\\",
        "^", "`", "\"", "%", ";"
    ].map(function(v) {
        return v.charCodeAt(0);
    })
);

Url.prototype._autoEscapeMap = autoEscapeMap;

module.exports = Url;

Url.replace = function Url$Replace() {
    require.cache["url"] = {
        exports: Url
    };
};

},{"punycode":2,"querystring":5}],71:[function(require,module,exports){
'use strict';

var pathToRegExp = require('./pathToRegExp');

function match (routes, uri, startAt) {
  var captures;
  var i = startAt || 0;

  for (var len = routes.length; i < len; ++i) {
    var route = routes[i];
    var re = route.re;
    var keys = route.keys;
    var splats = [];
    var params = {};

    if (captures = uri.match(re)) {
      for (var j = 1, len = captures.length; j < len; ++j) {
        var value = typeof captures[j] === 'string' ? unescape(captures[j]) : captures[j];
        var key = keys[j - 1];
        if (key) {
          params[key] = value;
        } else {
          splats.push(value);
        }
      }

      return {
        params: params,
        splats: splats,
        route: route.src,
        next: i + 1,
        index: route.index
      };
    }
  }
}

function routeInfo (path, index) {
  var src;
  var re;
  var keys = [];

  if (path instanceof RegExp) {
    re = path;
    src = path.toString();
  } else {
    re = pathToRegExp(path, keys);
    src = path;
  }

  return {
     re: re,
     src: path.toString(),
     keys: keys,
     index: index
  };
}

function Router () {
  if (!(this instanceof Router)) {
    return new Router();
  }

  this.routes = [];
  this.routeMap = [];
}

Router.prototype.addRoute = function (path, action) {
  if (!path) {
    throw new Error(' route requires a path');
  }
  if (!action) {
    throw new Error(' route ' + path.toString() + ' requires an action');
  }

  var route = routeInfo(path, this.routeMap.length);
  route.action = action;
  this.routes.push(route);
  this.routeMap.push([path, action]);
}

Router.prototype.match = function (uri, startAt) {
  var route = match(this.routes, uri, startAt);
  if (route) {
    route.action = this.routeMap[route.index][1];
    route.next = this.match.bind(this, uri, route.next);
  }
  return route;
}

module.exports = Router;

},{"./pathToRegExp":72}],72:[function(require,module,exports){
'use strict';

function pathToRegExp (path, keys) {
  path = path
    .concat('/?')
    .replace(/\/\(/g, '(?:/')
    .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?|\*/g, tweak)
    .replace(/([\/.])/g, '\\$1')
    .replace(/\*/g, '(.*)');

  return new RegExp('^' + path + '$', 'i');

  function tweak (match, slash, format, key, capture, optional) {
    if (match === '*') {
      keys.push(void 0);
      return match;
    }

    keys.push(key);

    slash = slash || '';

    return ''
      + (optional ? '' : slash)
      + '(?:'
      + (optional ? slash : '')
      + (format || '')
      + (capture ? capture.replace(/\*/g, '{0,}').replace(/\./g, '[\\s\\S]') : '([^/]+?)')
      + ')'
      + (optional || '');
  }
}

module.exports = pathToRegExp;

},{}],73:[function(require,module,exports){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status, body) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        }

        return error
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode()
        var body = getBody()
        var error = errorFromStatusCode(status, body)
        var response = {
            body: body,
            statusCode: status,
            statusText: xhr.statusText,
            raw: xhr
        }
        if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
            response.headers = parseHeaders(xhr.getAllResponseHeaders())
        } else {
            response.headers = {}
        }

        callback(error, response, response.body)
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status
        xhr.body = getBody()
        xhr.headers = parseHeaders(xhr.getAllResponseHeaders())

        callback(error, xhr, xhr.body)
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

},{"global/window":74,"once":75,"parse-headers":79}],74:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],75:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],76:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":77}],77:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],78:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],79:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":76,"trim":78}],80:[function(require,module,exports){
module.exports="4.0.0"

},{}],81:[function(require,module,exports){
'use strict';

var t = require('./version.json');

function get (v) {
  return 't' + t + ';v' + v;
}

module.exports = {
  get: get
};

},{"./version.json":80}]},{},[16])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvbmljby8ubnZtL3YwLjEwLjI2L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9uaWNvLy5udm0vdjAuMTAuMjYvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbmljby8ubnZtL3YwLjEwLjI2L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwiL1VzZXJzL25pY28vLm52bS92MC4xMC4yNi9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwiL1VzZXJzL25pY28vLm52bS92MC4xMC4yNi9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwiL1VzZXJzL25pY28vLm52bS92MC4xMC4yNi9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvLy5iaW4vdmlld3MvZG9jdW1lbnRhdGlvbi9hYm91dC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vLmJpbi92aWV3cy9kb2N1bWVudGF0aW9uL2FwaS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vLmJpbi92aWV3cy9kb2N1bWVudGF0aW9uL2NvbXBsZW1lbnRzLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby8uYmluL3ZpZXdzL2RvY3VtZW50YXRpb24vZ2V0dGluZy1zdGFydGVkLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby8uYmluL3ZpZXdzL2RvY3VtZW50YXRpb24vcGVyZm9ybWFuY2UuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvLy5iaW4vdmlld3MvZXJyb3Ivbm90LWZvdW5kLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby8uYmluL3ZpZXdzL2xheW91dC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vLmJpbi93aXJpbmcuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL2NsaWVudC9qcy9jb250cm9sbGVycy9kb2N1bWVudGF0aW9uL2Fib3V0LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9jbGllbnQvanMvY29udmVudGlvbnMuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL2NsaWVudC9qcy9tYWluLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9jbGllbnQvanMvdGhyb3R0bGUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9kb21pbnVzL25vZGVfbW9kdWxlcy9wb3Nlci9pbmRleC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2RvbWludXMvbm9kZV9tb2R1bGVzL3Bvc2VyL3NyYy9icm93c2VyLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvZG9taW51cy9ub2RlX21vZHVsZXMvc2VrdG9yL3NyYy9zZWt0b3IuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9kb21pbnVzL3NyYy9Eb21pbnVzLmN0b3IuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9kb21pbnVzL3NyYy9Eb21pbnVzLnByb3RvdHlwZS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2RvbWludXMvc3JjL2NsYXNzZXMuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9kb21pbnVzL3NyYy9jb3JlLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvZG9taW51cy9zcmMvZG9tLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvZG9taW51cy9zcmMvZG9taW51cy5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2RvbWludXMvc3JjL2V2ZW50cy5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2RvbWludXMvc3JjL3B1YmxpYy5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2RvbWludXMvc3JjL3Rlc3QuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9kb21pbnVzL3NyYy90ZXh0LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvamFkdW0vbm9kZV9tb2R1bGVzL2phZGUvcnVudGltZS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL2phZHVtL3J1bnRpbWUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy9yYWYvbm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvYWN0aXZhdG9yLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvY2FjaGUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9jYWNoaW5nLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvY2xvbmUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9jb21wb25lbnRDYWNoZS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2RlZmVycmFsLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvZW1pdHRlci5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2V2ZW50cy5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2ZldGNoZXIuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9nbG9iYWwvZG9jdW1lbnQuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9nbG9iYWwvaGlzdG9yeS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2dsb2JhbC9sb2NhdGlvbi5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2hvb2tzLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvaW5kZXguanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9pbnRlcmNlcHRvci5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL2xpbmtzLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvbW91bnQuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9uYXRpdmVGbi5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL29uY2UuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9wcmVmZXRjaGVyLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvcm91dGVyLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvc3RhdGUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9zdGF0ZUNsZWFyLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvc3RvcmVzL2lkYi5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9icm93c2VyL3N0b3Jlcy9yYXcuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci9zdG9yZXMvdW5kZXJseWluZ19pZGIuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci90ZW1wbGF0aW5nQVBJLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIvdW5lc2NhcGUuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci91bnN0cmljdEV2YWwuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvYnJvd3Nlci92aWV3LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2Jyb3dzZXIveGhyLmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL2xpYi9kZWZlcnJlZC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9saWIvcmVzb2x2ZS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMvY29udHJhLmVtaXR0ZXIvaW5kZXguanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvbm9kZV9tb2R1bGVzL2NvbnRyYS5lbWl0dGVyL3NyYy9jb250cmEuZW1pdHRlci5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMvZmFzdC11cmwtcGFyc2VyL3NyYy91cmxwYXJzZXIuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvbm9kZV9tb2R1bGVzL3J1dGEzL2luZGV4LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL25vZGVfbW9kdWxlcy9ydXRhMy9wYXRoVG9SZWdFeHAuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcyIsIi9Vc2Vycy9uaWNvL2Rldi90YXVudXMuYmV2YWNxdWEuaW8vbm9kZV9tb2R1bGVzL3RhdW51cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCIvVXNlcnMvbmljby9kZXYvdGF1bnVzLmJldmFjcXVhLmlvL25vZGVfbW9kdWxlcy90YXVudXMvdmVyc2lvbi5qc29uIiwiL1VzZXJzL25pY28vZGV2L3RhdW51cy5iZXZhY3F1YS5pby9ub2RlX21vZHVsZXMvdGF1bnVzL3ZlcnNpb25pbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjIuNCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teIC1+XS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9cXHgyRXxcXHUzMDAyfFxcdUZGMEV8XFx1RkY2MS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdGFycmF5W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHRyZXR1cm4gbWFwKHN0cmluZy5zcGxpdChyZWdleFNlcGFyYXRvcnMpLCBmbikuam9pbignLicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIHRvIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHlcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFVuaWNvZGUuIE9ubHkgdGhlXG5cdCAqIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB0b1xuXHQgKiBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgUHVueWNvZGUgZG9tYWluIG5hbWUgdG8gY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBQdW55Y29kZS4gT25seSB0aGVcblx0ICogbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgdG8gY29udmVydCwgYXMgYSBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjIuNCcsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJqYWR1bS9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhYm91dChsb2NhbHMpIHtcbnZhciBqYWRlX2RlYnVnID0gW3sgbGluZW5vOiAxLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2Fib3V0LmphZGVcIiB9XTtcbnRyeSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMCwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9hYm91dC5qYWRlXCIgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vYWJvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8c2VjdGlvbiBjbGFzcz1cXFwibHktc2VjdGlvbiBtZC1tYXJrZG93blxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2Fib3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGgxIGlkPVxcXCJ3aHktdGF1bnVzLVxcXCI+V2h5IFRhdW51cz88L2gxPlxcbjxwPlRhdW51cyBmb2N1c2VzIG9uIGRlbGl2ZXJpbmcgYSBwcm9ncmVzc2l2ZWx5IGVuaGFuY2VkIGV4cGVyaWVuY2UgdG8gdGhlIGVuZC11c2VyLCB3aGlsZSBwcm92aWRpbmcgPGVtPmEgcmVhc29uYWJsZSBkZXZlbG9wbWVudCBleHBlcmllbmNlPC9lbT4gYXMgd2VsbC4gPHN0cm9uZz5UYXVudXMgcHJpb3JpdGl6ZXMgY29udGVudDwvc3Ryb25nPi4gSXQgdXNlcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgdG8gZ2V0IGNvbnRlbnQgdG8geW91ciBodW1hbnMgYXMgZmFzdCBhcyBwb3NzaWJsZSwgYW5kIGl0IHVzZXMgY2xpZW50LXNpZGUgcmVuZGVyaW5nIHRvIGltcHJvdmUgdGhlaXIgZXhwZXJpZW5jZS48L3A+XFxuPHA+V2hpbGUgaXQgZm9jdXNlcyBvbiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCwgPHN0cm9uZz48YSBocmVmPVxcXCJodHRwOi8vcG9ueWZvby5jb20vYXJ0aWNsZXMvYWRqdXN0aW5nLXV4LWZvci1odW1hbnNcXFwiPnVzYWJpbGl0eTwvYT4gYW5kIHBlcmZvcm1hbmNlIGFyZSBib3RoIGNvcmUgY29uY2VybnM8L3N0cm9uZz4gZm9yIFRhdW51cy4gSW5jaWRlbnRhbGx5LCBmb2N1c2luZyBvbiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBhbHNvIGltcHJvdmVzIGJvdGggb2YgdGhlc2UuIFVzYWJpbGl0eSBpcyBpbXByb3ZlZCBiZWNhdXNlIHRoZSBleHBlcmllbmNlIGlzIGdyYWR1YWxseSBpbXByb3ZlZCwgbWVhbmluZyB0aGF0IGlmIHNvbWV3aGVyZSBhbG9uZyB0aGUgbGluZSBhIGZlYXR1cmUgaXMgbWlzc2luZywgdGhlIGNvbXBvbmVudCBpcyA8c3Ryb25nPnN0aWxsIGV4cGVjdGVkIHRvIHdvcms8L3N0cm9uZz4uPC9wPlxcbjxwPkZvciBleGFtcGxlLCBhIHByb2dyZXNzaXZlbHkgZW5oYW5jZWQgc2l0ZSB1c2VzIHBsYWluLW9sZCBsaW5rcyB0byBuYXZpZ2F0ZSBmcm9tIG9uZSB2aWV3IHRvIGFub3RoZXIsIGFuZCB0aGVuIGFkZHMgYSA8Y29kZT5jbGljazwvY29kZT4gZXZlbnQgaGFuZGxlciB0aGF0IGJsb2NrcyBuYXZpZ2F0aW9uIGFuZCBpc3N1ZXMgYW4gQUpBWCByZXF1ZXN0IGluc3RlYWQuIElmIEphdmFTY3JpcHQgZmFpbHMgdG8gbG9hZCwgcGVyaGFwcyB0aGUgZXhwZXJpZW5jZSBtaWdodCBzdGF5IGEgbGl0dGxlIGJpdCB3b3JzZSwgYnV0IHRoYXQmIzM5O3Mgb2theSwgYmVjYXVzZSB3ZSBhY2tub3dsZWRnZSB0aGF0IDxzdHJvbmc+b3VyIHNpdGVzIGRvbiYjMzk7dCBuZWVkIHRvIGxvb2sgYW5kIGJlaGF2ZSB0aGUgc2FtZSBvbiBldmVyeSBicm93c2VyPC9zdHJvbmc+LiBTaW1pbGFybHksIDxhIGhyZWY9XFxcImh0dHA6Ly9wb255Zm9vLmNvbS9hcnRpY2xlcy9jcml0aWNhbC1wYXRoLXBlcmZvcm1hbmNlLW9wdGltaXphdGlvblxcXCI+cGVyZm9ybWFuY2UgaXMgZ3JlYXRseSBlbmhhbmNlZDwvYT4gYnkgZGVsaXZlcmluZyBjb250ZW50IHRvIHRoZSBodW1hbiBhcyBmYXN0IGFzIHBvc3NpYmxlLCBhbmQgdGhlbiBhZGRpbmcgZnVuY3Rpb25hbGl0eSBvbiB0b3Agb2YgdGhhdC48L3A+XFxuPHA+V2l0aCBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCwgaWYgdGhlIGZ1bmN0aW9uYWxpdHkgbmV2ZXIgZ2V0cyB0aGVyZSBiZWNhdXNlIGEgSmF2YVNjcmlwdCByZXNvdXJjZSBmYWlsZWQgdG8gbG9hZCBiZWNhdXNlIHRoZSBuZXR3b3JrIGZhaWxlZCA8ZW0+KG5vdCB1bmNvbW1vbiBpbiB0aGUgbW9iaWxlIGVyYSk8L2VtPiBvciBiZWNhdXNlIHRoZSB1c2VyIGJsb2NrZWQgSmF2YVNjcmlwdCwgeW91ciBhcHBsaWNhdGlvbiB3aWxsIHN0aWxsIHdvcmshPC9wPlxcblwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9zZWN0aW9uPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMywgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9hYm91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxzZWN0aW9uIGNsYXNzPVxcXCJseS1zZWN0aW9uIG1kLW1hcmtkb3duXFxcIj5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDQsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vYWJvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8aDEgaWQ9XFxcIndoeS1ub3Qtb3RoZXItZnJhbWV3b3Jrcy1cXFwiPldoeSBOb3QgT3RoZXIgRnJhbWV3b3Jrcz88L2gxPlxcbjxwPk1hbnkgb3RoZXIgZnJhbWV3b3JrcyB3ZXJlbiYjMzk7dCBkZXNpZ25lZCB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LCBvciBldmVuIHNoYXJlZC1yZW5kZXJpbmcgaW4gbWluZC4gQ29udGVudCBpc24mIzM5O3QgcHJpb3JpdGl6ZWQsIGFuZCBodW1hbnMgYXJlIGV4cGVjdGVkIHRvIDxhIGhyZWY9XFxcImh0dHA6Ly9wb255Zm9vLmNvbS9hcnRpY2xlcy9zdG9wLWJyZWFraW5nLXRoZS13ZWJcXFwiPmRvd25sb2FkIG1vc3Qgb2YgYSB3ZWIgcGFnZSBiZWZvcmUgdGhleSBjYW4gc2VlIGFueSBkaWdlc3RpYmxlIGNvbnRlbnQ8L2E+LiBXaGlsZSBHb29nbGUgaXMgZ29pbmcgdG8gcmVzb2x2ZSB0aGUgU0VPIGlzc3VlcyB3aXRoIGRlZGljYXRlZCBjbGllbnQtc2lkZSByZW5kZXJpbmcgc29vbiwgdGhhdCB3b24mIzM5O3Qgc29sdmUgYWxsIHlvdXIgcHJvYmxlbXMuIEdvb2dsZSBpc24mIzM5O3QgdGhlIG9ubHkgd2ViIGNyYXdsZXIgb3BlcmF0b3Igb3V0IHRoZXJlLCBhbmQgaXQgbWlnaHQgYmUgYSB3aGlsZSBiZWZvcmUgc29jaWFsIG1lZGlhIGxpbmsgY3Jhd2xlcnMgY2F0Y2ggdXAgd2l0aCB0aGVtLiBFdmVuIGlmIGNyYXdsZXJzIGFyZSBub3QgYW4gaXNzdWUsIGJlaW5nIGFibGUgdG8gcHJvdmlkZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBleHBlcmllbmNlIGlzIGEgYmlnIHByb2JsZW0gdG8gcmVzb2x2ZS48L3A+XFxuPHA+TGF0ZWx5LCBtYW55IG1hdHVyZSBvcGVuLXNvdXJjZSBmcmFtZXdvcmtzIHN0YXJ0ZWQgZHJvcHBpbmcgc3VwcG9ydCBmb3Igb2xkZXIgYnJvd3NlcnMuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgdGhlIHdheSB0aGV5JiMzOTtyZSBhcmNoaXRlY3RlZCwgd2hlcmUgdGhlIGRldmVsb3BlciBpcyBwdXQgZmlyc3QuIDxzdHJvbmc+VGF1bnVzIGlzIDxhIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vaGFzaHRhZy9odW1hbmZpcnN0XFxcIj4jaHVtYW5maXJzdDwvYT48L3N0cm9uZz4sIG1lYW5pbmcgdGhhdCBpdCBjb25jZWRlcyB0aGF0IGh1bWFucyBhcmUgbW9yZSBpbXBvcnRhbnQgdGhhbiB0aGUgZGV2ZWxvcGVycyBidWlsZGluZyB0aGVpciBhcHBsaWNhdGlvbnMuPC9wPlxcbjxwPlByb2dyZXNzaXZlbHkgZW5oYW5jZWQgYXBwbGljYXRpb25zIGFyZSBhbHdheXMgZ29pbmcgdG8gaGF2ZSBncmVhdCBicm93c2VyIHN1cHBvcnQgYmVjYXVzZSBvZiB0aGUgd2F5IHRoZXkmIzM5O3JlIGFyY2hpdGVjdGVkLiBBcyB0aGUgbmFtZSBpbXBsaWVzLCBhIGJhc2VsaW5lIGlzIGVzdGFibGlzaGVkIHdoZXJlIHdlIGRlbGl2ZXIgdGhlIGNvcmUgZXhwZXJpZW5jZSB0byB0aGUgdXNlciA8ZW0+KHR5cGljYWxseSBpbiB0aGUgZm9ybSBvZiByZWFkYWJsZSBIVE1MIGNvbnRlbnQpPC9lbT4sIGFuZCB0aGVuIGVuaGFuY2UgaXQgPHN0cm9uZz5pZiBwb3NzaWJsZTwvc3Ryb25nPiB1c2luZyBDU1MgYW5kIEphdmFTY3JpcHQuIEJ1aWxkaW5nIGFwcGxpY2F0aW9ucyBpbiB0aGlzIHdheSBtZWFucyB0aGF0IDxzdHJvbmc+eW91JiMzOTtsbCBiZSBhYmxlIHRvIHJlYWNoIHRoZSBtb3N0IHBlb3BsZSB3aXRoIHlvdXIgY29yZSBleHBlcmllbmNlPC9zdHJvbmc+LCBhbmQgeW91JiMzOTtsbCBhbHNvIGJlIGFibGUgdG8gcHJvdmlkZSBodW1hbnMgaW4gbW9yZSBtb2Rlcm4gYnJvd3NlcnMgd2l0aCBhbGwgb2YgdGhlIGxhdGVzdCBmZWF0dXJlcyBhbmQgdGVjaG5vbG9naWVzLjwvcD5cXG5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2VjdGlvbj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDUsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vYWJvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8c2VjdGlvbiBjbGFzcz1cXFwibHktc2VjdGlvbiBtZC1tYXJrZG93blxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiA2LCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2Fib3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGgxIGlkPVxcXCJmZWF0dXJlc1xcXCI+RmVhdHVyZXM8L2gxPlxcbjxwPk91dCBvZiB0aGUgYm94LCBUYXVudXMgZW5zdXJlcyB0aGF0IHlvdXIgc2l0ZSB3b3JrcyBvbiBhbnkgSFRNTC1lbmFibGVkIGRvY3VtZW50IHZpZXdlciwgb3IgZXZlbiBvbiB0aGUgdGVybWluYWwsIHByb3ZpZGluZyBzdXBwb3J0IGZvciBwbGFpbiB0ZXh0IHJlc3BvbnNlcyA8YSBocmVmPVxcXCIvZ2V0dGluZy1zdGFydGVkXFxcIj53aXRob3V0IGFueSBjb25maWd1cmF0aW9uIG5lZWRlZDwvYT4uIEV2ZW4gd2hpbGUgVGF1bnVzIHByb3ZpZGVzIHNoYXJlZC1yZW5kZXJpbmcgY2FwYWJpbGl0aWVzLCBpdCBvZmZlcnMgY29kZSByZXVzZSBvZiB2aWV3cyBhbmQgcm91dGVzLCBtZWFuaW5nIHlvdSYjMzk7bGwgb25seSBoYXZlIHRvIGRlY2xhcmUgdGhlc2Ugb25jZSBidXQgdGhleSYjMzk7bGwgYmUgdXNlZCBpbiBib3RoIHRoZSBzZXJ2ZXItc2lkZSBhbmQgdGhlIGNsaWVudC1zaWRlLjwvcD5cXG48cD5UYXVudXMgZmVhdHVyZXMgYSByZWFzb25hYmx5IGVuaGFuY2VkIGV4cGVyaWVuY2UsIHdoZXJlIGlmIGZlYXR1cmVzIGFyZW4mIzM5O3QgYXZhaWxhYmxlIG9uIGEgYnJvd3NlciwgdGhleSYjMzk7cmUganVzdCBub3QgcHJvdmlkZWQuIEZvciBleGFtcGxlLCB0aGUgY2xpZW50LXNpZGUgcm91dGVyIG1ha2VzIHVzZSBvZiB0aGUgPGNvZGU+aGlzdG9yeTwvY29kZT4gQVBJIGJ1dCBpZiB0aGF0JiMzOTtzIG5vdCBhdmFpbGFibGUgdGhlbiBpdCYjMzk7bGwgZmFsbCBiYWNrIHRvIHNpbXBseSBub3QgbWVkZGxpbmcgd2l0aCBsaW5rcyBpbnN0ZWFkIG9mIHVzaW5nIGEgY2xpZW50LXNpZGUtb25seSBoYXNoIHJvdXRlci48L3A+XFxuPHA+VGF1bnVzIGNhbiBkZWFsIHdpdGggdmlldyBjYWNoaW5nIG9uIHlvdXIgYmVoYWxmLCBpZiB5b3Ugc28gZGVzaXJlLCB1c2luZyA8YSBocmVmPVxcXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSVxcXCI+YXN5bmNocm9ub3VzIGVtYmVkZGVkIGRhdGFiYXNlIHN0b3JlczwvYT4gb24gdGhlIGNsaWVudC1zaWRlLiBUdXJucyBvdXQsIHRoZXJlJiMzOTtzIDxhIGhyZWY9XFxcImh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWluZGV4ZWRkYlxcXCI+cHJldHR5IGdvb2QgYnJvd3NlciBzdXBwb3J0IGZvciBJbmRleGVkREI8L2E+LiBPZiBjb3Vyc2UsIEluZGV4ZWREQiB3aWxsIG9ubHkgYmUgdXNlZCBpZiBpdCYjMzk7cyBhdmFpbGFibGUsIGFuZCBpZiBpdCYjMzk7cyBub3QgdGhlbiB2aWV3IG1vZGVscyB3b24mIzM5O3QgYmUgY2FjaGVkIGluIHRoZSBjbGllbnQtc2lkZSBiZXNpZGVzIGFuIGluLW1lbW9yeSBzdG9yZS4gPHN0cm9uZz5UaGUgc2l0ZSB3b24mIzM5O3Qgc2ltcGx5IHJvbGwgb3ZlciBhbmQgZGllLCB0aG91Z2guPC9zdHJvbmc+PC9wPlxcbjxwPklmIHlvdSYjMzk7dmUgdHVybmVkIGNsaWVudC1zaWRlIGNhY2hpbmcgb24sIHRoZW4geW91IGNhbiBhbHNvIHR1cm4gb24gdGhlIDxzdHJvbmc+dmlldyBwcmUtZmV0Y2hpbmcgZmVhdHVyZTwvc3Ryb25nPiwgd2hpY2ggd2lsbCBzdGFydCBkb3dubG9hZGluZyB2aWV3cyBhcyBzb29uIGFzIGh1bWFucyBob3ZlciBvbiBsaW5rcywgYXMgdG8gZGVsaXZlciBhIDxlbT5mYXN0ZXIgcGVyY2VpdmVkIGh1bWFuIGV4cGVyaWVuY2U8L2VtPi48L3A+XFxuPHA+VGF1bnVzIHByb3ZpZGVzIHRoZSBiYXJlIGJvbmVzIGZvciB5b3VyIGFwcGxpY2F0aW9uIHNvIHRoYXQgeW91IGNhbiBzZXBhcmF0ZSBjb25jZXJucyBpbnRvIHJvdXRlcywgY29udHJvbGxlcnMsIG1vZGVscywgYW5kIHZpZXdzLiBUaGVuIGl0IGdldHMgb3V0IG9mIHRoZSB3YXksIGJ5IGRlc2lnbi4gVGhlcmUgYXJlIDxhIGhyZWY9XFxcIi9jb21wbGVtZW50c1xcXCI+YSBmZXcgY29tcGxlbWVudGFyeSBtb2R1bGVzPC9hPiB5b3UgY2FuIHVzZSB0byBlbmhhbmNlIHlvdXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZSwgYXMgd2VsbC48L3A+XFxuPHA+V2l0aCBUYXVudXMgeW91JiMzOTtsbCBiZSBpbiBjaGFyZ2UuIDxhIGhyZWY9XFxcIi9nZXR0aW5nLXN0YXJ0ZWRcXFwiPkFyZSB5b3UgcmVhZHkgdG8gZ2V0IHN0YXJ0ZWQ/PC9hPjwvcD5cXG5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2VjdGlvbj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDcsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vYWJvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8c2VjdGlvbiBjbGFzcz1cXFwibHktc2VjdGlvbiBtZC1tYXJrZG93blxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiA4LCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2Fib3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGgxIGlkPVxcXCJmYW1pbGlhcml0eVxcXCI+RmFtaWxpYXJpdHk8L2gxPlxcbjxwPllvdSBjYW4gdXNlIFRhdW51cyB0byBkZXZlbG9wIGFwcGxpY2F0aW9ucyB1c2luZyB5b3VyIGZhdm9yaXRlIE5vZGUuanMgSFRUUCBzZXJ2ZXIsIDxzdHJvbmc+Ym90aCA8YSBocmVmPVxcXCJodHRwOi8vZXhwcmVzc2pzLmNvbVxcXCI+RXhwcmVzczwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHA6Ly9oYXBpanMuY29tXFxcIj5IYXBpPC9hPiBhcmUgZnVsbHkgc3VwcG9ydGVkPC9zdHJvbmc+LiBJbiBib3RoIGNhc2VzLCB5b3UmIzM5O2xsIDxhIGhyZWY9XFxcIi9nZXR0aW5nLXN0YXJ0ZWRcXFwiPmJ1aWxkIGNvbnRyb2xsZXJzIHRoZSB3YXkgeW91JiMzOTtyZSBhbHJlYWR5IHVzZWQgdG88L2E+LCBleGNlcHQgeW91IHdvbiYjMzk7dCBoYXZlIHRvIDxjb2RlPnJlcXVpcmU8L2NvZGU+IHRoZSB2aWV3IGNvbnRyb2xsZXJzIG9yIGRlZmluZSBhbnkgdmlldyByb3V0ZXMgc2luY2UgVGF1bnVzIHdpbGwgZGVhbCB3aXRoIHRoYXQgb24geW91ciBiZWhhbGYuIEluIHRoZSBjb250cm9sbGVycyB5b3UmIzM5O2xsIGJlIGFibGUgdG8gZG8gZXZlcnl0aGluZyB5b3UmIzM5O3JlIGFscmVhZHkgYWJsZSB0byBkbywgYW5kIHRoZW4geW91JiMzOTtsbCBoYXZlIHRvIHJldHVybiBhIEpTT04gbW9kZWwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbmRlciBhIHZpZXcuPC9wPlxcbjxwPllvdSBjYW4gdXNlIGFueSB2aWV3LXJlbmRlcmluZyBlbmdpbmUgdGhhdCB5b3Ugd2FudCwgcHJvdmlkZWQgdGhhdCBpdCBjYW4gYmUgY29tcGlsZWQgaW50byBKYXZhU2NyaXB0IGZ1bmN0aW9ucy4gVGhhdCYjMzk7cyBiZWNhdXNlIFRhdW51cyB0cmVhdHMgdmlld3MgYXMgbWVyZSBKYXZhU2NyaXB0IGZ1bmN0aW9ucywgcmF0aGVyIHRoYW4gYmVpbmcgdGllZCBpbnRvIGEgc3BlY2lmaWMgdmlldy1yZW5kZXJpbmcgZW5naW5lLjwvcD5cXG48cD5DbGllbnQtc2lkZSBjb250cm9sbGVycyBhcmUganVzdCBmdW5jdGlvbnMsIHRvby4gWW91IGNhbiBicmluZyB5b3VyIG93biBzZWxlY3RvciBlbmdpbmUsIHlvdXIgb3duIEFKQVggbGlicmFyaWVzLCBhbmQgeW91ciBvd24gZGF0YS1iaW5kaW5nIHNvbHV0aW9ucy4gSXQgbWlnaHQgbWVhbiB0aGVyZSYjMzk7cyBhIGJpdCBtb3JlIHdvcmsgaW52b2x2ZWQgZm9yIHlvdSwgYnV0IHlvdSYjMzk7bGwgYWxzbyBiZSBmcmVlIHRvIHBpY2sgd2hhdGV2ZXIgbGlicmFyaWVzIHlvdSYjMzk7cmUgbW9zdCBjb21mb3J0YWJsZSB3aXRoISBUaGF0IGJlaW5nIHNhaWQsIFRhdW51cyA8YSBocmVmPVxcXCIvY29tcGxlbWVudHNcXFwiPmRvZXMgcmVjb21tZW5kIGEgZmV3IGxpYnJhcmllczwvYT4gdGhhdCB3b3JrIHdlbGwgd2l0aCBpdC48L3A+XFxuXCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L3NlY3Rpb24+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO30uY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC51bmRlZmluZWQ6dHlwZW9mIHVuZGVmaW5lZCE9PVwidW5kZWZpbmVkXCI/dW5kZWZpbmVkOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59IGNhdGNoIChlcnIpIHtcbiAgamFkZS5yZXRocm93KGVyciwgamFkZV9kZWJ1Z1swXS5maWxlbmFtZSwgamFkZV9kZWJ1Z1swXS5saW5lbm8sIFwic2VjdGlvbi5seS1zZWN0aW9uLm1kLW1hcmtkb3duXFxuICA6bWFya2Rvd25cXG4gICAgIyBXaHkgVGF1bnVzP1xcblxcbiAgICBUYXVudXMgZm9jdXNlcyBvbiBkZWxpdmVyaW5nIGEgcHJvZ3Jlc3NpdmVseSBlbmhhbmNlZCBleHBlcmllbmNlIHRvIHRoZSBlbmQtdXNlciwgd2hpbGUgcHJvdmlkaW5nIF9hIHJlYXNvbmFibGUgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZV8gYXMgd2VsbC4gKipUYXVudXMgcHJpb3JpdGl6ZXMgY29udGVudCoqLiBJdCB1c2VzIHNlcnZlci1zaWRlIHJlbmRlcmluZyB0byBnZXQgY29udGVudCB0byB5b3VyIGh1bWFucyBhcyBmYXN0IGFzIHBvc3NpYmxlLCBhbmQgaXQgdXNlcyBjbGllbnQtc2lkZSByZW5kZXJpbmcgdG8gaW1wcm92ZSB0aGVpciBleHBlcmllbmNlLlxcblxcbiAgICBXaGlsZSBpdCBmb2N1c2VzIG9uIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LCAqKlt1c2FiaWxpdHldWzJdIGFuZCBwZXJmb3JtYW5jZSBhcmUgYm90aCBjb3JlIGNvbmNlcm5zKiogZm9yIFRhdW51cy4gSW5jaWRlbnRhbGx5LCBmb2N1c2luZyBvbiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBhbHNvIGltcHJvdmVzIGJvdGggb2YgdGhlc2UuIFVzYWJpbGl0eSBpcyBpbXByb3ZlZCBiZWNhdXNlIHRoZSBleHBlcmllbmNlIGlzIGdyYWR1YWxseSBpbXByb3ZlZCwgbWVhbmluZyB0aGF0IGlmIHNvbWV3aGVyZSBhbG9uZyB0aGUgbGluZSBhIGZlYXR1cmUgaXMgbWlzc2luZywgdGhlIGNvbXBvbmVudCBpcyAqKnN0aWxsIGV4cGVjdGVkIHRvIHdvcmsqKi5cXG5cXG4gICAgRm9yIGV4YW1wbGUsIGEgcHJvZ3Jlc3NpdmVseSBlbmhhbmNlZCBzaXRlIHVzZXMgcGxhaW4tb2xkIGxpbmtzIHRvIG5hdmlnYXRlIGZyb20gb25lIHZpZXcgdG8gYW5vdGhlciwgYW5kIHRoZW4gYWRkcyBhIGBjbGlja2AgZXZlbnQgaGFuZGxlciB0aGF0IGJsb2NrcyBuYXZpZ2F0aW9uIGFuZCBpc3N1ZXMgYW4gQUpBWCByZXF1ZXN0IGluc3RlYWQuIElmIEphdmFTY3JpcHQgZmFpbHMgdG8gbG9hZCwgcGVyaGFwcyB0aGUgZXhwZXJpZW5jZSBtaWdodCBzdGF5IGEgbGl0dGxlIGJpdCB3b3JzZSwgYnV0IHRoYXQncyBva2F5LCBiZWNhdXNlIHdlIGFja25vd2xlZGdlIHRoYXQgKipvdXIgc2l0ZXMgZG9uJ3QgbmVlZCB0byBsb29rIGFuZCBiZWhhdmUgdGhlIHNhbWUgb24gZXZlcnkgYnJvd3NlcioqLiBTaW1pbGFybHksIFtwZXJmb3JtYW5jZSBpcyBncmVhdGx5IGVuaGFuY2VkXVsxXSBieSBkZWxpdmVyaW5nIGNvbnRlbnQgdG8gdGhlIGh1bWFuIGFzIGZhc3QgYXMgcG9zc2libGUsIGFuZCB0aGVuIGFkZGluZyBmdW5jdGlvbmFsaXR5IG9uIHRvcCBvZiB0aGF0LlxcblxcbiAgICBXaXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LCBpZiB0aGUgZnVuY3Rpb25hbGl0eSBuZXZlciBnZXRzIHRoZXJlIGJlY2F1c2UgYSBKYXZhU2NyaXB0IHJlc291cmNlIGZhaWxlZCB0byBsb2FkIGJlY2F1c2UgdGhlIG5ldHdvcmsgZmFpbGVkIF8obm90IHVuY29tbW9uIGluIHRoZSBtb2JpbGUgZXJhKV8gb3IgYmVjYXVzZSB0aGUgdXNlciBibG9ja2VkIEphdmFTY3JpcHQsIHlvdXIgYXBwbGljYXRpb24gd2lsbCBzdGlsbCB3b3JrIVxcblxcbiAgICBbMV06IGh0dHA6Ly9wb255Zm9vLmNvbS9hcnRpY2xlcy9jcml0aWNhbC1wYXRoLXBlcmZvcm1hbmNlLW9wdGltaXphdGlvblxcbiAgICBbMl06IGh0dHA6Ly9wb255Zm9vLmNvbS9hcnRpY2xlcy9hZGp1c3RpbmctdXgtZm9yLWh1bWFuc1xcblxcbnNlY3Rpb24ubHktc2VjdGlvbi5tZC1tYXJrZG93blxcbiAgOm1hcmtkb3duXFxuICAgICMgV2h5IE5vdCBPdGhlciBGcmFtZXdvcmtzP1xcblxcbiAgICBNYW55IG90aGVyIGZyYW1ld29ya3Mgd2VyZW4ndCBkZXNpZ25lZCB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LCBvciBldmVuIHNoYXJlZC1yZW5kZXJpbmcgaW4gbWluZC4gQ29udGVudCBpc24ndCBwcmlvcml0aXplZCwgYW5kIGh1bWFucyBhcmUgZXhwZWN0ZWQgdG8gW2Rvd25sb2FkIG1vc3Qgb2YgYSB3ZWIgcGFnZSBiZWZvcmUgdGhleSBjYW4gc2VlIGFueSBkaWdlc3RpYmxlIGNvbnRlbnRdWzJdLiBXaGlsZSBHb29nbGUgaXMgZ29pbmcgdG8gcmVzb2x2ZSB0aGUgU0VPIGlzc3VlcyB3aXRoIGRlZGljYXRlZCBjbGllbnQtc2lkZSByZW5kZXJpbmcgc29vbiwgdGhhdCB3b24ndCBzb2x2ZSBhbGwgeW91ciBwcm9ibGVtcy4gR29vZ2xlIGlzbid0IHRoZSBvbmx5IHdlYiBjcmF3bGVyIG9wZXJhdG9yIG91dCB0aGVyZSwgYW5kIGl0IG1pZ2h0IGJlIGEgd2hpbGUgYmVmb3JlIHNvY2lhbCBtZWRpYSBsaW5rIGNyYXdsZXJzIGNhdGNoIHVwIHdpdGggdGhlbS4gRXZlbiBpZiBjcmF3bGVycyBhcmUgbm90IGFuIGlzc3VlLCBiZWluZyBhYmxlIHRvIHByb3ZpZGUgdGhlIGZhc3Rlc3QgcG9zc2libGUgZXhwZXJpZW5jZSBpcyBhIGJpZyBwcm9ibGVtIHRvIHJlc29sdmUuXFxuXFxuICAgIExhdGVseSwgbWFueSBtYXR1cmUgb3Blbi1zb3VyY2UgZnJhbWV3b3JrcyBzdGFydGVkIGRyb3BwaW5nIHN1cHBvcnQgZm9yIG9sZGVyIGJyb3dzZXJzLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIHRoZSB3YXkgdGhleSdyZSBhcmNoaXRlY3RlZCwgd2hlcmUgdGhlIGRldmVsb3BlciBpcyBwdXQgZmlyc3QuICoqVGF1bnVzIGlzIFsjaHVtYW5maXJzdF1bMV0qKiwgbWVhbmluZyB0aGF0IGl0IGNvbmNlZGVzIHRoYXQgaHVtYW5zIGFyZSBtb3JlIGltcG9ydGFudCB0aGFuIHRoZSBkZXZlbG9wZXJzIGJ1aWxkaW5nIHRoZWlyIGFwcGxpY2F0aW9ucy5cXG5cXG4gICAgUHJvZ3Jlc3NpdmVseSBlbmhhbmNlZCBhcHBsaWNhdGlvbnMgYXJlIGFsd2F5cyBnb2luZyB0byBoYXZlIGdyZWF0IGJyb3dzZXIgc3VwcG9ydCBiZWNhdXNlIG9mIHRoZSB3YXkgdGhleSdyZSBhcmNoaXRlY3RlZC4gQXMgdGhlIG5hbWUgaW1wbGllcywgYSBiYXNlbGluZSBpcyBlc3RhYmxpc2hlZCB3aGVyZSB3ZSBkZWxpdmVyIHRoZSBjb3JlIGV4cGVyaWVuY2UgdG8gdGhlIHVzZXIgXyh0eXBpY2FsbHkgaW4gdGhlIGZvcm0gb2YgcmVhZGFibGUgSFRNTCBjb250ZW50KV8sIGFuZCB0aGVuIGVuaGFuY2UgaXQgKippZiBwb3NzaWJsZSoqIHVzaW5nIENTUyBhbmQgSmF2YVNjcmlwdC4gQnVpbGRpbmcgYXBwbGljYXRpb25zIGluIHRoaXMgd2F5IG1lYW5zIHRoYXQgKip5b3UnbGwgYmUgYWJsZSB0byByZWFjaCB0aGUgbW9zdCBwZW9wbGUgd2l0aCB5b3VyIGNvcmUgZXhwZXJpZW5jZSoqLCBhbmQgeW91J2xsIGFsc28gYmUgYWJsZSB0byBwcm92aWRlIGh1bWFucyBpbiBtb3JlIG1vZGVybiBicm93c2VycyB3aXRoIGFsbCBvZiB0aGUgbGF0ZXN0IGZlYXR1cmVzIGFuZCB0ZWNobm9sb2dpZXMuXFxuXFxuICAgIFsxXTogaHR0cHM6Ly90d2l0dGVyLmNvbS9oYXNodGFnL2h1bWFuZmlyc3RcXG4gICAgWzJdOiBodHRwOi8vcG9ueWZvby5jb20vYXJ0aWNsZXMvc3RvcC1icmVha2luZy10aGUtd2ViXFxuXFxuc2VjdGlvbi5seS1zZWN0aW9uLm1kLW1hcmtkb3duXFxuICA6bWFya2Rvd25cXG4gICAgIyBGZWF0dXJlc1xcblxcbiAgICBPdXQgb2YgdGhlIGJveCwgVGF1bnVzIGVuc3VyZXMgdGhhdCB5b3VyIHNpdGUgd29ya3Mgb24gYW55IEhUTUwtZW5hYmxlZCBkb2N1bWVudCB2aWV3ZXIsIG9yIGV2ZW4gb24gdGhlIHRlcm1pbmFsLCBwcm92aWRpbmcgc3VwcG9ydCBmb3IgcGxhaW4gdGV4dCByZXNwb25zZXMgW3dpdGhvdXQgYW55IGNvbmZpZ3VyYXRpb24gbmVlZGVkXVsyXS4gRXZlbiB3aGlsZSBUYXVudXMgcHJvdmlkZXMgc2hhcmVkLXJlbmRlcmluZyBjYXBhYmlsaXRpZXMsIGl0IG9mZmVycyBjb2RlIHJldXNlIG9mIHZpZXdzIGFuZCByb3V0ZXMsIG1lYW5pbmcgeW91J2xsIG9ubHkgaGF2ZSB0byBkZWNsYXJlIHRoZXNlIG9uY2UgYnV0IHRoZXknbGwgYmUgdXNlZCBpbiBib3RoIHRoZSBzZXJ2ZXItc2lkZSBhbmQgdGhlIGNsaWVudC1zaWRlLlxcblxcbiAgICBUYXVudXMgZmVhdHVyZXMgYSByZWFzb25hYmx5IGVuaGFuY2VkIGV4cGVyaWVuY2UsIHdoZXJlIGlmIGZlYXR1cmVzIGFyZW4ndCBhdmFpbGFibGUgb24gYSBicm93c2VyLCB0aGV5J3JlIGp1c3Qgbm90IHByb3ZpZGVkLiBGb3IgZXhhbXBsZSwgdGhlIGNsaWVudC1zaWRlIHJvdXRlciBtYWtlcyB1c2Ugb2YgdGhlIGBoaXN0b3J5YCBBUEkgYnV0IGlmIHRoYXQncyBub3QgYXZhaWxhYmxlIHRoZW4gaXQnbGwgZmFsbCBiYWNrIHRvIHNpbXBseSBub3QgbWVkZGxpbmcgd2l0aCBsaW5rcyBpbnN0ZWFkIG9mIHVzaW5nIGEgY2xpZW50LXNpZGUtb25seSBoYXNoIHJvdXRlci5cXG5cXG4gICAgVGF1bnVzIGNhbiBkZWFsIHdpdGggdmlldyBjYWNoaW5nIG9uIHlvdXIgYmVoYWxmLCBpZiB5b3Ugc28gZGVzaXJlLCB1c2luZyBbYXN5bmNocm9ub3VzIGVtYmVkZGVkIGRhdGFiYXNlIHN0b3Jlc11bM10gb24gdGhlIGNsaWVudC1zaWRlLiBUdXJucyBvdXQsIHRoZXJlJ3MgW3ByZXR0eSBnb29kIGJyb3dzZXIgc3VwcG9ydCBmb3IgSW5kZXhlZERCXVs0XS4gT2YgY291cnNlLCBJbmRleGVkREIgd2lsbCBvbmx5IGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBpZiBpdCdzIG5vdCB0aGVuIHZpZXcgbW9kZWxzIHdvbid0IGJlIGNhY2hlZCBpbiB0aGUgY2xpZW50LXNpZGUgYmVzaWRlcyBhbiBpbi1tZW1vcnkgc3RvcmUuICoqVGhlIHNpdGUgd29uJ3Qgc2ltcGx5IHJvbGwgb3ZlciBhbmQgZGllLCB0aG91Z2guKipcXG5cXG4gICAgSWYgeW91J3ZlIHR1cm5lZCBjbGllbnQtc2lkZSBjYWNoaW5nIG9uLCB0aGVuIHlvdSBjYW4gYWxzbyB0dXJuIG9uIHRoZSAqKnZpZXcgcHJlLWZldGNoaW5nIGZlYXR1cmUqKiwgd2hpY2ggd2lsbCBzdGFydCBkb3dubG9hZGluZyB2aWV3cyBhcyBzb29uIGFzIGh1bWFucyBob3ZlciBvbiBsaW5rcywgYXMgdG8gZGVsaXZlciBhIF9mYXN0ZXIgcGVyY2VpdmVkIGh1bWFuIGV4cGVyaWVuY2VfLlxcblxcbiAgICBUYXVudXMgcHJvdmlkZXMgdGhlIGJhcmUgYm9uZXMgZm9yIHlvdXIgYXBwbGljYXRpb24gc28gdGhhdCB5b3UgY2FuIHNlcGFyYXRlIGNvbmNlcm5zIGludG8gcm91dGVzLCBjb250cm9sbGVycywgbW9kZWxzLCBhbmQgdmlld3MuIFRoZW4gaXQgZ2V0cyBvdXQgb2YgdGhlIHdheSwgYnkgZGVzaWduLiBUaGVyZSBhcmUgW2EgZmV3IGNvbXBsZW1lbnRhcnkgbW9kdWxlc11bMV0geW91IGNhbiB1c2UgdG8gZW5oYW5jZSB5b3VyIGRldmVsb3BtZW50IGV4cGVyaWVuY2UsIGFzIHdlbGwuXFxuXFxuICAgIFdpdGggVGF1bnVzIHlvdSdsbCBiZSBpbiBjaGFyZ2UuIFtBcmUgeW91IHJlYWR5IHRvIGdldCBzdGFydGVkP11bMl1cXG5cXG4gICAgWzFdOiAvY29tcGxlbWVudHNcXG4gICAgWzJdOiAvZ2V0dGluZy1zdGFydGVkXFxuICAgIFszXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUElcXG4gICAgWzRdOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1pbmRleGVkZGJcXG5cXG5zZWN0aW9uLmx5LXNlY3Rpb24ubWQtbWFya2Rvd25cXG4gIDptYXJrZG93blxcbiAgICAjIEZhbWlsaWFyaXR5XFxuXFxuICAgIFlvdSBjYW4gdXNlIFRhdW51cyB0byBkZXZlbG9wIGFwcGxpY2F0aW9ucyB1c2luZyB5b3VyIGZhdm9yaXRlIE5vZGUuanMgSFRUUCBzZXJ2ZXIsICoqYm90aCBbRXhwcmVzc11bM10gYW5kIFtIYXBpXVs0XSBhcmUgZnVsbHkgc3VwcG9ydGVkKiouIEluIGJvdGggY2FzZXMsIHlvdSdsbCBbYnVpbGQgY29udHJvbGxlcnMgdGhlIHdheSB5b3UncmUgYWxyZWFkeSB1c2VkIHRvXVsxXSwgZXhjZXB0IHlvdSB3b24ndCBoYXZlIHRvIGByZXF1aXJlYCB0aGUgdmlldyBjb250cm9sbGVycyBvciBkZWZpbmUgYW55IHZpZXcgcm91dGVzIHNpbmNlIFRhdW51cyB3aWxsIGRlYWwgd2l0aCB0aGF0IG9uIHlvdXIgYmVoYWxmLiBJbiB0aGUgY29udHJvbGxlcnMgeW91J2xsIGJlIGFibGUgdG8gZG8gZXZlcnl0aGluZyB5b3UncmUgYWxyZWFkeSBhYmxlIHRvIGRvLCBhbmQgdGhlbiB5b3UnbGwgaGF2ZSB0byByZXR1cm4gYSBKU09OIG1vZGVsIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW5kZXIgYSB2aWV3LlxcblxcbiAgICBZb3UgY2FuIHVzZSBhbnkgdmlldy1yZW5kZXJpbmcgZW5naW5lIHRoYXQgeW91IHdhbnQsIHByb3ZpZGVkIHRoYXQgaXQgY2FuIGJlIGNvbXBpbGVkIGludG8gSmF2YVNjcmlwdCBmdW5jdGlvbnMuIFRoYXQncyBiZWNhdXNlIFRhdW51cyB0cmVhdHMgdmlld3MgYXMgbWVyZSBKYXZhU2NyaXB0IGZ1bmN0aW9ucywgcmF0aGVyIHRoYW4gYmVpbmcgdGllZCBpbnRvIGEgc3BlY2lmaWMgdmlldy1yZW5kZXJpbmcgZW5naW5lLlxcblxcbiAgICBDbGllbnQtc2lkZSBjb250cm9sbGVycyBhcmUganVzdCBmdW5jdGlvbnMsIHRvby4gWW91IGNhbiBicmluZyB5b3VyIG93biBzZWxlY3RvciBlbmdpbmUsIHlvdXIgb3duIEFKQVggbGlicmFyaWVzLCBhbmQgeW91ciBvd24gZGF0YS1iaW5kaW5nIHNvbHV0aW9ucy4gSXQgbWlnaHQgbWVhbiB0aGVyZSdzIGEgYml0IG1vcmUgd29yayBpbnZvbHZlZCBmb3IgeW91LCBidXQgeW91J2xsIGFsc28gYmUgZnJlZSB0byBwaWNrIHdoYXRldmVyIGxpYnJhcmllcyB5b3UncmUgbW9zdCBjb21mb3J0YWJsZSB3aXRoISBUaGF0IGJlaW5nIHNhaWQsIFRhdW51cyBbZG9lcyByZWNvbW1lbmQgYSBmZXcgbGlicmFyaWVzXVsyXSB0aGF0IHdvcmsgd2VsbCB3aXRoIGl0LlxcblxcbiAgICBbMV06IC9nZXR0aW5nLXN0YXJ0ZWRcXG4gICAgWzJdOiAvY29tcGxlbWVudHNcXG4gICAgWzNdOiBodHRwOi8vZXhwcmVzc2pzLmNvbVxcbiAgICBbNF06IGh0dHA6Ly9oYXBpanMuY29tXFxuXCIpO1xufVxufSIsInZhciBqYWRlID0gcmVxdWlyZShcImphZHVtL3J1bnRpbWVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwaShsb2NhbHMpIHtcbnZhciBqYWRlX2RlYnVnID0gW3sgbGluZW5vOiAxLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2FwaS5qYWRlXCIgfV07XG50cnkge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vYXBpLmphZGVcIiB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMSwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9hcGkuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8c2VjdGlvbiBjbGFzcz1cXFwibHktc2VjdGlvbiBtZC1tYXJrZG93blxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2FwaS5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMSBpZD1cXFwiYXBpLWRvY3VtZW50YXRpb25cXFwiPkFQSSBEb2N1bWVudGF0aW9uPC9oMT5cXG48cD5IZXJlJiMzOTtzIHRoZSBBUEkgZG9jdW1lbnRhdGlvbiBmb3IgVGF1bnVzLiBJZiB5b3UmIzM5O3ZlIG5ldmVyIHVzZWQgaXQgYmVmb3JlLCB3ZSByZWNvbW1lbmQgZ29pbmcgb3ZlciB0aGUgPGEgaHJlZj1cXFwiL2dldHRpbmctc3RhcnRlZFxcXCI+R2V0dGluZyBTdGFydGVkPC9hPiBndWlkZSBiZWZvcmUganVtcGluZyBpbnRvIHRoZSBBUEkgZG9jdW1lbnRhdGlvbi4gVGhhdCB3YXksIHlvdSYjMzk7bGwgZ2V0IGEgYmV0dGVyIGlkZWEgb2Ygd2hhdCB0byBsb29rIGZvciBhbmQgaG93IHRvIHB1dCB0b2dldGhlciBzaW1wbGUgYXBwbGljYXRpb25zIHVzaW5nIFRhdW51cywgYmVmb3JlIGdvaW5nIHRocm91Z2ggZG9jdW1lbnRhdGlvbiBvbiBldmVyeSBwdWJsaWMgaW50ZXJmYWNlIHRvIFRhdW51cy48L3A+XFxuPHA+VGF1bnVzIGV4cG9zZXMgPGVtPnRocmVlIGRpZmZlcmVudCBwdWJsaWMgQVBJczwvZW0+LCBhbmQgdGhlcmUmIzM5O3MgYWxzbyA8c3Ryb25nPnBsdWdpbnMgdG8gaW50ZWdyYXRlIFRhdW51cyBhbmQgYW4gSFRUUCBzZXJ2ZXI8L3N0cm9uZz4uIFRoaXMgZG9jdW1lbnQgY292ZXJzIGFsbCB0aHJlZSBBUElzIGV4dGVuc2l2ZWx5LiBJZiB5b3UmIzM5O3JlIGNvbmNlcm5lZCBhYm91dCB0aGUgaW5uZXIgd29ya2luZ3Mgb2YgVGF1bnVzLCBwbGVhc2UgcmVmZXIgdG8gdGhlIDxhIGhyZWY9XFxcIi9nZXR0aW5nLXN0YXJ0ZWRcXFwiPkdldHRpbmcgU3RhcnRlZDwvYT4gZ3VpZGUuIFRoaXMgZG9jdW1lbnQgYWltcyB0byBvbmx5IGNvdmVyIGhvdyB0aGUgcHVibGljIGludGVyZmFjZSBhZmZlY3RzIGFwcGxpY2F0aW9uIHN0YXRlLCBidXQgPHN0cm9uZz5kb2VzbiYjMzk7dCBkZWx2ZSBpbnRvIGltcGxlbWVudGF0aW9uIGRldGFpbHM8L3N0cm9uZz4uPC9wPlxcbjxoMSBpZD1cXFwidGFibGUtb2YtY29udGVudHNcXFwiPlRhYmxlIG9mIENvbnRlbnRzPC9oMT5cXG48dWw+XFxuPGxpPkEgPGEgaHJlZj1cXFwiI3NlcnZlci1zaWRlLWFwaVxcXCI+c2VydmVyLXNpZGUgQVBJPC9hPiB0aGF0IGRlYWxzIHdpdGggc2VydmVyLXNpZGUgcmVuZGVyaW5nPHVsPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy10YXVudXMtbW91bnQtYWRkcm91dGUtb3B0aW9ucy1cXFwiPjxjb2RlPnRhdW51cy5tb3VudDwvY29kZT48L2E+IG1ldGhvZDx1bD5cXG48bGk+SXRzIDxhIGhyZWY9XFxcIiN0aGUtb3B0aW9ucy1vYmplY3RcXFwiPjxjb2RlPm9wdGlvbnM8L2NvZGU+PC9hPiBhcmd1bWVudDx1bD5cXG48bGk+PGEgaHJlZj1cXFwiIy1vcHRpb25zLWxheW91dC1cXFwiPjxjb2RlPmxheW91dDwvY29kZT48L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiIy1vcHRpb25zLXJvdXRlcy1cXFwiPjxjb2RlPnJvdXRlczwvY29kZT48L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiIy1vcHRpb25zLWdldGRlZmF1bHR2aWV3bW9kZWwtXFxcIj48Y29kZT5nZXREZWZhdWx0Vmlld01vZGVsPC9jb2RlPjwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjLW9wdGlvbnMtcGxhaW50ZXh0LVxcXCI+PGNvZGU+cGxhaW50ZXh0PC9jb2RlPjwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjLW9wdGlvbnMtcmVzb2x2ZXJzLVxcXCI+PGNvZGU+cmVzb2x2ZXJzPC9jb2RlPjwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjLW9wdGlvbnMtdmVyc2lvbi1cXFwiPjxjb2RlPnZlcnNpb248L2NvZGU+PC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiMtb3B0aW9ucy1kZWZlcm1pbmlmaWVkLVxcXCI+PGNvZGU+ZGVmZXJNaW5pZmllZDwvY29kZT48L2E+PC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPkl0cyA8YSBocmVmPVxcXCIjLWFkZHJvdXRlLWRlZmluaXRpb24tXFxcIj48Y29kZT5hZGRSb3V0ZTwvY29kZT48L2E+IGFyZ3VtZW50PC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXRhdW51cy1yZW5kZXItYWN0aW9uLXZpZXdtb2RlbC1yZXEtcmVzLW5leHQtXFxcIj48Y29kZT50YXVudXMucmVuZGVyPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXJlc29sdmUtYWN0aW9uLWRhdGEtXFxcIj48Y29kZT50YXVudXMucmVzb2x2ZTwvY29kZT48L2E+IG1ldGhvZDwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXRhdW51cy1yZWRpcmVjdC1yZXEtcmVzLXVybC1cXFwiPjxjb2RlPnRhdW51cy5yZWRpcmVjdDwvY29kZT48L2E+IG1ldGhvZDwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXRhdW51cy1yZWJ1aWxkZGVmYXVsdHZpZXdtb2RlbC1kb25lLVxcXCI+PGNvZGU+dGF1bnVzLnJlYnVpbGREZWZhdWx0Vmlld01vZGVsPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiNzZXJ2ZXItc2lkZS1jb250cm9sbGVyc1xcXCI+U2VydmVyLXNpZGUgY29udHJvbGxlcnM8L2E+PC9saT5cXG48bGk+QSA8YSBocmVmPVxcXCIjaHR0cC1mcmFtZXdvcmstcGx1Z2luc1xcXCI+c3VpdGUgb2YgcGx1Z2luczwvYT4gY2FuIGludGVncmF0ZSBUYXVudXMgYW5kIGFuIEhUVFAgc2VydmVyPHVsPlxcbjxsaT5Vc2luZyA8YSBocmVmPVxcXCIjdXNpbmctdGF1bnVzLWV4cHJlc3MtXFxcIj48Y29kZT50YXVudXMtZXhwcmVzczwvY29kZT48L2E+IGZvciA8YSBocmVmPVxcXCJodHRwOi8vZXhwcmVzc2pzLmNvbVxcXCI+RXhwcmVzczwvYT48L2xpPlxcbjxsaT5Vc2luZyA8YSBocmVmPVxcXCIjdXNpbmctdGF1bnVzLWhhcGktXFxcIj48Y29kZT50YXVudXMtaGFwaTwvY29kZT48L2E+IGZvciA8YSBocmVmPVxcXCJodHRwOi8vaGFwaWpzLmNvbVxcXCI+SGFwaTwvYT48L2xpPlxcbjwvdWw+XFxuPC9saT5cXG48bGk+QSA8YSBocmVmPVxcXCIjY29tbWFuZC1saW5lLWludGVyZmFjZVxcXCI+Q0xJIHRoYXQgcHJvZHVjZXMgYSB3aXJpbmcgbW9kdWxlPC9hPiBmb3IgdGhlIGNsaWVudC1zaWRlPHVsPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy1vdXRwdXQtXFxcIj48Y29kZT4tLW91dHB1dDwvY29kZT48L2E+IGZsYWc8L2xpPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy13YXRjaC1cXFwiPjxjb2RlPi0td2F0Y2g8L2NvZGU+PC9hPiBmbGFnPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdHJhbnNmb3JtLW1vZHVsZS1cXFwiPjxjb2RlPi0tdHJhbnNmb3JtICZsdDttb2R1bGUmZ3Q7PC9jb2RlPjwvYT4gZmxhZzwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLWRlZmVyLWFjdGlvbnMtXFxcIj48Y29kZT4tLWRlZmVyPC9jb2RlPjwvYT4gZmxhZzwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXJlc29sdmVycy1tb2R1bGUtXFxcIj48Y29kZT4tLXJlc29sdmVycyAmbHQ7bW9kdWxlJmd0OzwvY29kZT48L2E+IGZsYWc8L2xpPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy1idW5kbGUtXFxcIj48Y29kZT4tLWJ1bmRsZTwvY29kZT48L2E+IGZsYWc8L2xpPlxcbjwvdWw+XFxuPC9saT5cXG48bGk+QSA8YSBocmVmPVxcXCIjY2xpZW50LXNpZGUtYXBpXFxcIj5jbGllbnQtc2lkZSBBUEk8L2E+IHRoYXQgZGVhbHMgd2l0aCBjbGllbnQtc2lkZSByZW5kZXJpbmc8dWw+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXRhdW51cy1tb3VudC1jb250YWluZXItd2lyaW5nLW9wdGlvbnMtXFxcIj48Y29kZT50YXVudXMubW91bnQ8L2NvZGU+PC9hPiBtZXRob2Q8dWw+XFxuPGxpPlVzaW5nIHRoZSA8YSBocmVmPVxcXCIjdXNpbmctdGhlLWF1dG8tc3RyYXRlZ3lcXFwiPjxjb2RlPmF1dG88L2NvZGU+PC9hPiBzdHJhdGVneTwvbGk+XFxuPGxpPlVzaW5nIHRoZSA8YSBocmVmPVxcXCIjdXNpbmctdGhlLWlubGluZS1zdHJhdGVneVxcXCI+PGNvZGU+aW5saW5lPC9jb2RlPjwvYT4gc3RyYXRlZ3k8L2xpPlxcbjxsaT5Vc2luZyB0aGUgPGEgaHJlZj1cXFwiI3VzaW5nLXRoZS1tYW51YWwtc3RyYXRlZ3lcXFwiPjxjb2RlPm1hbnVhbDwvY29kZT48L2E+IHN0cmF0ZWd5PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI2NhY2hpbmdcXFwiPkNhY2hpbmc8L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI3ByZWZldGNoaW5nXFxcIj5QcmVmZXRjaGluZzwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjdmVyc2lvbmluZ1xcXCI+VmVyc2lvbmluZzwvYT48L2xpPlxcbjwvdWw+XFxuPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLW9uLXR5cGUtZm4tXFxcIj48Y29kZT50YXVudXMub248L2NvZGU+PC9hPiBtZXRob2Q8L2xpPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy10YXVudXMtb25jZS10eXBlLWZuLVxcXCI+PGNvZGU+dGF1bnVzLm9uY2U8L2NvZGU+PC9hPiBtZXRob2Q8L2xpPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy10YXVudXMtb2ZmLXR5cGUtZm4tXFxcIj48Y29kZT50YXVudXMub2ZmPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLWludGVyY2VwdC1hY3Rpb24tZm4tXFxcIj48Y29kZT50YXVudXMuaW50ZXJjZXB0PC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXBhcnRpYWwtY29udGFpbmVyLWFjdGlvbi1tb2RlbC1cXFwiPjxjb2RlPnRhdW51cy5wYXJ0aWFsPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLW5hdmlnYXRlLXVybC1vcHRpb25zLVxcXCI+PGNvZGU+dGF1bnVzLm5hdmlnYXRlPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXJvdXRlLXVybC1zdGFydGluZGV4LVxcXCI+PGNvZGU+dGF1bnVzLnJvdXRlPC9jb2RlPjwvYT4gbWV0aG9kPHVsPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy10YXVudXMtcm91dGUtZXF1YWxzLXJvdXRlLXJvdXRlLVxcXCI+PGNvZGU+dGF1bnVzLnJvdXRlLmVxdWFsczwvY29kZT48L2E+IG1ldGhvZDwvbGk+XFxuPC91bD5cXG48L2xpPlxcbjxsaT5UaGUgPGEgaHJlZj1cXFwiIy10YXVudXMtcmVzb2x2ZS1vbi10aGUtY2xpZW50XFxcIj48Y29kZT50YXVudXMucmVzb2x2ZTwvY29kZT48L2E+IG1ldGhvZDwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjLXRhdW51cy1zdGF0ZS1cXFwiPjxjb2RlPnRhdW51cy5zdGF0ZTwvY29kZT48L2E+IHByb3BlcnR5PC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXhoci11cmwtb3B0aW9ucy1kb25lLVxcXCI+PGNvZGU+dGF1bnVzLnhocjwvY29kZT48L2E+IG1ldGhvZDwvbGk+XFxuPGxpPlRoZSA8YSBocmVmPVxcXCIjdXNpbmctdGF1bnVzLXByZWZldGNoLXVybC1lbGVtZW50LVxcXCI+PGNvZGU+dGF1bnVzLnByZWZldGNoPC9jb2RlPjwvYT4gbWV0aG9kPC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI2RlYnVnZ2luZy10YXVudXNcXFwiPkRlYnVnZ2luZyBUYXVudXM8L2E+PC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiNjbGllbnQtc2lkZS1jb250cm9sbGVyc1xcXCI+Q2xpZW50LXNpZGUgY29udHJvbGxlcnM8L2E+PC9saT5cXG48bGk+VGhlIDxhIGhyZWY9XFxcIiN0aGUtdGF1bnVzcmMtbWFuaWZlc3RcXFwiPjxjb2RlPi50YXVudXNyYzwvY29kZT48L2E+IG1hbmlmZXN0PC9saT5cXG48L3VsPlxcbjxoMSBpZD1cXFwic2VydmVyLXNpZGUtYXBpXFxcIj5TZXJ2ZXItc2lkZSBBUEk8L2gxPlxcbjxwPlRoZSBzZXJ2ZXItc2lkZSBBUEkgaXMgdXNlZCB0byBzZXQgdXAgdGhlIHZpZXcgcm91dGVyLiBJdCB0aGVuIGdldHMgb3V0IG9mIHRoZSB3YXksIGFsbG93aW5nIHRoZSBjbGllbnQtc2lkZSB0byBldmVudHVhbGx5IHRha2Ugb3ZlciBhbmQgYWRkIGFueSBleHRyYSBzdWdhciBvbiB0b3AsIDxlbT5pbmNsdWRpbmcgY2xpZW50LXNpZGUgcmVuZGVyaW5nPC9lbT4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiLXRhdW51cy1tb3VudC1hZGRyb3V0ZS1vcHRpb25zLVxcXCI+PGNvZGU+dGF1bnVzLm1vdW50KGFkZFJvdXRlLCBvcHRpb25zPyk8L2NvZGU+PC9oMj5cXG48cD5Nb3VudHMgVGF1bnVzIG9uIHRvcCBvZiBhIHNlcnZlci1zaWRlIHJvdXRlciwgYnkgcmVnaXN0ZXJpbmcgZWFjaCByb3V0ZSBpbiA8Y29kZT5vcHRpb25zLnJvdXRlczwvY29kZT4gd2l0aCB0aGUgPGNvZGU+YWRkUm91dGU8L2NvZGU+IG1ldGhvZC48L3A+XFxuPGJsb2NrcXVvdGU+XFxuPHA+Tm90ZSB0aGF0IG1vc3Qgb2YgdGhlIHRpbWUsIDxzdHJvbmc+dGhpcyBtZXRob2Qgc2hvdWxkbiYjMzk7dCBiZSBpbnZva2VkIGRpcmVjdGx5PC9zdHJvbmc+LCBidXQgcmF0aGVyIHRocm91Z2ggb25lIG9mIHRoZSA8YSBocmVmPVxcXCIjaHR0cC1mcmFtZXdvcmstcGx1Z2luc1xcXCI+SFRUUCBmcmFtZXdvcmsgcGx1Z2luczwvYT4gcHJlc2VudGVkIGJlbG93LjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+SGVyZSYjMzk7cyBhbiBpbmNvbXBsZXRlIGV4YW1wbGUgb2YgaG93IHRoaXMgbWV0aG9kIG1heSBiZSB1c2VkLiBJdCBpcyBpbmNvbXBsZXRlIGJlY2F1c2Ugcm91dGUgZGVmaW5pdGlvbnMgaGF2ZSBtb3JlIG9wdGlvbnMgYmV5b25kIHRoZSA8Y29kZT5yb3V0ZTwvY29kZT4gYW5kIDxjb2RlPmFjdGlvbjwvY29kZT4gcHJvcGVydGllcy48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxudGF1bnVzLm1vdW50KGFkZFJvdXRlLCB7XFxuICByb3V0ZXM6IFt7IHJvdXRlOiAmIzM5Oy8mIzM5OywgYWN0aW9uOiAmIzM5O2hvbWUvaW5kZXgmIzM5OyB9XVxcbn0pO1xcblxcbmZ1bmN0aW9uIGFkZFJvdXRlIChkZWZpbml0aW9uKSB7XFxuICBhcHAuZ2V0KGRlZmluaXRpb24ucm91dGUsIGRlZmluaXRpb24uYWN0aW9uKTtcXG59XFxuPC9jb2RlPjwvcHJlPlxcbjxwPkxldCYjMzk7cyBnbyBvdmVyIHRoZSBvcHRpb25zIHlvdSBjYW4gcGFzcyB0byA8Y29kZT50YXVudXMubW91bnQ8L2NvZGU+IGZpcnN0LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcInRoZS1vcHRpb25zLW9iamVjdFxcXCI+VGhlIDxjb2RlPm9wdGlvbnM/PC9jb2RlPiBvYmplY3Q8L2g0PlxcbjxwPlRoZXJlJiMzOTtzIGEgZmV3IG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBzZXJ2ZXItc2lkZSBtb3VudHBvaW50LiBZb3UmIzM5O3JlIHByb2JhYmx5IGdvaW5nIHRvIGJlIHBhc3NpbmcgdGhlc2UgdG8geW91ciA8YSBocmVmPVxcXCIjaHR0cC1mcmFtZXdvcmstcGx1Z2luc1xcXCI+SFRUUCBmcmFtZXdvcmsgcGx1Z2luPC9hPiwgcmF0aGVyIHRoYW4gdXNpbmcgPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPiBkaXJlY3RseS48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy1sYXlvdXQtXFxcIj48Y29kZT5vcHRpb25zLmxheW91dD88L2NvZGU+PC9oNj5cXG48cD5UaGUgPGNvZGU+bGF5b3V0PC9jb2RlPiBwcm9wZXJ0eSBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSA8Y29kZT5mdW5jdGlvbihkYXRhKTwvY29kZT4gc2lnbmF0dXJlLiBJdCYjMzk7bGwgYmUgaW52b2tlZCB3aGVuZXZlciBhIGZ1bGwgSFRNTCBkb2N1bWVudCBuZWVkcyB0byBiZSByZW5kZXJlZCwgYW5kIGEgPGNvZGU+ZGF0YTwvY29kZT4gb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRvIGl0LiBUaGF0IG9iamVjdCB3aWxsIGNvbnRhaW4gZXZlcnl0aGluZyB5b3UmIzM5O3ZlIHNldCBhcyB0aGUgdmlldyBtb2RlbCwgcGx1cyBhIDxjb2RlPnBhcnRpYWw8L2NvZGU+IHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHJhdyBIVE1MIG9mIHRoZSByZW5kZXJlZCBwYXJ0aWFsIHZpZXcuIFlvdXIgPGNvZGU+bGF5b3V0PC9jb2RlPiBtZXRob2Qgd2lsbCB0eXBpY2FsbHkgd3JhcCB0aGUgcmF3IEhUTUwgZm9yIHRoZSBwYXJ0aWFsIHdpdGggdGhlIGJhcmUgYm9uZXMgb2YgYW4gSFRNTCBkb2N1bWVudC4gQ2hlY2sgb3V0IDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9wb255Zm9vL3Bvbnlmb28vYmxvYi8zMzI3MTc1MTMxMmRiNmU5MjA1OWQ5ODI5M2QwYTdhYzZlOWU4ZTViL3ZpZXdzL3NlcnZlci9sYXlvdXQvbGF5b3V0LmphZGVcXFwiPnRoZSA8Y29kZT5sYXlvdXQuamFkZTwvY29kZT4gdXNlZCBpbiBQb255IEZvbzwvYT4gYXMgYW4gZXhhbXBsZS48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy1yb3V0ZXMtXFxcIj48Y29kZT5vcHRpb25zLnJvdXRlczwvY29kZT48L2g2PlxcbjxwPlRoZSBvdGhlciBiaWcgb3B0aW9uIGlzIDxjb2RlPnJvdXRlczwvY29kZT4sIHdoaWNoIGV4cGVjdHMgYSBjb2xsZWN0aW9uIG9mIHJvdXRlIGRlZmluaXRpb25zLiBSb3V0ZSBkZWZpbml0aW9ucyB1c2UgYSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBkZXRlcm1pbmUgaG93IHRoZSByb3V0ZSBpcyBnb2luZyB0byBiZWhhdmUuPC9wPlxcbjxwPkhlcmUmIzM5O3MgYW4gZXhhbXBsZSByb3V0ZSB0aGF0IHVzZXMgdGhlIDxhIGhyZWY9XFxcImh0dHA6Ly9leHByZXNzanMuY29tXFxcIj5FeHByZXNzPC9hPiByb3V0aW5nIHNjaGVtZS48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+e1xcbiAgcm91dGU6ICYjMzk7L2FydGljbGVzLzpzbHVnJiMzOTssXFxuICBhY3Rpb246ICYjMzk7YXJ0aWNsZXMvYXJ0aWNsZSYjMzk7LFxcbiAgaWdub3JlOiBmYWxzZSxcXG4gIGNhY2hlOiAmbHQ7aW5oZXJpdCZndDtcXG59XFxuPC9jb2RlPjwvcHJlPlxcbjx1bD5cXG48bGk+PGNvZGU+cm91dGU8L2NvZGU+IGlzIGEgcm91dGUgaW4gdGhlIGZvcm1hdCB5b3VyIEhUVFAgZnJhbWV3b3JrIG9mIGNob2ljZSB1bmRlcnN0YW5kczwvbGk+XFxuPGxpPjxjb2RlPmFjdGlvbjwvY29kZT4gaXMgdGhlIG5hbWUgb2YgeW91ciBjb250cm9sbGVyIGFjdGlvbi4gSXQmIzM5O2xsIGJlIHVzZWQgdG8gZmluZCB0aGUgc2VydmVyLXNpZGUgY29udHJvbGxlciwgdGhlIGRlZmF1bHQgdmlldyB0aGF0IHNob3VsZCBiZSB1c2VkIHdpdGggdGhpcyByb3V0ZSwgYW5kIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyPC9saT5cXG48bGk+PGNvZGU+Y2FjaGU8L2NvZGU+IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2xpZW50LXNpZGUgY2FjaGluZyBiZWhhdmlvciBpbiB0aGlzIGFwcGxpY2F0aW9uIHBhdGgsIGFuZCBpdCYjMzk7bGwgZGVmYXVsdCB0byBpbmhlcml0aW5nIGZyb20gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gPGVtPm9uIHRoZSBjbGllbnQtc2lkZTwvZW0+PC9saT5cXG48bGk+PGNvZGU+aWdub3JlPC9jb2RlPiBpcyB1c2VkIGluIHRob3NlIGNhc2VzIHdoZXJlIHlvdSB3YW50IGEgVVJMIHRvIGJlIGlnbm9yZWQgYnkgdGhlIGNsaWVudC1zaWRlIHJvdXRlciBldmVuIGlmIHRoZXJlJiMzOTtzIGEgY2F0Y2gtYWxsIHJvdXRlIHRoYXQgd291bGQgbWF0Y2ggdGhhdCBVUkw8L2xpPlxcbjwvdWw+XFxuPHA+QXMgYW4gZXhhbXBsZSBvZiB0aGUgPGNvZGU+aWdub3JlPC9jb2RlPiB1c2UgY2FzZSwgY29uc2lkZXIgdGhlIHJvdXRpbmcgdGFibGUgc2hvd24gYmVsb3cuIFRoZSBjbGllbnQtc2lkZSByb3V0ZXIgZG9lc24mIzM5O3Qga25vdyA8ZW0+KGFuZCBjYW4mIzM5O3Qga25vdyB1bmxlc3MgeW91IHBvaW50IGl0IG91dCk8L2VtPiB3aGF0IHJvdXRlcyBhcmUgc2VydmVyLXNpZGUgb25seSwgYW5kIGl0JiMzOTtzIHVwIHRvIHlvdSB0byBwb2ludCB0aG9zZSBvdXQuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPltcXG4gIHsgcm91dGU6ICYjMzk7LyYjMzk7LCBhY3Rpb246ICYjMzk7L2hvbWUvaW5kZXgmIzM5OyB9LFxcbiAgeyByb3V0ZTogJiMzOTsvZmVlZCYjMzk7LCBpZ25vcmU6IHRydWUgfSxcXG4gIHsgcm91dGU6ICYjMzk7LyomIzM5OywgYWN0aW9uOiAmIzM5O2Vycm9yL25vdC1mb3VuZCYjMzk7IH1cXG5dXFxuPC9jb2RlPjwvcHJlPlxcbjxwPlRoaXMgc3RlcCBpcyBuZWNlc3Nhcnkgd2hlbmV2ZXIgeW91IGhhdmUgYW4gYW5jaG9yIGxpbmsgcG9pbnRlZCBhdCBzb21ldGhpbmcgbGlrZSBhbiBSU1MgZmVlZC4gVGhlIDxjb2RlPmlnbm9yZTwvY29kZT4gcHJvcGVydHkgaXMgZWZmZWN0aXZlbHkgdGVsbGluZyB0aGUgY2xpZW50LXNpZGUgPGVtPiZxdW90O2RvbiYjMzk7dCBoaWphY2sgbGlua3MgY29udGFpbmluZyB0aGlzIFVSTCZxdW90OzwvZW0+LjwvcD5cXG48cD5QbGVhc2Ugbm90ZSB0aGF0IGV4dGVybmFsIGxpbmtzIGFyZSBuZXZlciBoaWphY2tlZC4gT25seSBzYW1lLW9yaWdpbiBsaW5rcyBjb250YWluaW5nIGEgVVJMIHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlIHJvdXRlcyB3aWxsIGJlIGhpamFja2VkIGJ5IFRhdW51cy4gRXh0ZXJuYWwgbGlua3MgZG9uJiMzOTt0IG5lZWQgdG8gYmUgPGNvZGU+aWdub3JlPC9jb2RlPmQuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNiBpZD1cXFwiLW9wdGlvbnMtZ2V0ZGVmYXVsdHZpZXdtb2RlbC1cXFwiPjxjb2RlPm9wdGlvbnMuZ2V0RGVmYXVsdFZpZXdNb2RlbD88L2NvZGU+PC9oNj5cXG48cD5UaGUgPGNvZGU+Z2V0RGVmYXVsdFZpZXdNb2RlbChkb25lKTwvY29kZT4gcHJvcGVydHkgY2FuIGJlIGEgbWV0aG9kIHRoYXQgcHV0cyB0b2dldGhlciB0aGUgYmFzZSB2aWV3IG1vZGVsLCB3aGljaCB3aWxsIHRoZW4gYmUgZXh0ZW5kZWQgb24gYW4gYWN0aW9uLWJ5LWFjdGlvbiBiYXNpcy4gV2hlbiB5b3UmIzM5O3JlIGRvbmUgY3JlYXRpbmcgYSB2aWV3IG1vZGVsLCB5b3UgY2FuIGludm9rZSA8Y29kZT5kb25lKG51bGwsIG1vZGVsKTwvY29kZT4uIElmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBidWlsZGluZyB0aGUgdmlldyBtb2RlbCwgeW91IHNob3VsZCBjYWxsIDxjb2RlPmRvbmUoZXJyKTwvY29kZT4gaW5zdGVhZC48L3A+XFxuPHA+VGF1bnVzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgPGNvZGU+ZG9uZTwvY29kZT4gaXMgaW52b2tlZCB3aXRoIGFuIGVycm9yLCBzbyB5b3UgbWlnaHQgd2FudCB0byBwdXQgc2FmZWd1YXJkcyBpbiBwbGFjZSBhcyB0byBhdm9pZCB0aGF0IGZyb20gaGFwcGVubmluZy4gVGhlIHJlYXNvbiB0aGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgaXMgYmVjYXVzZSB5b3UgbWF5IG5lZWQgZGF0YWJhc2UgYWNjZXNzIG9yIHNvbWVzdWNoIHdoZW4gcHV0dGluZyB0b2dldGhlciB0aGUgZGVmYXVsdHMuIFRoZSByZWFzb24gdGhpcyBpcyBhIG1ldGhvZCBhbmQgbm90IGp1c3QgYW4gb2JqZWN0IGlzIHRoYXQgdGhlIGRlZmF1bHRzIG1heSBjaGFuZ2UgZHVlIHRvIGh1bWFuIGludGVyYWN0aW9uIHdpdGggdGhlIGFwcGxpY2F0aW9uLCBhbmQgaW4gdGhvc2UgY2FzZXMgPGEgaHJlZj1cXFwiI3RhdW51cy1yZWJ1aWxkZGVmYXVsdHZpZXdtb2RlbFxcXCI+dGhlIGRlZmF1bHRzIGNhbiBiZSByZWJ1aWx0PC9hPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy1wbGFpbnRleHQtXFxcIj48Y29kZT5vcHRpb25zLnBsYWludGV4dD88L2NvZGU+PC9oNj5cXG48cD5UaGUgPGNvZGU+cGxhaW50ZXh0PC9jb2RlPiBvcHRpb25zIG9iamVjdCBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2hnZXRcXFwiPmhnZXQ8L2E+LCBhbmQgaXQmIzM5O3MgdXNlZCB0byA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vcG9ueWZvby9wb255Zm9vL2Jsb2IvZjZkNmI1MDY4ZmYwM2EzODdmNTAzOTAwMTYwZDlmZGMxZTc0OTc1MC9jb250cm9sbGVycy9yb3V0aW5nLmpzI0w3MC1MNzJcXFwiPnR3ZWFrIHRoZSBwbGFpbnRleHQgdmVyc2lvbjwvYT4gb2YgeW91ciBzaXRlLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDYgaWQ9XFxcIi1vcHRpb25zLXJlc29sdmVycy1cXFwiPjxjb2RlPm9wdGlvbnMucmVzb2x2ZXJzPzwvY29kZT48L2g2PlxcbjxwPlJlc29sdmVycyBhcmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGxvY2F0aW9uIG9mIHNvbWUgb2YgdGhlIGRpZmZlcmVudCBwaWVjZXMgb2YgeW91ciBhcHBsaWNhdGlvbi4gVHlwaWNhbGx5IHlvdSB3b24mIzM5O3QgaGF2ZSB0byB0b3VjaCB0aGVzZSBpbiB0aGUgc2xpZ2h0ZXN0LjwvcD5cXG48dGFibGU+XFxuPHRoZWFkPlxcbjx0cj5cXG48dGg+U2lnbmF0dXJlPC90aD5cXG48dGg+RGVzY3JpcHRpb248L3RoPlxcbjwvdHI+XFxuPC90aGVhZD5cXG48dGJvZHk+XFxuPHRyPlxcbjx0ZD48Y29kZT5nZXRTZXJ2ZXJDb250cm9sbGVyKGFjdGlvbik8L2NvZGU+PC90ZD5cXG48dGQ+UmV0dXJuIHBhdGggdG8gc2VydmVyLXNpZGUgY29udHJvbGxlciBhY3Rpb24gaGFuZGxlciBtb2R1bGU8L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT5nZXRWaWV3KGFjdGlvbik8L2NvZGU+PC90ZD5cXG48dGQ+UmV0dXJuIHBhdGggdG8gdmlldyB0ZW1wbGF0ZSBtb2R1bGU8L3RkPlxcbjwvdHI+XFxuPC90Ym9keT5cXG48L3RhYmxlPlxcbjxwPlRoZSA8Y29kZT5hZGRSb3V0ZTwvY29kZT4gbWV0aG9kIHBhc3NlZCB0byA8Y29kZT50YXVudXMubW91bnQ8L2NvZGU+IG9uIHRoZSBzZXJ2ZXItc2lkZSBpcyBtb3N0bHkgZ29pbmcgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBIVFRQIGZyYW1ld29yayBwbHVnaW5zLCBzbyBmZWVsIGZyZWUgdG8gc2tpcCBvdmVyIHRoZSBmb2xsb3dpbmcgc2VjdGlvbi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy12ZXJzaW9uLVxcXCI+PGNvZGU+b3B0aW9ucy52ZXJzaW9uPzwvY29kZT48L2g2PlxcbjxwPlJlZmVyIHRvIHRoZSA8YSBocmVmPVxcXCIjdmVyc2lvbmluZ1xcXCI+VmVyc2lvbmluZzwvYT4gc2VjdGlvbi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy1nZXRwYXJ0aWFsLVxcXCI+PGNvZGU+b3B0aW9ucy5nZXRQYXJ0aWFsPzwvY29kZT48L2g2PlxcbjxwPkJ5IGRlZmF1bHQsIFRhdW51cyB3aWxsIHJlbmRlciBwYXJ0aWFscyBvbiB0aGUgc2VydmVyLXNpZGUgYnkgbG9va2luZyB1cCB0aGUgbW9kdWxlIGZvciBhbiBhY3Rpb24gbWV0aG9kLCBhbmQgY2FsbGluZyB0aGF0IGFjdGlvbiBwYXNzaW5nIGluIGEgbW9kZWwuPC9wPlxcbjxwPllvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgYnkgc2V0dGluZyA8Y29kZT5vcHRpb25zLmdldFBhcnRpYWw8L2NvZGU+IHRvIGEgZnVuY3Rpb24uIFRoaXMgbWV0aG9kIHRha2VzIHRocmVlIHBhcmFtZXRlcnMuPC9wPlxcbjx1bD5cXG48bGk+PGNvZGU+YWN0aW9uPC9jb2RlPiBpcyB0aGUgYWN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgcmVuZGVyZWQ8L2xpPlxcbjxsaT48Y29kZT5tb2RlbDwvY29kZT4gaXMgdGhlIG1vZGVsIHlvdSBjYW4gdXNlIHRvIHJlbmRlciB0aGUgdmlldyBmb3IgdGhhdCBhY3Rpb248L2xpPlxcbjxsaT48Y29kZT5kb25lKGVyciwgaHRtbCk8L2NvZGU+IGlzIGNhbGxlZCB3aGVuIHlvdSYjMzk7cmUgZG9uZSwgcGFzc2luZyBpbiB0aGUgcmVzdWx0aW5nIDxjb2RlPmh0bWw8L2NvZGU+IGZvciB0aGUgcGFydGlhbDwvbGk+XFxuPC91bD5cXG48cD5Ob3RlIHRoYXQgaWYgeW91IGRvbiYjMzk7dCBzZXQgPGNvZGU+Z2V0UGFydGlhbDwvY29kZT4sIFRhdW51cyB3aWxsIGp1c3QgcmVxdWlyZSB5b3VyIGNvbnRyb2xsZXIgYWN0aW9uIG1ldGhvZCBhbmQgaW52b2tlIHRoYXQgaW5zdGVhZC48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg2IGlkPVxcXCItb3B0aW9ucy1kZWZlcm1pbmlmaWVkLVxcXCI+PGNvZGU+b3B0aW9ucy5kZWZlck1pbmlmaWVkPzwvY29kZT48L2g2PlxcbjxwPldoZW4gdmlld3MgYW5kIGNvbnRyb2xsZXJzIGFyZSBsYXppbHkgbG9hZGVkLCB0aGV5IGFyZSBjb21waWxlZCBhbmQgYnVuZGxlZCB1c2luZyBCcm93c2VyaWZ5LiBUYXVudXMgd2lsbCBldmVuIHByb2R1Y2UgYSBzb3VyY2UgbWFwLiBUbyBhdm9pZCB0aGUgc291cmNlIG1hcCwgYW5kIG1pbmlmeSB0aGUgYnVuZGxlIGluc3RlYWQsIHNldCA8Y29kZT5kZWZlck1pbmlmaWVkPC9jb2RlPiB0byA8Y29kZT50cnVlPC9jb2RlPi48L3A+XFxuPHA+WW91JiMzOTtsbCBwcm9iYWJseSB3YW50IHRvIHNldCA8Y29kZT5kZWZlck1pbmlmaWVkPC9jb2RlPiB0byB3aGV0aGVyIHRoZSBhcHBsaWNhdGlvbiBpcyBydW5uaW5nIG9uIHRoZSBwcm9kdWN0aW9uIGVudmlyb25tZW50LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcIi1hZGRyb3V0ZS1kZWZpbml0aW9uLVxcXCI+PGNvZGU+YWRkUm91dGUoZGVmaW5pdGlvbik8L2NvZGU+PC9oND5cXG48cD5UaGUgPGNvZGU+YWRkUm91dGUoZGVmaW5pdGlvbik8L2NvZGU+IG1ldGhvZCB3aWxsIGJlIHBhc3NlZCBhIHJvdXRlIGRlZmluaXRpb24sIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLiBUaGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0byByZWdpc3RlciBhIHJvdXRlIGluIHlvdXIgSFRUUCBmcmFtZXdvcmsmIzM5O3Mgcm91dGVyLjwvcD5cXG48dWw+XFxuPGxpPjxjb2RlPnJvdXRlPC9jb2RlPiBpcyB0aGUgcm91dGUgdGhhdCB5b3Ugc2V0IGFzIDxjb2RlPmRlZmluaXRpb24ucm91dGU8L2NvZGU+PC9saT5cXG48bGk+PGNvZGU+YWN0aW9uPC9jb2RlPiBpcyB0aGUgYWN0aW9uIGFzIHBhc3NlZCB0byB0aGUgcm91dGUgZGVmaW5pdGlvbjwvbGk+XFxuPGxpPjxjb2RlPmFjdGlvbkZuPC9jb2RlPiB3aWxsIGJlIHRoZSBjb250cm9sbGVyIGZvciB0aGlzIGFjdGlvbiBtZXRob2Q8L2xpPlxcbjxsaT48Y29kZT5taWRkbGV3YXJlPC9jb2RlPiB3aWxsIGJlIGFuIGFycmF5IG9mIG1ldGhvZHMgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIDxjb2RlPmFjdGlvbkZuPC9jb2RlPjwvbGk+XFxuPC91bD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtcmVuZGVyLWFjdGlvbi12aWV3bW9kZWwtcmVxLXJlcy1uZXh0LVxcXCI+PGNvZGU+dGF1bnVzLnJlbmRlcihhY3Rpb24sIHZpZXdNb2RlbCwgcmVxLCByZXMsIG5leHQpPC9jb2RlPjwvaDI+XFxuPHA+VGhpcyBtZXRob2QgaXMgYWxtb3N0IGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhcyB5b3Ugc2hvdWxkIGJlIHVzaW5nIFRhdW51cyB0aHJvdWdoIG9uZSBvZiB0aGUgcGx1Z2lucyBhbnl3YXlzLCBzbyB3ZSB3b24mIzM5O3QgZ28gdmVyeSBkZWVwIGludG8gaXQuPC9wPlxcbjxwPlRoZSByZW5kZXIgbWV0aG9kIGlzIHdoYXQgVGF1bnVzIHVzZXMgdG8gcmVuZGVyIHZpZXdzIGJ5IGNvbnN0cnVjdGluZyBIVE1MLCBKU09OLCBvciBwbGFpbnRleHQgcmVzcG9uc2VzLiBUaGUgPGNvZGU+YWN0aW9uPC9jb2RlPiBwcm9wZXJ0eSBkZXRlcm1pbmVzIHRoZSBkZWZhdWx0IHZpZXcgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLiBUaGUgPGNvZGU+dmlld01vZGVsPC9jb2RlPiB3aWxsIGJlIGV4dGVuZGVkIGJ5IDxhIGhyZWY9XFxcIiMtb3B0aW9ucy1nZXRkZWZhdWx0dmlld21vZGVsLVxcXCI+dGhlIGRlZmF1bHQgdmlldyBtb2RlbDwvYT4sIGFuZCBpdCBtYXkgYWxzbyBvdmVycmlkZSB0aGUgZGVmYXVsdCA8Y29kZT5hY3Rpb248L2NvZGU+IGJ5IHNldHRpbmcgPGNvZGU+dmlld01vZGVsLm1vZGVsLmFjdGlvbjwvY29kZT4uPC9wPlxcbjxwPlRoZSA8Y29kZT5yZXE8L2NvZGU+LCA8Y29kZT5yZXM8L2NvZGU+LCBhbmQgPGNvZGU+bmV4dDwvY29kZT4gYXJndW1lbnRzIGFyZSBleHBlY3RlZCB0byBiZSB0aGUgRXhwcmVzcyByb3V0aW5nIGFyZ3VtZW50cywgYnV0IHRoZXkgY2FuIGFsc28gYmUgbW9ja2VkIDxlbT4od2hpY2ggaXMgaW4gZmFjdCB3aGF0IHRoZSBIYXBpIHBsdWdpbiBkb2VzKTwvZW0+LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtcmVidWlsZGRlZmF1bHR2aWV3bW9kZWwtZG9uZS1cXFwiPjxjb2RlPnRhdW51cy5yZWJ1aWxkRGVmYXVsdFZpZXdNb2RlbChkb25lPyk8L2NvZGU+PC9oMj5cXG48cD5PbmNlIFRhdW51cyBoYXMgYmVlbiBtb3VudGVkLCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgcmVidWlsZCB0aGUgdmlldyBtb2RlbCBkZWZhdWx0cyB1c2luZyB0aGUgPGNvZGU+Z2V0RGVmYXVsdFZpZXdNb2RlbDwvY29kZT4gdGhhdCB3YXMgcGFzc2VkIHRvIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gaW4gdGhlIG9wdGlvbnMuIEFuIG9wdGlvbmFsIDxjb2RlPmRvbmU8L2NvZGU+IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBtb2RlbCBpcyByZWJ1aWx0LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtcmVzb2x2ZS1hY3Rpb24tZGF0YS1cXFwiPjxjb2RlPnRhdW51cy5yZXNvbHZlKGFjdGlvbiwgZGF0YT8pPC9jb2RlPjwvaDI+XFxuPHA+UmV0dXJucyB0aGUgZmlyc3Qgcm91dGUgdGhhdCBtYXRjaGVzIGFuIDxjb2RlPmFjdGlvbjwvY29kZT4sIHJlcGxhY2luZyBuYW1lZCBwYXJhbWV0ZXJzIHdpdGggZGF0YSBmcm9tIHRoZSA8Y29kZT5kYXRhPC9jb2RlPiBvYmplY3QuIElmIGEgbWF0Y2hpbmcgcm91dGUgaXMgbm90IGZvdW5kLCA8Y29kZT5udWxsPC9jb2RlPiBpcyByZXR1cm5lZC48L3A+XFxuPGJsb2NrcXVvdGU+XFxuPHA+SWYgYSByb3V0ZSBpcyBtYXRjaGVkIGJ1dCBhIHJlcXVpcmVkIG5hbWVkIHBhcmFtZXRlciBpc24mIzM5O3QgaW4gPGNvZGU+ZGF0YTwvY29kZT4sIDxzdHJvbmc+YW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duPC9zdHJvbmc+LjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+VGhpcyBtZXRob2QgaXMgbW9zdCB1c2VmdWwgd2hlbiBjb21wb3NpbmcgdGhlIFVSTCBmb3IgYSByZWRpcmVjdCBvciBhbiBhY3Rpb24gbGluayB3aXRoaW4gYSB0ZW1wbGF0ZSwgYXMgYSBtZWFucyB0byBrZWVwIHRoZSByb3V0ZSBkZWNsYXJhdGlvbiBpc29sYXRlZCBmcm9tIHRoZSByb3V0ZSBpdHNlbGYuIElmIHRoZSByb3V0ZSBjaGFuZ2VzLCB0aGUgbWV0aG9kIHdpbGwgcmVmbGVjdCB0aGUgbmV3ZXIgcm91dGUgYXMgbG9uZyBhcyB0aGUgcGFyYW1ldGVycyBzdGF5IHRoZSBzYW1lLCByZXN1bHRpbmcgaW4gaW5jcmVhc2VkIG1haW50YWluYWJpbGl0eS4gPGVtPlRoZSBtZXRob2QgaXMgYXZhaWxhYmxlIGluIGJvdGggbGF5b3V0IHRlbXBsYXRlcyBhbmQgcGFydGlhbCB2aWV3IHRlbXBsYXRlcy48L2VtPjwvcD5cXG48aDYgaWQ9XFxcImV4YW1wbGVcXFwiPkV4YW1wbGU8L2g2PlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPnRhdW51cy5yZXNvbHZlKCYjMzk7cHJvamVjdHMvcHJvamVjdCYjMzk7LCB7XFxuICBuYW1lOiAmIzM5O3B1cHBpZXMmIzM5Oywgb3JnYW5pemF0aW9uOiAmIzM5O2Nhbml1c2UmIzM5O1xcbn0pO1xcbi8vICZsdDstIC9wL2Nhbml1c2UvcHVwcGllc1xcbjwvY29kZT48L3ByZT5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtcmVkaXJlY3QtcmVxLXJlcy11cmwtXFxcIj48Y29kZT50YXVudXMucmVkaXJlY3QocmVxLCByZXMsIHVybCk8L2NvZGU+PC9oMj5cXG48cD5SZWRpcmVjdHMgdGhlIHJlc3BvbnNlIHRvIGEgZGlmZmVyZW50IFVSTC4gSWYgdGhlIHBhZ2Ugd2FzIGJlaW5nIGxvYWRlZCBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gPGNvZGU+cmVzLnJlZGlyZWN0KHVybCk8L2NvZGU+LiBJZiB0aGUgcGFnZSB3YXMgYmVpbmcgbG9hZGVkIHZpYSB0aGUgY2xpZW50LXNpZGUgQUpBWCByb3V0aW5nIGVuZ2luZSwgYSBzcGVjaWFsbHkgY3JhZnRlZCBKU09OIHJlc3BvbnNlIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWxvYWQgb24gdGhlIGNsaWVudC1zaWRlLjwvcD5cXG48aDYgaWQ9XFxcImV4YW1wbGVcXFwiPkV4YW1wbGU8L2g2PlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPnRhdW51cy5yZWRpcmVjdChyZXEsIHJlcywgJiMzOTsvbG9naW4mIzM5Oyk7XFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMSBpZD1cXFwic2VydmVyLXNpZGUtY29udHJvbGxlcnNcXFwiPlNlcnZlci1TaWRlIENvbnRyb2xsZXJzPC9oMT5cXG48cD5PbiB0aGUgc2VydmVyLXNpZGUsIGNvbnRyb2xsZXJzIGFyZSBtb2R1bGVzIHRoYXQgZXhwb3J0IGEgc2luZ2xlIGZ1bmN0aW9uLiBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlc2UgY29udHJvbGxlcnMgZGVwZW5kIG9uIHRoZSBzZXJ2ZXItc2lkZSBIVFRQIGZyYW1ld29yayB0aGF0JiMzOTtzIGJlaW5nIHVzZWQuPC9wPlxcbjxwPkZvciBleGFtcGxlLCBFeHByZXNzIGdpdmVzIHVzIHRocmVlIHBhcmFtZXRlcnM6IDxjb2RlPnJlcTwvY29kZT4sIDxjb2RlPnJlczwvY29kZT4gYW5kIDxjb2RlPm5leHQ8L2NvZGU+LiBIYXBpIGdpdmVzIHVzIHR3byBpbnN0ZWFkOiA8Y29kZT5yZXF1ZXN0PC9jb2RlPiBhbmQgPGNvZGU+cmVwbHk8L2NvZGU+LjwvcD5cXG48cD5IZXJlJiMzOTtzIGEgc2FtcGxlIGNvbnRyb2xsZXIgdXNpbmcgPGNvZGU+dGF1bnVzLWV4cHJlc3M8L2NvZGU+LCBhcyA8YSBocmVmPVxcXCIjdXNpbmctdGF1bnVzLWV4cHJlc3MtXFxcIj5kZXRhaWxlZCBiZWxvdzwvYT4uIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBjb250cm9sbGVyIHdoZXJlIHdlIGFyZSBzZXR0aW5nIHRoZSBzcGVjaWFsIDxjb2RlPnZpZXdNb2RlbDwvY29kZT4gcHJvcGVydHkgb24gdGhlIHJlc3BvbnNlLCBhbmQgY2FsbGluZyA8Y29kZT5uZXh0PC9jb2RlPi4gU3VwcG9zZSB0aGlzIGNvbnRyb2xsZXIgaXMgdGhlIDxjb2RlPnByb2R1Y3QvaG9tZTwvY29kZT4gYWN0aW9uIGhhbmRsZXIuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7XFxuICByZXMudmlld01vZGVsID0ge1xcbiAgICBtb2RlbDoge1xcbiAgICAgIHRpdGxlOiAmIzM5O3ZpZXcgdGl0bGUmIzM5O1xcbiAgICB9XFxuICB9O1xcbiAgbmV4dCgpO1xcbn07XFxuPC9jb2RlPjwvcHJlPlxcbjxwPkFzIHlvdSBjYW4gc2VlLCBUYXVudXMgd29uJiMzOTt0IGFsdGVyIHRoZSBBUEkgcHJvdmlkZWQgYnkgRXhwcmVzcy4gSW5zdGVhZCwgaXQgYnVpbGRzIHVwb24gdGhlIG5vdGlvbiBvZiB1c2luZyBtaWRkbGV3YXJlLiBPbmNlIHRoZSA8Y29kZT5wcm9kdWN0L2hvbWU8L2NvZGU+IHZpZXcgaXMgcmVuZGVyZWQgYW5kIEphdmFTY3JpcHQgbG9hZHMsIHRoZSA8Y29kZT5wcm9kdWN0L2hvbWU8L2NvZGU+IHZpZXcgY29udHJvbGxlciBpcyBleGVjdXRlZCBvbiB0aGUgY2xpZW50LXNpZGUuPC9wPlxcbjxwPllvdSBjb3VsZCBjaGFuZ2UgdGhlIHZpZXcgdG8gYmUgcmVuZGVyZWQgYnkgc2V0dGluZyB0aGUgPGNvZGU+YWN0aW9uPC9jb2RlPiBwcm9wZXJ0eSBvbiB0aGUgPGNvZGU+bW9kZWw8L2NvZGU+LiBJbiB0aGUgZXhhbXBsZSBzaG93biBiZWxvdyB0aGlzIHdvdWxkIG1lYW4gdGhhdCB0aGUgPGNvZGU+ZXJyb3Ivb2ZmbGluZTwvY29kZT4gdmlldyB3b3VsZCBiZSByZW5kZXJlZC4gVGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgd2lsbCBiZSB0aGF0IG9mIDxjb2RlPmVycm9yL29mZmxpbmU8L2NvZGU+LCBhcyB3ZWxsLiBWaWV3IGNvbnRyb2xsZXJzIGFyZSB0aWVkIHRvIHRoZSB2aWV3IHRoYXQgZ2V0cyByZW5kZXJlZC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHtcXG4gIHJlcy52aWV3TW9kZWwgPSB7XFxuICAgIG1vZGVsOiB7XFxuICAgICAgdGl0bGU6ICYjMzk7dmlldyB0aXRsZSYjMzk7XFxuICAgIH1cXG4gIH07XFxuICBpZiAob2ZmbGluZSkge1xcbiAgICByZXMudmlld01vZGVsLm1vZGVsLmFjdGlvbiA9ICYjMzk7ZXJyb3Ivb2ZmbGluZSYjMzk7O1xcbiAgfVxcbiAgbmV4dCgpO1xcbn07XFxuPC9jb2RlPjwvcHJlPlxcbjxwPkhhdmluZyBhIGRlZmF1bHQgYWN0aW9uIGFuZCB0aGUgYWJpbGl0eSB0byByZWRpcmVjdCB0byBhbm90aGVyIGdpdmVzIHVzIGEgbG90IG9mIGZsZXhpYmlsaXR5IHdoZW4gZGV0ZXJtaW5pbmcgaG93IHRvIHJlc3BvbmQgdG8gYSByZXF1ZXN0LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDEgaWQ9XFxcImh0dHAtZnJhbWV3b3JrLXBsdWdpbnNcXFwiPkhUVFAgRnJhbWV3b3JrIFBsdWdpbnM8L2gxPlxcbjxwPlRoZXJlJiMzOTtzIGN1cnJlbnRseSB0d28gZGlmZmVyZW50IEhUVFAgZnJhbWV3b3JrcyA8ZW0+KDxhIGhyZWY9XFxcImh0dHA6Ly9leHByZXNzanMuY29tXFxcIj5FeHByZXNzPC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cDovL2hhcGlqcy5jb21cXFwiPkhhcGk8L2E+KTwvZW0+IHRoYXQgeW91IGNhbiByZWFkaWx5IHVzZSB3aXRoIFRhdW51cyB3aXRob3V0IGhhdmluZyB0byBkZWFsIHdpdGggYW55IG9mIHRoZSByb3V0ZSBwbHVtYmluZyB5b3Vyc2VsZi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCJ1c2luZy10YXVudXMtZXhwcmVzcy1cXFwiPlVzaW5nIDxjb2RlPnRhdW51cy1leHByZXNzPC9jb2RlPjwvaDI+XFxuPHA+VGhlIDxjb2RlPnRhdW51cy1leHByZXNzPC9jb2RlPiBwbHVnaW4gaXMgcHJvYmFibHkgdGhlIGVhc2llc3QgdG8gdXNlLCBhcyBUYXVudXMgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIHdpdGgganVzdCA8YSBocmVmPVxcXCJodHRwOi8vZXhwcmVzc2pzLmNvbVxcXCI+RXhwcmVzczwvYT4gaW4gbWluZC4gSW4gYWRkaXRpb24gdG8gdGhlIG9wdGlvbnMgYWxyZWFkeSBvdXRsaW5lZCBmb3IgPGEgaHJlZj1cXFwiIy10YXVudXMtbW91bnQtYWRkcm91dGUtb3B0aW9ucy1cXFwiPnRhdW51cy5tb3VudDwvYT4sIHlvdSBjYW4gYWRkIG1pZGRsZXdhcmUgZm9yIGFueSByb3V0ZSBpbmRpdmlkdWFsbHkuPC9wPlxcbjx1bD5cXG48bGk+PGNvZGU+bWlkZGxld2FyZTwvY29kZT4gYXJlIGFueSBtZXRob2RzIHlvdSB3YW50IFRhdW51cyB0byBleGVjdXRlIGFzIG1pZGRsZXdhcmUgaW4gRXhwcmVzcyBhcHBsaWNhdGlvbnM8L2xpPlxcbjwvdWw+XFxuPHA+VG8gZ2V0IDxjb2RlPnRhdW51cy1leHByZXNzPC9jb2RlPiBnb2luZyB5b3UgY2FuIHVzZSB0aGUgZm9sbG93aW5nIHBpZWNlIG9mIGNvZGUsIHByb3ZpZGVkIHRoYXQgeW91IGNvbWUgdXAgd2l0aCBhbiA8Y29kZT5vcHRpb25zPC9jb2RlPiBvYmplY3QuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbnZhciB0YXVudXMgPSByZXF1aXJlKCYjMzk7dGF1bnVzJiMzOTspO1xcbnZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgmIzM5O3RhdW51cy1leHByZXNzJiMzOTspO1xcbnZhciBleHByZXNzID0gcmVxdWlyZSgmIzM5O2V4cHJlc3MmIzM5Oyk7XFxudmFyIGFwcCA9IGV4cHJlc3MoKTtcXG52YXIgb3B0aW9ucyA9IHtcXG4gIC8vIC4uLlxcbn07XFxuXFxudGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuPC9jb2RlPjwvcHJlPlxcbjxwPlRoZSA8Y29kZT50YXVudXNFeHByZXNzPC9jb2RlPiBtZXRob2Qgd2lsbCBtZXJlbHkgc2V0IHVwIFRhdW51cyBhbmQgYWRkIHRoZSByZWxldmFudCByb3V0ZXMgdG8geW91ciBFeHByZXNzIGFwcGxpY2F0aW9uIGJ5IGNhbGxpbmcgPGNvZGU+YXBwLmdldDwvY29kZT4gYSBidW5jaCBvZiB0aW1lcy4gWW91IGNhbiA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy1leHByZXNzXFxcIj5maW5kIHRhdW51cy1leHByZXNzIG9uIEdpdEh1YjwvYT4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwidXNpbmctdGF1bnVzLWhhcGktXFxcIj5Vc2luZyA8Y29kZT50YXVudXMtaGFwaTwvY29kZT48L2gyPlxcbjxwPlRoZSA8Y29kZT50YXVudXMtaGFwaTwvY29kZT4gcGx1Z2luIGlzIGEgYml0IG1vcmUgaW52b2x2ZWQsIGFuZCB5b3UmIzM5O2xsIGhhdmUgdG8gY3JlYXRlIGEgUGFjayBpbiBvcmRlciB0byB1c2UgaXQuIEluIGFkZGl0aW9uIHRvIDxhIGhyZWY9XFxcIiMtdGF1bnVzLW1vdW50LWFkZHJvdXRlLW9wdGlvbnMtXFxcIj50aGUgb3B0aW9ucyB3ZSYjMzk7dmUgYWxyZWFkeSBjb3ZlcmVkPC9hPiwgeW91IGNhbiBhZGQgPGNvZGU+Y29uZmlnPC9jb2RlPiBvbiBhbnkgcm91dGUuPC9wPlxcbjx1bD5cXG48bGk+PGNvZGU+Y29uZmlnPC9jb2RlPiBpcyBwYXNzZWQgZGlyZWN0bHkgaW50byB0aGUgcm91dGUgcmVnaXN0ZXJlZCB3aXRoIEhhcGksIGdpdmluZyB5b3UgdGhlIG1vc3QgZmxleGliaWxpdHk8L2xpPlxcbjwvdWw+XFxuPHA+VG8gZ2V0IDxjb2RlPnRhdW51cy1oYXBpPC9jb2RlPiBnb2luZyB5b3UgY2FuIHVzZSB0aGUgZm9sbG93aW5nIHBpZWNlIG9mIGNvZGUsIGFuZCB5b3UgY2FuIGJyaW5nIHlvdXIgb3duIDxjb2RlPm9wdGlvbnM8L2NvZGU+IG9iamVjdC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxudmFyIEhhcGkgPSByZXF1aXJlKCYjMzk7aGFwaSYjMzk7KTtcXG52YXIgdGF1bnVzID0gcmVxdWlyZSgmIzM5O3RhdW51cyYjMzk7KTtcXG52YXIgdGF1bnVzSGFwaSA9IHJlcXVpcmUoJiMzOTt0YXVudXMtaGFwaSYjMzk7KSh0YXVudXMpO1xcbnZhciBwYWNrID0gbmV3IEhhcGkuUGFjaygpO1xcblxcbnBhY2sucmVnaXN0ZXIoe1xcbiAgcGx1Z2luOiB0YXVudXNIYXBpLFxcbiAgb3B0aW9uczoge1xcbiAgICAvLyAuLi5cXG4gIH1cXG59KTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+VGhlIDxjb2RlPnRhdW51c0hhcGk8L2NvZGU+IHBsdWdpbiB3aWxsIG1vdW50IFRhdW51cyBhbmQgcmVnaXN0ZXIgYWxsIG9mIHRoZSBuZWNlc3Nhcnkgcm91dGVzLiBZb3UgY2FuIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS90YXVudXMvdGF1bnVzLWhhcGlcXFwiPmZpbmQgdGF1bnVzLWhhcGkgb24gR2l0SHViPC9hPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJjb21tYW5kLWxpbmUtaW50ZXJmYWNlXFxcIj5Db21tYW5kLUxpbmUgSW50ZXJmYWNlPC9oMT5cXG48cD5PbmNlIHlvdSYjMzk7dmUgc2V0IHVwIHRoZSBzZXJ2ZXItc2lkZSB0byByZW5kZXIgeW91ciB2aWV3cyB1c2luZyBUYXVudXMsIGl0JiMzOTtzIG9ubHkgbG9naWNhbCB0aGF0IHlvdSYjMzk7bGwgd2FudCB0byByZW5kZXIgdGhlIHZpZXdzIGluIHRoZSBjbGllbnQtc2lkZSBhcyB3ZWxsLCBlZmZlY3RpdmVseSBjb252ZXJ0aW5nIHlvdXIgYXBwbGljYXRpb24gaW50byBhIHNpbmdsZS1wYWdlIGFwcGxpY2F0aW9uIGFmdGVyIHRoZSBmaXJzdCB2aWV3IGhhcyBiZWVuIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXItc2lkZS48L3A+XFxuPHA+VGhlIFRhdW51cyBDTEkgaXMgYW4gdXNlZnVsIGludGVybWVkaWFyeSBpbiB0aGUgcHJvY2VzcyBvZiBnZXR0aW5nIHRoZSBjb25maWd1cmF0aW9uIHlvdSB3cm90ZSBzbyBmYXIgZm9yIHRoZSBzZXJ2ZXItc2lkZSB0byBhbHNvIHdvcmsgd2VsbCBpbiB0aGUgY2xpZW50LXNpZGUuPC9wPlxcbjxwPkluc3RhbGwgaXQgZ2xvYmFsbHkgZm9yIGRldmVsb3BtZW50LCBidXQgcmVtZW1iZXIgdG8gdXNlIGxvY2FsIGNvcGllcyBmb3IgcHJvZHVjdGlvbi1ncmFkZSB1c2VzLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ucG0gaW5zdGFsbCAtZyB0YXVudXNcXG48L2NvZGU+PC9wcmU+XFxuPHA+V2hlbiBpbnZva2VkIHdpdGhvdXQgYW55IGFyZ3VtZW50cywgdGhlIENMSSB3aWxsIHNpbXBseSBmb2xsb3cgdGhlIGRlZmF1bHQgY29udmVudGlvbnMgdG8gZmluZCB5b3VyIHJvdXRlIGRlZmluaXRpb25zLCB2aWV3cywgYW5kIGNsaWVudC1zaWRlIGNvbnRyb2xsZXJzLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj50YXVudXNcXG48L2NvZGU+PC9wcmU+XFxuPHA+QnkgZGVmYXVsdCwgdGhlIG91dHB1dCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIHN0YW5kYXJkIG91dHB1dCwgbWFraW5nIGZvciBhIGZhc3QgZGVidWdnaW5nIGV4cGVyaWVuY2UuIEhlcmUmIzM5O3MgdGhlIG91dHB1dCBpZiB5b3UganVzdCBoYWQgYSBzaW5nbGUgPGNvZGU+aG9tZS9pbmRleDwvY29kZT4gcm91dGUsIGFuZCB0aGUgbWF0Y2hpbmcgdmlldyBhbmQgY2xpZW50LXNpZGUgY29udHJvbGxlciBleGlzdGVkLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWpzXFxcIj4mIzM5O3VzZSBzdHJpY3QmIzM5OztcXG5cXG52YXIgdGVtcGxhdGVzID0ge1xcbiAgJiMzOTtob21lL2luZGV4JiMzOTs6IHJlcXVpcmUoJiMzOTsuL3ZpZXdzL2hvbWUvaW5kZXguanMmIzM5OylcXG59O1xcblxcbnZhciBjb250cm9sbGVycyA9IHtcXG4gICYjMzk7aG9tZS9pbmRleCYjMzk7OiByZXF1aXJlKCYjMzk7Li4vY2xpZW50L2pzL2NvbnRyb2xsZXJzL2hvbWUvaW5kZXguanMmIzM5OylcXG59O1xcblxcbnZhciByb3V0ZXMgPSBbXFxuICB7XFxuICAgIHJvdXRlOiAmIzM5Oy8mIzM5OyxcXG4gICAgYWN0aW9uOiAmIzM5O2hvbWUvaW5kZXgmIzM5O1xcbiAgfVxcbl07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcXG4gIGNvbnRyb2xsZXJzOiBjb250cm9sbGVycyxcXG4gIHJvdXRlczogcm91dGVzXFxufTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+WW91IGNhbiB1c2UgYSBmZXcgb3B0aW9ucyB0byBhbHRlciB0aGUgb3V0Y29tZSBvZiBpbnZva2luZyA8Y29kZT50YXVudXM8L2NvZGU+LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi1vdXRwdXQtXFxcIj48Y29kZT4tLW91dHB1dDwvY29kZT48L2gyPlxcbjxwPjxzdWI+dGhlIDxjb2RlPi1vPC9jb2RlPiBhbGlhcyBpcyBhdmFpbGFibGU8L3N1Yj48L3A+XFxuPHA+T3V0cHV0IGlzIHdyaXR0ZW4gdG8gYSBmaWxlIGluc3RlYWQgb2YgdG8gc3RhbmRhcmQgb3V0cHV0LiBUaGUgZmlsZSBwYXRoIHVzZWQgd2lsbCBiZSB0aGUgPGNvZGU+Y2xpZW50X3dpcmluZzwvY29kZT4gb3B0aW9uIGluIDxhIGhyZWY9XFxcIiN0aGUtdGF1bnVzcmMtbWFuaWZlc3RcXFwiPjxjb2RlPi50YXVudXNyYzwvY29kZT48L2E+LCB3aGljaCBkZWZhdWx0cyB0byA8Y29kZT4mIzM5Oy5iaW4vd2lyaW5nLmpzJiMzOTs8L2NvZGU+LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi13YXRjaC1cXFwiPjxjb2RlPi0td2F0Y2g8L2NvZGU+PC9oMj5cXG48cD48c3ViPnRoZSA8Y29kZT4tdzwvY29kZT4gYWxpYXMgaXMgYXZhaWxhYmxlPC9zdWI+PC9wPlxcbjxwPldoZW5ldmVyIGEgc2VydmVyLXNpZGUgcm91dGUgZGVmaW5pdGlvbiBjaGFuZ2VzLCB0aGUgb3V0cHV0IGlzIHByaW50ZWQgYWdhaW4gdG8gZWl0aGVyIHN0YW5kYXJkIG91dHB1dCBvciBhIGZpbGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIDxjb2RlPi0tb3V0cHV0PC9jb2RlPiB3YXMgdXNlZC48L3A+XFxuPHA+VGhlIHByb2dyYW0gd29uJiMzOTt0IGV4aXQuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiLXRyYW5zZm9ybS1tb2R1bGUtXFxcIj48Y29kZT4tLXRyYW5zZm9ybSAmbHQ7bW9kdWxlJmd0OzwvY29kZT48L2gyPlxcbjxwPjxzdWI+dGhlIDxjb2RlPi10PC9jb2RlPiBhbGlhcyBpcyBhdmFpbGFibGU8L3N1Yj48L3A+XFxuPHA+VGhpcyBmbGFnIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHNlcnZlci1zaWRlIHJvdXRlcyBpbnRvIHNvbWV0aGluZyB0aGUgY2xpZW50LXNpZGUgdW5kZXJzdGFuZHMuIEV4cHJlc3Mgcm91dGVzIGFyZSBjb21wbGV0ZWx5IGNvbXBhdGlibGUgd2l0aCB0aGUgY2xpZW50LXNpZGUgcm91dGVyLCBidXQgSGFwaSByb3V0ZXMgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy9oYXBpaWZ5XFxcIj48Y29kZT5oYXBpaWZ5PC9jb2RlPjwvYT4gbW9kdWxlLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ucG0gaW5zdGFsbCBoYXBpaWZ5XFxudGF1bnVzIC10IGhhcGlpZnlcXG48L2NvZGU+PC9wcmU+XFxuPHA+VXNpbmcgdGhpcyB0cmFuc2Zvcm0gcmVsaWV2ZXMgeW91IGZyb20gaGF2aW5nIHRvIGRlZmluZSB0aGUgc2FtZSByb3V0ZXMgdHdpY2UgdXNpbmcgc2xpZ2h0bHkgZGlmZmVyZW50IGZvcm1hdHMgdGhhdCBjb252ZXkgdGhlIHNhbWUgbWVhbmluZy48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItZGVmZXItYWN0aW9ucy1cXFwiPjxjb2RlPi0tZGVmZXIgW2FjdGlvbnNdPC9jb2RlPjwvaDI+XFxuPHA+PHN1Yj50aGUgPGNvZGU+LWQ8L2NvZGU+IGFsaWFzIGlzIGF2YWlsYWJsZTwvc3ViPjwvcD5cXG48cD5IZXJlIGlzIHdoZXJlIHRoaW5ncyBnZXQgaW50ZXJlc3RpbmcuIFRoZSA8Y29kZT4tLWRlZmVyPC9jb2RlPiBmbGFnIGFsbG93cyB5b3UgdG8gZGVmZXIgbG9hZGluZyBmb3IgemVybyBvciBtb3JlIGFjdGlvbnMuIEV4Y2x1ZGluZyB0aGUgY29udHJvbGxlciBhbmQgdmlldyB0ZW1wbGF0ZXMgZm9yIGFueSBkZWZlcnJlZCBhY3Rpb24gY2FuIHNpZ25pZmljYW50bHkgcmVkdWNlIHRoZSBmaW5nZXJwcmludCBvZiB5b3VyIGFwcGxpY2F0aW9uLjwvcD5cXG48cD5UaGUgPGNvZGU+W2FjdGlvbnNdPC9jb2RlPiBhcmd1bWVudCBkZXRlcm1pbmVzIHdoYXQgYWN0aW9ucyBnZXQgZGVmZXJyZWQsIGFuZCB3aGljaCBkb24mIzM5O3QuIEl0IGV4cGVjdHMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhY3Rpb25zLCB3aGVyZSB5b3UgY2FuIHBhc3MgaW4gZWl0aGVyIHRoZSBjb250cm9sbGVyIG5hbWUsIG9yIGJvdGggdGhlIGNvbnRyb2xsZXIgbmFtZSBhbmQgdGhlIGFjdGlvbiBuYW1lLiBVc2luZyA8Y29kZT4/PC9jb2RlPiBhY3RzIGFzIGEgd2lsZGNhcmQuPC9wPlxcbjxwPkZvciBleGFtcGxlLCB1c2luZyA8Y29kZT5hZG1pbjwvY29kZT4gPGVtPihlcXVpdmFsZW50IHRvIHVzaW5nIDxjb2RlPmFkbWluLz88L2NvZGU+KTwvZW0+IHdpbGwgZGVmZXIgZXZlcnkgYWN0aW9uIHVuZGVyIHRoZSA8Y29kZT5hZG1pbjwvY29kZT4gY29udHJvbGxlci4gVXNpbmcgPGNvZGU+YWRtaW4vbnVrZTwvY29kZT4gd2lsbCBvbmx5IGRlZmVyIHRoZSA8Y29kZT5hZG1pbi9udWtlPC9jb2RlPiBhY3Rpb24uIElmIHlvdSBvbWl0IHRoZSA8Y29kZT5bYWN0aW9uc108L2NvZGU+IHBhcmFtZXRlciBlbnRpcmVseSwgdGhlIGRlZmF1bHQgdmFsdWUgb2YgPGNvZGU+JiMzOTs/JiMzOTs8L2NvZGU+IHdpbGwgYmUgdXNlZCBhbmQgZXZlcnl0aGluZyB3aWxsIGJlIGRlZmVycmVkLjwvcD5cXG48cD5XaGVuIGNvbXBvbmVudHMgZ2V0IGRlZmVycmVkLCB0aGV5JiMzOTtsbCBiZSBsb2FkZWQgYXMgc29vbiBhcyBUYXVudXMgZGV0ZWN0cyB0aGF0IHRoZXkmIzM5O3JlIG5lZWRlZC4gVGhpcyBjYW4gaGFwcGVuIGluIGEgZmV3IHBsYWNlcy48L3A+XFxuPHVsPlxcbjxsaT5UaGUgdXNlciBuYXZpZ2F0ZXMgdG8gKG9yIDxhIGhyZWY9XFxcIiNwcmVmZXRjaGluZ1xcXCI+PGVtPnByZWZldGNoZXM8L2VtPjwvYT4pIHRoZSA8Y29kZT4vYWRtaW48L2NvZGU+IHJvdXRlLCBhbmQgPGNvZGU+YWRtaW4vaW5kZXg8L2NvZGU+IHdhcyBkZWZlcnJlZCwgYW5kIGl0cyBjb21wb25lbnRzIGFyZW4mIzM5O3QgY2FjaGVkIG9uIHRoZSBjbGllbnQtc2lkZSB5ZXQ8L2xpPlxcbjxsaT5BIGNvbnRyb2xsZXIgdXNlcyA8Y29kZT50YXVudXMucGFydGlhbDwvY29kZT4gdG8gcmVuZGVyIGFuIGFjdGlvbiB0aGF0IHdhcyBkZWZlcnJlZCwgYW5kIGl0cyBjb21wb25lbnRzIGFyZW4mIzM5O3QgY2FjaGVkIG9uIHRoZSBjbGllbnQtc2lkZSB5ZXQ8L2xpPlxcbjxsaT5UaGUgdXNlciBuYXZpZ2F0ZXMgdG8gdGhlIDxjb2RlPi9hZG1pbjwvY29kZT4gcm91dGUsIGFuZCBpdHMgbWF0Y2hpbmcgPGNvZGU+YWRtaW4vaW5kZXg8L2NvZGU+IHJvdXRlIHdhc24mIzM5O3QgZGVmZXJyZWQsIGJ1dCB0aGUgc2VydmVyLXNpZGUgY29udHJvbGxlciBkZWNpZGVzIHRvIGNoYW5nZSB0aGUgYWN0aW9uIHRvIDxjb2RlPmFkbWluL3N1cGVyYWRtaW48L2NvZGU+LiBXaGVuIHRoZSByZXNwb25zZSBnZXRzIHRvIHRoZSBjbGllbnQsIGl0JiMzOTtsbCBuZWVkIHRvIGFzayB0aGUgc2VydmVyIGZvciB0aGUgPGNvZGU+YWRtaW4vc3VwZXJhZG1pbjwvY29kZT4gdGVtcGxhdGUgaWYgdGhlIGNsaWVudCBkb2VzbiYjMzk7dCBhbHJlYWR5IGhhdmUgaXQ8L2xpPlxcbjwvdWw+XFxuPHA+WW91IGRvbiYjMzk7dCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRob3NlIGRpZmZlcmVudCBzY2VuYXJpb3MsIHRob3VnaCwgYXMgVGF1bnVzIGhhbmRsZXMgdGhlbSBhbGwgZm9yIHlvdSB0cmFuc3BhcmVudGx5LiBZb3Ugc2hvdWxkIDxhIGhyZWY9XFxcIi9wZXJmb3JtYW5jZSNzZW5kLXZpZXdzLWFuZC1jb250cm9sbGVycy10by10aGUtY2xpZW50LXNlbGVjdGl2ZWx5XFxcIj5sZWFybiBtb3JlIGFib3V0IGRlZmVycmVkIGxvYWRpbmcgb24gdGhlIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvbiBndWlkZTwvYT4uPC9wPlxcbjxibG9ja3F1b3RlPlxcbjxwPkEgcG9zc2libGUgY29uY2VybiB3aXRoIGRlZmVycmVkIGV4ZWN1dGlvbiBpcyB0aGF0IHBhcnRpYWwgdmlld3MgbWF5IG5vdCBiZSByZW5kZXJlZCBpbW1lZGlhdGVseSwgYXMgYSByZXF1ZXN0IG1heSBiZSBuZWNlc3NhcnkgdG8gZmV0Y2ggdGhlIGNvbnRyb2xsZXIgb3IgdGVtcGxhdGUgZm9yIHRoZSBwYXJ0aWFsLjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+U29tZSBvdGhlciBjb25zaWRlcmF0aW9ucywgcmVnYXJkaW5nIGhvdyBkZWZlcnJlZCBjb21wb25lbnRzIGdldCBidW5kbGVkLCBhcmUgbGlzdGVkIGluIHRoZSA8YSBocmVmPVxcXCIvcGVyZm9ybWFuY2Ujc2VuZC12aWV3cy1hbmQtY29udHJvbGxlcnMtdG8tdGhlLWNsaWVudC1zZWxlY3RpdmVseVxcXCI+UGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uPC9hPiBndWlkZS48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItcmVzb2x2ZXJzLW1vZHVsZS1cXFwiPjxjb2RlPi0tcmVzb2x2ZXJzICZsdDttb2R1bGUmZ3Q7PC9jb2RlPjwvaDI+XFxuPHA+PHN1Yj50aGUgPGNvZGU+LXI8L2NvZGU+IGFsaWFzIGlzIGF2YWlsYWJsZTwvc3ViPjwvcD5cXG48cD5TaW1pbGFybHkgdG8gdGhlIDxhIGhyZWY9XFxcIiMtb3B0aW9ucy1yZXNvbHZlcnMtXFxcIj48Y29kZT5yZXNvbHZlcnM8L2NvZGU+PC9hPiBvcHRpb24gdGhhdCB5b3UgY2FuIHBhc3MgdG8gPGEgaHJlZj1cXFwiIy10YXVudXMtbW91bnQtYWRkcm91dGUtb3B0aW9ucy1cXFwiPjxjb2RlPnRhdW51cy5tb3VudDwvY29kZT48L2E+LCB0aGVzZSByZXNvbHZlcnMgY2FuIGNoYW5nZSB0aGUgd2F5IGluIHdoaWNoIGZpbGUgcGF0aHMgYXJlIHJlc29sdmVkLjwvcD5cXG48dGFibGU+XFxuPHRoZWFkPlxcbjx0cj5cXG48dGg+U2lnbmF0dXJlPC90aD5cXG48dGg+RGVzY3JpcHRpb248L3RoPlxcbjwvdHI+XFxuPC90aGVhZD5cXG48dGJvZHk+XFxuPHRyPlxcbjx0ZD48Y29kZT5nZXRDbGllbnRDb250cm9sbGVyKGFjdGlvbik8L2NvZGU+PC90ZD5cXG48dGQ+UmV0dXJuIHBhdGggdG8gY2xpZW50LXNpZGUgY29udHJvbGxlciBhY3Rpb24gaGFuZGxlciBtb2R1bGU8L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT5nZXRWaWV3KGFjdGlvbik8L2NvZGU+PC90ZD5cXG48dGQ+UmV0dXJuIHBhdGggdG8gdmlldyB0ZW1wbGF0ZSBtb2R1bGU8L3RkPlxcbjwvdHI+XFxuPC90Ym9keT5cXG48L3RhYmxlPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiLWJ1bmRsZS1cXFwiPjxjb2RlPi0tYnVuZGxlPC9jb2RlPjwvaDI+XFxuPHA+PHN1Yj50aGUgPGNvZGU+LWI8L2NvZGU+IGFsaWFzIGlzIGF2YWlsYWJsZTwvc3ViPjwvcD5cXG48cD5VbmRlciB0aGlzIGV4cGVyaW1lbnRhbCBmbGFnLCB0aGUgQ0xJIHdpbGwgdXNlIEJyb3dzZXJpZnkgdG8gY29tcGlsZSBhIHN0YW5kYWxvbmUgbW9kdWxlIHRoYXQgaW5jbHVkZXMgdGhlIHdpcmluZyBub3JtYWxseSBleHBvcnRlZCBieSB0aGUgQ0xJIHBsdXMgYWxsIG9mIFRhdW51cyA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kXFxcIj5hcyBhIFVNRCBtb2R1bGU8L2E+LjwvcD5cXG48cD5UaGlzIGFsbG93cyB5b3UgdG8gdXNlIFRhdW51cyBvbiB0aGUgY2xpZW50LXNpZGUgZXZlbiBpZiB5b3UgZG9uJiMzOTt0IHdhbnQgdG8gdXNlIDxhIGhyZWY9XFxcImh0dHA6Ly9icm93c2VyaWZ5Lm9yZ1xcXCI+QnJvd3NlcmlmeTwvYT4gZGlyZWN0bHkuPC9wPlxcbjxwPkZlZWRiYWNrIGFuZCBzdWdnZXN0aW9ucyBhYm91dCB0aGlzIGZsYWcsIDxlbT5hbmQgcG9zc2libGUgYWx0ZXJuYXRpdmVzIHRoYXQgd291bGQgbWFrZSBUYXVudXMgZWFzaWVyIHRvIHVzZTwvZW0+LCBhcmUgd2VsY29tZS48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJjbGllbnQtc2lkZS1hcGlcXFwiPkNsaWVudC1zaWRlIEFQSTwvaDE+XFxuPHA+SnVzdCBsaWtlIHRoZSBzZXJ2ZXItc2lkZSwgZXZlcnl0aGluZyBpbiB0aGUgY2xpZW50LXNpZGUgYmVnaW5zIGF0IHRoZSBtb3VudHBvaW50LiBPbmNlIHRoZSBhcHBsaWNhdGlvbiBpcyBtb3VudGVkLCBhbmNob3IgbGlua3Mgd2lsbCBiZSBoaWphY2tlZCBhbmQgdGhlIGNsaWVudC1zaWRlIHJvdXRlciB3aWxsIHRha2Ugb3ZlciB2aWV3IHJlbmRlcmluZy4gQ2xpZW50LXNpZGUgY29udHJvbGxlcnMgYXJlIGV4ZWN1dGVkIHdoZW5ldmVyIGEgdmlldyBpcyByZW5kZXJlZC48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItdGF1bnVzLW1vdW50LWNvbnRhaW5lci13aXJpbmctb3B0aW9ucy1cXFwiPjxjb2RlPnRhdW51cy5tb3VudChjb250YWluZXIsIHdpcmluZywgb3B0aW9ucz8pPC9jb2RlPjwvaDI+XFxuPHA+VGhlIG1vdW50cG9pbnQgdGFrZXMgYSByb290IGNvbnRhaW5lciwgdGhlIHdpcmluZyBtb2R1bGUsIGFuZCBhbiBvcHRpb25zIHBhcmFtZXRlci4gVGhlIDxjb2RlPmNvbnRhaW5lcjwvY29kZT4gaXMgd2hlcmUgY2xpZW50LXNpZGUtcmVuZGVyZWQgdmlld3Mgd2lsbCBiZSBwbGFjZWQsIGJ5IHJlcGxhY2luZyB3aGF0ZXZlciBIVE1MIGNvbnRlbnRzIGFscmVhZHkgZXhpc3QuIFlvdSBjYW4gcGFzcyBpbiB0aGUgPGNvZGU+d2lyaW5nPC9jb2RlPiBtb2R1bGUgZXhhY3RseSBhcyBidWlsdCBieSB0aGUgQ0xJLCBhbmQgbm8gZnVydGhlciBjb25maWd1cmF0aW9uIGlzIG5lY2Vzc2FyeS48L3A+XFxuPHA+V2hlbiB0aGUgbW91bnRwb2ludCBleGVjdXRlcywgVGF1bnVzIHdpbGwgY29uZmlndXJlIGl0cyBpbnRlcm5hbCBzdGF0ZSwgPGVtPnNldCB1cCB0aGUgY2xpZW50LXNpZGUgcm91dGVyPC9lbT4sIHJ1biB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlciBmb3IgdGhlIHNlcnZlci1zaWRlIHJlbmRlcmVkIHZpZXcsIGFuZCBzdGFydCBoaWphY2tpbmcgbGlua3MuPC9wPlxcbjxwPkFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIGEgYnJvd3NlciBtYWtlcyBhIDxjb2RlPkdFVDwvY29kZT4gcmVxdWVzdCBmb3IgPGNvZGU+L2FydGljbGVzL3RoZS1mb3g8L2NvZGU+IGZvciB0aGUgZmlyc3QgdGltZS4gT25jZSA8Y29kZT50YXVudXMubW91bnQoY29udGFpbmVyLCB3aXJpbmcpPC9jb2RlPiBpcyBpbnZva2VkIG9uIHRoZSBjbGllbnQtc2lkZSwgc2V2ZXJhbCB0aGluZ3Mgd291bGQgaGFwcGVuIGluIHRoZSBvcmRlciBsaXN0ZWQgYmVsb3cuPC9wPlxcbjx1bD5cXG48bGk+VGF1bnVzIHNldHMgdXAgdGhlIGNsaWVudC1zaWRlIHZpZXcgcm91dGluZyBlbmdpbmU8L2xpPlxcbjxsaT5JZiBlbmFibGVkIDxlbT4odmlhIDxjb2RlPm9wdGlvbnM8L2NvZGU+KTwvZW0+LCB0aGUgY2FjaGluZyBlbmdpbmUgaXMgY29uZmlndXJlZDwvbGk+XFxuPGxpPlRhdW51cyBvYnRhaW5zIHRoZSB2aWV3IG1vZGVsIDxlbT4obW9yZSBvbiB0aGlzIGxhdGVyKTwvZW0+PC9saT5cXG48bGk+V2hlbiBhIHZpZXcgbW9kZWwgaXMgb2J0YWluZWQsIHRoZSA8Y29kZT4mIzM5O3N0YXJ0JiMzOTs8L2NvZGU+IGV2ZW50IGlzIGVtaXR0ZWQ8L2xpPlxcbjxsaT5BbmNob3IgbGlua3Mgc3RhcnQgYmVpbmcgbW9uaXRvcmVkIGZvciBjbGlja3MgPGVtPihhdCB0aGlzIHBvaW50IHlvdXIgYXBwbGljYXRpb24gYmVjb21lcyBhIDxhIGhyZWY9XFxcImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2luZ2xlLXBhZ2VfYXBwbGljYXRpb25cXFwiPlNQQTwvYT4pPC9lbT48L2xpPlxcbjxsaT5UaGUgPGNvZGU+YXJ0aWNsZXMvYXJ0aWNsZTwvY29kZT4gY2xpZW50LXNpZGUgY29udHJvbGxlciBpcyBleGVjdXRlZDwvbGk+XFxuPC91bD5cXG48cD5UaGF0JiMzOTtzIHF1aXRlIGEgYml0IG9mIGZ1bmN0aW9uYWxpdHksIGJ1dCBpZiB5b3UgdGhpbmsgYWJvdXQgaXQsIG1vc3Qgb3RoZXIgZnJhbWV3b3JrcyBhbHNvIHJlbmRlciB0aGUgdmlldyBhdCB0aGlzIHBvaW50LCA8ZW0+cmF0aGVyIHRoYW4gb24gdGhlIHNlcnZlci1zaWRlITwvZW0+PC9wPlxcbjxwPkluIG9yZGVyIHRvIGJldHRlciB1bmRlcnN0YW5kIHRoZSBwcm9jZXNzLCBJJiMzOTtsbCB3YWxrIHlvdSB0aHJvdWdoIHRoZSA8Y29kZT5vcHRpb25zPC9jb2RlPiBwYXJhbWV0ZXIuPC9wPlxcbjxwPkZpcnN0IG9mZiwgdGhlIDxjb2RlPmJvb3RzdHJhcDwvY29kZT4gb3B0aW9uIGRldGVybWluZXMgdGhlIHN0cmF0ZWd5IHVzZWQgdG8gcHVsbCB0aGUgdmlldyBtb2RlbCBvZiB0aGUgc2VydmVyLXNpZGUgcmVuZGVyZWQgdmlldyBpbnRvIHRoZSBjbGllbnQtc2lkZS4gVGhlcmUgYXJlIHRocmVlIHBvc3NpYmxlIHN0cmF0ZWdpZXMgYXZhaWxhYmxlOiA8Y29kZT5hdXRvPC9jb2RlPiA8ZW0+KHRoZSBkZWZhdWx0IHN0cmF0ZWd5KTwvZW0+LCA8Y29kZT5pbmxpbmU8L2NvZGU+LCBvciA8Y29kZT5tYW51YWw8L2NvZGU+LiBUaGUgPGNvZGU+YXV0bzwvY29kZT4gc3RyYXRlZ3kgaW52b2x2ZXMgdGhlIGxlYXN0IHdvcmssIHdoaWNoIGlzIHdoeSBpdCYjMzk7cyB0aGUgZGVmYXVsdC48L3A+XFxuPHVsPlxcbjxsaT48Y29kZT5hdXRvPC9jb2RlPiB3aWxsIG1ha2UgYW4gQUpBWCByZXF1ZXN0IGZvciB0aGUgdmlldyBtb2RlbDwvbGk+XFxuPGxpPjxjb2RlPmlubGluZTwvY29kZT4gZXhwZWN0cyB5b3UgdG8gcGxhY2UgdGhlIG1vZGVsIGludG8gYSA8Y29kZT4mbHQ7c2NyaXB0IHR5cGU9JiMzOTt0ZXh0L3RhdW51cyYjMzk7Jmd0OzwvY29kZT4gdGFnPC9saT5cXG48bGk+PGNvZGU+bWFudWFsPC9jb2RlPiBleHBlY3RzIHlvdSB0byBnZXQgdGhlIHZpZXcgbW9kZWwgaG93ZXZlciB5b3Ugd2FudCB0bywgYW5kIHRoZW4gbGV0IFRhdW51cyBrbm93IHdoZW4gaXQmIzM5O3MgcmVhZHk8L2xpPlxcbjwvdWw+XFxuPHA+TGV0JiMzOTtzIGdvIGludG8gZGV0YWlsIGFib3V0IGVhY2ggb2YgdGhlc2Ugc3RyYXRlZ2llcy48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg0IGlkPVxcXCJ1c2luZy10aGUtYXV0by1zdHJhdGVneVxcXCI+VXNpbmcgdGhlIDxjb2RlPmF1dG88L2NvZGU+IHN0cmF0ZWd5PC9oND5cXG48cD5UaGUgPGNvZGU+YXV0bzwvY29kZT4gc3RyYXRlZ3kgbWVhbnMgdGhhdCBUYXVudXMgd2lsbCBtYWtlIHVzZSBvZiBhbiBBSkFYIHJlcXVlc3QgdG8gb2J0YWluIHRoZSB2aWV3IG1vZGVsLiA8ZW0+WW91IGRvbiYjMzk7dCBoYXZlIHRvIGRvIGFueXRoaW5nIGVsc2U8L2VtPiBhbmQgdGhpcyBpcyB0aGUgZGVmYXVsdCBzdHJhdGVneS4gVGhpcyBpcyB0aGUgPHN0cm9uZz5tb3N0IGNvbnZlbmllbnQgc3RyYXRlZ3ksIGJ1dCBhbHNvIHRoZSBzbG93ZXN0PC9zdHJvbmc+IG9uZS48L3A+XFxuPHA+SXQmIzM5O3Mgc2xvdyBiZWNhdXNlIHRoZSB2aWV3IG1vZGVsIHdvbiYjMzk7dCBiZSByZXF1ZXN0ZWQgdW50aWwgdGhlIGJ1bGsgb2YgeW91ciBKYXZhU2NyaXB0IGNvZGUgaGFzIGJlZW4gZG93bmxvYWRlZCwgcGFyc2VkLCBleGVjdXRlZCwgYW5kIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gaXMgaW52b2tlZC48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg0IGlkPVxcXCJ1c2luZy10aGUtaW5saW5lLXN0cmF0ZWd5XFxcIj5Vc2luZyB0aGUgPGNvZGU+aW5saW5lPC9jb2RlPiBzdHJhdGVneTwvaDQ+XFxuPHA+VGhlIDxjb2RlPmlubGluZTwvY29kZT4gc3RyYXRlZ3kgZXhwZWN0cyB5b3UgdG8gYWRkIGEgPGNvZGU+ZGF0YS10YXVudXM8L2NvZGU+IGF0dHJpYnV0ZSBvbiB0aGUgPGNvZGU+Y29udGFpbmVyPC9jb2RlPiBlbGVtZW50LiBUaGlzIGF0dHJpYnV0ZSBtdXN0IGJlIGVxdWFsIHRvIHRoZSA8Y29kZT5pZDwvY29kZT4gYXR0cmlidXRlIG9mIGEgPGNvZGU+Jmx0O3NjcmlwdCZndDs8L2NvZGU+IHRhZyBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIHZpZXcgbW9kZWwgYWxvbmdzaWRlIHRoZSB2ZXJzaW9uIGluZm9ybWF0aW9uIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgYnkgVGF1bnVzIGludG8gdGhlIGxheW91dCB0ZW1wbGF0ZSBkYXRhLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWphZGVcXFwiPmRpdihkYXRhLXRhdW51cz0mIzM5O21vZGVsJiMzOTspIT1wYXJ0aWFsXFxuc2NyaXB0KHR5cGU9JiMzOTt0ZXh0L3RhdW51cyYjMzk7LCBkYXRhLXRhdW51cz0mIzM5O21vZGVsJiMzOTspPUpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogdmVyc2lvbiwgbW9kZWw6IG1vZGVsIH0pXFxuPC9jb2RlPjwvcHJlPlxcbjxwPlBheSBzcGVjaWFsIGF0dGVudGlvbiB0byB0aGUgZmFjdCB0aGF0IHRoZSBtb2RlbCBpcyBub3Qgb25seSBtYWRlIGludG8gYSBKU09OIHN0cmluZywgPGVtPmJ1dCBhbHNvIEhUTUwgZW5jb2RlZCBieSBKYWRlPC9lbT4uIFdoZW4gVGF1bnVzIGV4dHJhY3RzIHRoZSBtb2RlbCBmcm9tIHRoZSA8Y29kZT4mbHQ7c2NyaXB0Jmd0OzwvY29kZT4gdGFnIGl0JiMzOTtsbCB1bmVzY2FwZSBpdCwgYW5kIHRoZW4gcGFyc2UgaXQgYXMgSlNPTi48L3A+XFxuPHA+VGhpcyBzdHJhdGVneSBpcyBhbHNvIGZhaXJseSBjb252ZW5pZW50IHRvIHNldCB1cCwgYnV0IGl0IGludm9sdmVzIGEgbGl0dGxlIG1vcmUgd29yay4gSXQgbWlnaHQgYmUgd29ydGh3aGlsZSB0byB1c2UgaW4gY2FzZXMgd2hlcmUgbW9kZWxzIGFyZSBzbWFsbCwgYnV0IGl0IHdpbGwgc2xvdyBkb3duIHNlcnZlci1zaWRlIHZpZXcgcmVuZGVyaW5nLCBhcyB0aGUgbW9kZWwgaXMgaW5saW5lZCBhbG9uZ3NpZGUgdGhlIEhUTUwuPC9wPlxcbjxwPlRoYXQgbWVhbnMgdGhhdCB0aGUgY29udGVudCB5b3UgYXJlIHN1cHBvc2VkIHRvIGJlIHByaW9yaXRpemluZyBpcyBnb2luZyB0byB0YWtlIGxvbmdlciB0byBnZXQgdG8geW91ciBodW1hbnMsIGJ1dCBvbmNlIHRoZXkgZ2V0IHRoZSBIVE1MLCB0aGlzIHN0cmF0ZWd5IHdpbGwgZXhlY3V0ZSB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlciBhbG1vc3QgaW1tZWRpYXRlbHkuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwidXNpbmctdGhlLW1hbnVhbC1zdHJhdGVneVxcXCI+VXNpbmcgdGhlIDxjb2RlPm1hbnVhbDwvY29kZT4gc3RyYXRlZ3k8L2g0PlxcbjxwPlRoZSA8Y29kZT5tYW51YWw8L2NvZGU+IHN0cmF0ZWd5IGlzIHRoZSBtb3N0IGludm9sdmVkIG9mIHRoZSB0aHJlZSwgYnV0IGFsc28gdGhlIG1vc3QgcGVyZm9ybWFudC4gSW4gdGhpcyBzdHJhdGVneSB5b3UmIzM5O3JlIHN1cHBvc2VkIHRvIGFkZCB0aGUgZm9sbG93aW5nIDxlbT4oc2VlbWluZ2x5IHBvaW50bGVzcyk8L2VtPiBzbmlwcGV0IG9mIGNvZGUgaW4gYSA8Y29kZT4mbHQ7c2NyaXB0Jmd0OzwvY29kZT4gb3RoZXIgdGhhbiB0aGUgb25lIHRoYXQmIzM5O3MgcHVsbGluZyBkb3duIFRhdW51cywgc28gdGhhdCB0aGV5IGFyZSBwdWxsZWQgY29uY3VycmVudGx5IHJhdGhlciB0aGFuIHNlcmlhbGx5LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWpzXFxcIj4mIzM5O3VzZSBzdHJpY3QmIzM5OztcXG5cXG53aW5kb3cudGF1bnVzUmVhZHkgPSBmdW5jdGlvbiAobW9kZWwpIHtcXG4gIHdpbmRvdy50YXVudXNSZWFkeSA9IG1vZGVsO1xcbn07XFxuPC9jb2RlPjwvcHJlPlxcbjxwPk9uY2UgeW91IHNvbWVob3cgZ2V0IHlvdXIgaGFuZHMgb24gdGhlIHZpZXcgbW9kZWwsIHlvdSBzaG91bGQgaW52b2tlIDxjb2RlPnRhdW51c1JlYWR5KG1vZGVsKTwvY29kZT4uIENvbnNpZGVyaW5nIHlvdSYjMzk7bGwgYmUgcHVsbGluZyBib3RoIHRoZSB2aWV3IG1vZGVsIGFuZCBUYXVudXMgYXQgdGhlIHNhbWUgdGltZSwgYSBudW1iZXIgb2YgZGlmZmVyZW50IHNjZW5hcmlvcyBtYXkgcGxheSBvdXQuPC9wPlxcbjx1bD5cXG48bGk+VGhlIHZpZXcgbW9kZWwgaXMgbG9hZGVkIGZpcnN0LCB5b3UgY2FsbCA8Y29kZT50YXVudXNSZWFkeShtb2RlbCk8L2NvZGU+IGFuZCB3YWl0IGZvciBUYXVudXMgdG8gdGFrZSB0aGUgbW9kZWwgb2JqZWN0IGFuZCBib290IHRoZSBhcHBsaWNhdGlvbiBhcyBzb29uIGFzIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gaXMgZXhlY3V0ZWQ8L2xpPlxcbjxsaT5UYXVudXMgbG9hZHMgZmlyc3QgYW5kIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gaXMgY2FsbGVkIGZpcnN0LiBJbiB0aGlzIGNhc2UsIFRhdW51cyB3aWxsIHJlcGxhY2UgPGNvZGU+d2luZG93LnRhdW51c1JlYWR5PC9jb2RlPiB3aXRoIGEgc3BlY2lhbCA8Y29kZT5ib290PC9jb2RlPiBtZXRob2QuIFdoZW4gdGhlIHZpZXcgbW9kZWwgZmluaXNoZXMgbG9hZGluZywgeW91IGNhbGwgPGNvZGU+dGF1bnVzUmVhZHkobW9kZWwpPC9jb2RlPiBhbmQgdGhlIGFwcGxpY2F0aW9uIGZpbmlzaGVzIGJvb3Rpbmc8L2xpPlxcbjwvdWw+XFxuPGJsb2NrcXVvdGU+XFxuPHA+SWYgdGhpcyBzb3VuZHMgYSBsaXR0bGUgbWluZC1iZW5kaW5nIGl0JiMzOTtzIGJlY2F1c2UgaXQgaXMuIEl0JiMzOTtzIG5vdCBkZXNpZ25lZCB0byBiZSBwcmV0dHksIGJ1dCBtZXJlbHkgdG8gYmUgcGVyZm9ybWFudC48L3A+XFxuPC9ibG9ja3F1b3RlPlxcbjxwPk5vdyB0aGF0IHdlJiMzOTt2ZSBhZGRyZXNzZWQgdGhlIGF3a3dhcmQgYml0cywgbGV0JiMzOTtzIGNvdmVyIHRoZSA8ZW0+JnF1b3Q7c29tZWhvdyBnZXQgeW91ciBoYW5kcyBvbiB0aGUgdmlldyBtb2RlbCZxdW90OzwvZW0+IGFzcGVjdC4gTXkgcHJlZmVycmVkIG1ldGhvZCBpcyB1c2luZyBKU09OUCwgYXMgaXQmIzM5O3MgYWJsZSB0byBkZWxpdmVyIHRoZSBzbWFsbGVzdCBzbmlwcGV0IHBvc3NpYmxlLCBhbmQgaXQgY2FuIHRha2UgYWR2YW50YWdlIG9mIHNlcnZlci1zaWRlIGNhY2hpbmcuIENvbnNpZGVyaW5nIHlvdSYjMzk7bGwgcHJvYmFibHkgd2FudCB0aGlzIHRvIGJlIGFuIGlubGluZSBzY3JpcHQsIGtlZXBpbmcgaXQgc21hbGwgaXMgaW1wb3J0YW50LjwvcD5cXG48cD5UaGUgZ29vZCBuZXdzIGlzIHRoYXQgdGhlIHNlcnZlci1zaWRlIHN1cHBvcnRzIEpTT05QIG91dCB0aGUgYm94LiBIZXJlJiMzOTtzIGEgc25pcHBldCBvZiBjb2RlIHlvdSBjb3VsZCB1c2UgdG8gcHVsbCBkb3duIHRoZSB2aWV3IG1vZGVsIGFuZCBib290IFRhdW51cyB1cCBhcyBzb29uIGFzIGJvdGggb3BlcmF0aW9ucyBhcmUgcmVhZHkuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbmZ1bmN0aW9uIGluamVjdCAodXJsKSB7XFxuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgmIzM5O3NjcmlwdCYjMzk7KTtcXG4gIHNjcmlwdC5zcmMgPSB1cmw7XFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XFxufVxcblxcbmZ1bmN0aW9uIGluamVjdG9yICgpIHtcXG4gIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XFxuICB2YXIgc2VhcmNoUXVlcnkgPSBzZWFyY2ggPyAmIzM5OyZhbXA7JiMzOTsgKyBzZWFyY2guc3Vic3RyKDEpIDogJiMzOTsmIzM5OztcXG4gIHZhciBzZWFyY2hKc29uID0gJiMzOTs/anNvbiZhbXA7Y2FsbGJhY2s9dGF1bnVzUmVhZHkmIzM5OyArIHNlYXJjaFF1ZXJ5O1xcbiAgaW5qZWN0KGxvY2F0aW9uLnBhdGhuYW1lICsgc2VhcmNoSnNvbik7XFxufVxcblxcbndpbmRvdy50YXVudXNSZWFkeSA9IGZ1bmN0aW9uIChtb2RlbCkge1xcbiAgd2luZG93LnRhdW51c1JlYWR5ID0gbW9kZWw7XFxufTtcXG5cXG5pbmplY3RvcigpO1xcbjwvY29kZT48L3ByZT5cXG48cD5BcyBtZW50aW9uZWQgZWFybGllciwgdGhpcyBhcHByb2FjaCBpbnZvbHZlcyBnZXR0aW5nIHlvdXIgaGFuZHMgZGlydGllciBidXQgaXQgcGF5cyBvZmYgYnkgYmVpbmcgdGhlIGZhc3Rlc3Qgb2YgdGhlIHRocmVlLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcImNhY2hpbmdcXFwiPkNhY2hpbmc8L2g0PlxcbjxwPlRoZSBjbGllbnQtc2lkZSBpbiBUYXVudXMgc3VwcG9ydHMgY2FjaGluZyBpbi1tZW1vcnkgYW5kIHVzaW5nIHRoZSBlbWJlZGRlZCBJbmRleGVkREIgc3lzdGVtIGJ5IG1lcmVseSB0dXJuaW5nIG9uIHRoZSA8Y29kZT5jYWNoZTwvY29kZT4gZmxhZyBpbiB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPiBvbiB0aGUgY2xpZW50LXNpZGUuPC9wPlxcbjxwPklmIHlvdSBzZXQgPGNvZGU+Y2FjaGU8L2NvZGU+IHRvIDxjb2RlPnRydWU8L2NvZGU+IHRoZW4gY2FjaGVkIGl0ZW1zIHdpbGwgYmUgY29uc2lkZXJlZCA8ZW0+JnF1b3Q7ZnJlc2gmcXVvdDsgKHZhbGlkIGNvcGllcyBvZiB0aGUgb3JpZ2luYWwpPC9lbT4gZm9yIDxzdHJvbmc+MTUgc2Vjb25kczwvc3Ryb25nPi4gWW91IGNhbiBhbHNvIHNldCA8Y29kZT5jYWNoZTwvY29kZT4gdG8gYSBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBvZiBzZWNvbmRzIHdpbGwgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBpbnN0ZWFkLjwvcD5cXG48cD5DYWNoaW5nIGNhbiBhbHNvIGJlIHR3ZWFrZWQgb24gaW5kaXZpZHVhbCByb3V0ZXMuIEZvciBpbnN0YW5jZSwgeW91IGNvdWxkIHNldCA8Y29kZT57IGNhY2hlOiB0cnVlIH08L2NvZGU+IHdoZW4gbW91bnRpbmcgVGF1bnVzIGFuZCB0aGVuIGhhdmUgPGNvZGU+eyBjYWNoZTogMzYwMCB9PC9jb2RlPiBvbiBhIHJvdXRlIHRoYXQgeW91IHdhbnQgdG8gY2FjaGUgZm9yIGEgbG9uZ2VyIHBlcmlvZCBvZiB0aW1lLjwvcD5cXG48cD5UaGUgY2FjaGluZyBsYXllciBpcyA8ZW0+c2VhbWxlc3NseSBpbnRlZ3JhdGVkPC9lbT4gaW50byBUYXVudXMsIG1lYW5pbmcgdGhhdCBhbnkgdmlld3MgcmVuZGVyZWQgYnkgVGF1bnVzIHdpbGwgYmUgY2FjaGVkIGFjY29yZGluZyB0byB0aGVzZSBjYWNoaW5nIHJ1bGVzLiBLZWVwIGluIG1pbmQsIGhvd2V2ZXIsIHRoYXQgcGVyc2lzdGVuY2UgYXQgdGhlIGNsaWVudC1zaWRlIGNhY2hpbmcgbGF5ZXIgd2lsbCBvbmx5IGJlIHBvc3NpYmxlIGluIDxhIGhyZWY9XFxcImh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1pbmRleGVkZGJcXFwiPmJyb3dzZXJzIHRoYXQgc3VwcG9ydCBJbmRleGVkREI8L2E+LiBJbiB0aGUgY2FzZSBvZiBicm93c2VycyB0aGF0IGRvbiYjMzk7dCBzdXBwb3J0IEluZGV4ZWREQiwgVGF1bnVzIHdpbGwgdXNlIGFuIGluLW1lbW9yeSBjYWNoZSwgd2hpY2ggd2lsbCBiZSB3aXBlZCBvdXQgd2hlbmV2ZXIgdGhlIGh1bWFuIGRlY2lkZXMgdG8gY2xvc2UgdGhlIHRhYiBpbiB0aGVpciBicm93c2VyLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcInByZWZldGNoaW5nXFxcIj5QcmVmZXRjaGluZzwvaDQ+XFxuPHA+SWYgY2FjaGluZyBpcyBlbmFibGVkLCB0aGUgbmV4dCBsb2dpY2FsIHN0ZXAgaXMgcHJlZmV0Y2hpbmcuIFRoaXMgaXMgZW5hYmxlZCBqdXN0IGJ5IGFkZGluZyA8Y29kZT5wcmVmZXRjaDogdHJ1ZTwvY29kZT4gdG8gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4uIFRoZSBwcmVmZXRjaGluZyBmZWF0dXJlIHdpbGwgZmlyZSBmb3IgYW55IGFuY2hvciBsaW5rIHRoYXQmIzM5O3MgdHJpcHMgb3ZlciBhIDxjb2RlPm1vdXNlb3ZlcjwvY29kZT4gb3IgYSA8Y29kZT50b3VjaHN0YXJ0PC9jb2RlPiBldmVudC4gSWYgYSByb3V0ZSBtYXRjaGVzIHRoZSBVUkwgaW4gdGhlIDxjb2RlPmhyZWY8L2NvZGU+LCBhbiBBSkFYIHJlcXVlc3Qgd2lsbCBwcmVmZXRjaCB0aGUgdmlldyBhbmQgY2FjaGUgaXRzIGNvbnRlbnRzLCBpbXByb3ZpbmcgcGVyY2VpdmVkIHBlcmZvcm1hbmNlLjwvcD5cXG48cD5XaGVuIGxpbmtzIGFyZSBjbGlja2VkIGJlZm9yZSBwcmVmZXRjaGluZyBmaW5pc2hlcywgdGhleSYjMzk7bGwgd2FpdCBvbiB0aGUgcHJlZmV0Y2hlciB0byBmaW5pc2ggYmVmb3JlIGltbWVkaWF0ZWx5IHN3aXRjaGluZyB0byB0aGUgdmlldywgZWZmZWN0aXZlbHkgY3V0dGluZyBkb3duIHRoZSByZXNwb25zZSB0aW1lLiBJZiB0aGUgbGluayB3YXMgYWxyZWFkeSBwcmVmZXRjaGVkIG9yIG90aGVyd2lzZSBjYWNoZWQsIHRoZSB2aWV3IHdpbGwgYmUgbG9hZGVkIGltbWVkaWF0ZWx5LiBJZiB0aGUgaHVtYW4gaG92ZXJzIG92ZXIgYSBsaW5rIGFuZCBhbm90aGVyIG9uZSB3YXMgYWxyZWFkeSBiZWluZyBwcmVmZXRjaGVkLCB0aGVuIHRoYXQgb25lIGlzIGFib3J0ZWQuIFRoaXMgcHJldmVudHMgcHJlZmV0Y2hpbmcgZnJvbSBkcmFpbmluZyB0aGUgYmFuZHdpZHRoIG9uIGNsaWVudHMgd2l0aCBsaW1pdGVkIG9yIGludGVybWl0dGVudCBjb25uZWN0aXZpdHkuPC9wPlxcbjxoNCBpZD1cXFwidmVyc2lvbmluZ1xcXCI+VmVyc2lvbmluZzwvaDQ+XFxuPHA+V2hlbiBlbmFibGVkLCB2ZXJzaW9uaW5nIHdpbGwgbG9vayBvdXQgZm9yIGRpc2NyZXBhbmNpZXMgYmV0d2VlbiB3aGF0JiMzOTtzIGN1cnJlbnRseSBvbiB0aGUgY2xpZW50IGFuZCB3aGF0JiMzOTtzIG9uIHRoZSBzZXJ2ZXIsIGFuZCByZWxvYWQgZXZlcnl0aGluZyBuZWNlc3NhcnkgdG8gbWFrZSB3aGF0JiMzOTtzIG9uIHRoZSBjbGllbnQgbWF0Y2ggd2hhdCYjMzk7cyBvbiB0aGUgc2VydmVyLjwvcD5cXG48cD5JbiBvcmRlciB0byB0dXJuIGl0IG9uLCBzZXQgdGhlIDxjb2RlPnZlcnNpb248L2NvZGU+IGZpZWxkIGluIHRoZSBvcHRpb25zIHdoZW4gaW52b2tpbmcgPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPiA8c3Ryb25nPm9uIGJvdGggdGhlIHNlcnZlci1zaWRlIGFuZCB0aGUgY2xpZW50LXNpZGUsIHVzaW5nIHRoZSBzYW1lIHZhbHVlPC9zdHJvbmc+LiBUaGUgVGF1bnVzIHZlcnNpb24gc3RyaW5nIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG9uZSB5b3UgcHJvdmlkZWQsIHNvIHRoYXQgVGF1bnVzIHdpbGwga25vdyB0byBzdGF5IGFsZXJ0IGZvciBjaGFuZ2VzIHRvIFRhdW51cyBpdHNlbGYsIGFzIHdlbGwuPC9wPlxcbjxibG9ja3F1b3RlPlxcbjxwPlRvIG1ha2Ugc3VyZSB5b3UgZG9uJiMzOTt0IGZvcmdldCB0byBjaGFuZ2UgdGhlIHZlcnNpb24gc3RyaW5nIGluIG9uZSBvZiB0aGUgbW91bnRwb2ludHMsIHBsZWFzZSBjcmVhdGUgYSBKU09OIGZpbGUgd2l0aCBqdXN0IHRoZSB2ZXJzaW9uIHN0cmluZyBhbmQgPGNvZGU+cmVxdWlyZTwvY29kZT4gdGhhdCBmaWxlIGluIGJvdGggc2lkZXMuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPmVjaG8gJiMzOTsmcXVvdDsxLjAuMCZxdW90OyYjMzk7ICZndDsgdmVyc2lvbi5qc29uXFxuPC9jb2RlPjwvcHJlPlxcbjwvYmxvY2txdW90ZT5cXG48cD5UaGUgZGVmYXVsdCB2ZXJzaW9uIHN0cmluZyBpcyBzZXQgdG8gPGNvZGU+MTwvY29kZT4uIFRoZSBUYXVudXMgdmVyc2lvbiB3aWxsIGJlIHByZXBlbmRlZCB0byB5b3VycywgcmVzdWx0aW5nIGluIGEgdmFsdWUgc3VjaCBhcyA8Y29kZT50My4wLjA7djE8L2NvZGU+IHdoZXJlIFRhdW51cyBpcyBydW5uaW5nIHZlcnNpb24gPGNvZGU+My4wLjA8L2NvZGU+IGFuZCB5b3VyIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgdmVyc2lvbiA8Y29kZT4xPC9jb2RlPi48L3A+XFxuPHA+UmVmZXIgdG8gdGhlIEdldHRpbmcgU3RhcnRlZCBndWlkZSBmb3IgYSBtb3JlIGRldGFpbGVkIDxhIGhyZWY9XFxcIi9nZXR0aW5nLXN0YXJ0ZWQjdmVyc2lvbmluZ1xcXCI+YW5hbHlzaXMgb2YgdGhlIHVzZXMgZm9yIHZlcnNpb25pbmc8L2E+LiBUaGVyZSYjMzk7cyBzb21lIG1vcmUgbnVnZ2V0cyBvZiBpbmZvcm1hdGlvbiBpbiB0aGUgPGEgaHJlZj1cXFwiL3BlcmZvcm1hbmNlI3VzZS12ZXJzaW9uaW5nLXRvLWVuc3VyZS1jYWNoZS12YWxpZGl0eVxcXCI+UGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uPC9hPiBndWlkZSBhcyB3ZWxsLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtb24tdHlwZS1mbi1cXFwiPjxjb2RlPnRhdW51cy5vbih0eXBlLCBmbik8L2NvZGU+PC9oMj5cXG48cD5UYXVudXMgZW1pdHMgYSBzZXJpZXMgb2YgZXZlbnRzIGR1cmluZyBpdHMgbGlmZWN5Y2xlLCBhbmQgPGNvZGU+dGF1bnVzLm9uPC9jb2RlPiBpcyB0aGUgd2F5IHlvdSBjYW4gdHVuZSBpbiBhbmQgbGlzdGVuIGZvciB0aGVzZSBldmVudHMgdXNpbmcgYSBzdWJzY3JpcHRpb24gZnVuY3Rpb24gPGNvZGU+Zm48L2NvZGU+LjwvcD5cXG48dGFibGU+XFxuPHRoZWFkPlxcbjx0cj5cXG48dGg+RXZlbnQ8L3RoPlxcbjx0aD5Bcmd1bWVudHM8L3RoPlxcbjx0aD5EZXNjcmlwdGlvbjwvdGg+XFxuPC90cj5cXG48L3RoZWFkPlxcbjx0Ym9keT5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7c3RhcnQmIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5jb250YWluZXIsIG1vZGVsLCByb3V0ZTwvY29kZT48L3RkPlxcbjx0ZD5FbWl0dGVkIHdoZW4gPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPiBmaW5pc2hlZCB0aGUgcm91dGUgc2V0dXAgYW5kIGlzIGFib3V0IHRvIGludm9rZSB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlci4gU3Vic2NyaWJlIHRvIHRoaXMgZXZlbnQgYmVmb3JlIGNhbGxpbmcgPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPi48L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT4mIzM5O3JlbmRlciYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPmNvbnRhaW5lciwgbW9kZWwsIHJvdXRlPC9jb2RlPjwvdGQ+XFxuPHRkPkEgdmlldyBoYXMganVzdCBiZWVuIHJlbmRlcmVkIGFuZCBpdHMgY2xpZW50LXNpZGUgY29udHJvbGxlciBpcyBhYm91dCB0byBiZSBpbnZva2VkPC90ZD5cXG48L3RyPlxcbjx0cj5cXG48dGQ+PGNvZGU+JiMzOTtjaGFuZ2UmIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5yb3V0ZSwgbW9kZWw8L2NvZGU+PC90ZD5cXG48dGQ+U2FtZSBhcyA8Y29kZT4mIzM5O3JlbmRlciYjMzk7PC9jb2RlPiwgYnV0IG9ubHkgaWYgPGNvZGU+Y29udGFpbmVyPC9jb2RlPiBpcyB0aGUgbW91bnRwb2ludCBhbmQgdGhlIHJvdXRlIGhhcyBjaGFuZ2VkLjwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7ZmV0Y2guc3RhcnQmIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5yb3V0ZSwgY29udGV4dDwvY29kZT48L3RkPlxcbjx0ZD5FbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IHN0YXJ0cy48L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT4mIzM5O2ZldGNoLmRvbmUmIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5yb3V0ZSwgY29udGV4dCwgZGF0YTwvY29kZT48L3RkPlxcbjx0ZD5FbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IGVuZHMgc3VjY2Vzc2Z1bGx5LjwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7ZmV0Y2guYWJvcnQmIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5yb3V0ZSwgY29udGV4dDwvY29kZT48L3RkPlxcbjx0ZD5FbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IGlzIHB1cnBvc2VseSBhYm9ydGVkLjwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7ZmV0Y2guZXJyb3ImIzM5OzwvY29kZT48L3RkPlxcbjx0ZD48Y29kZT5yb3V0ZSwgY29udGV4dCwgZXJyPC9jb2RlPjwvdGQ+XFxuPHRkPkVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3QgcmVzdWx0cyBpbiBhbiBIVFRQIGVycm9yLjwvdGQ+XFxuPC90cj5cXG48L3Rib2R5PlxcbjwvdGFibGU+XFxuPHA+Q29uc2lkZXIgZm9yIGluc3RhbmNlIHRoYXQgeW91JiMzOTtkIGxpa2UgdG8ga2VlcCB0cmFjayBvZiBldmVyeSB2aWV3IHRoYXQgZ2V0cyByZW5kZXJlZCwgYW5kIHdoYXQgRE9NIGVsZW1lbnQgaXQgZ2V0cyBwbGFjZWQgaW50by4gVGhlIHBpZWNlIG9mIGNvZGUgYmVsb3cgd291bGQgcXVpY2tseSBkbyB0aGF0IGZvciB1cy48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+dGF1bnVzLm9uKCYjMzk7cmVuZGVyJiMzOTssIGZ1bmN0aW9uIChjb250YWluZXIpIHtcXG4gIGNvbnNvbGUubG9nKCYjMzk7UmVuZGVyZWQgYSB2aWV3IG9uJiMzOTssIGNvbnRhaW5lcik7XFxufSk7XFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiLXRhdW51cy1vbmNlLXR5cGUtZm4tXFxcIj48Y29kZT50YXVudXMub25jZSh0eXBlLCBmbik8L2NvZGU+PC9oMj5cXG48cD5UaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIDxhIGhyZWY9XFxcIiMtdGF1bnVzLW9uLXR5cGUtZm4tXFxcIj48Y29kZT50YXVudXMub248L2NvZGU+PC9hPiwgZXhjZXB0IHRoZSBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSB1c2VkIG9uY2UgYW5kIHRoZW4gaXQmIzM5O2xsIGJlIGRpc2NhcmRlZC48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItdGF1bnVzLW9mZi10eXBlLWZuLVxcXCI+PGNvZGU+dGF1bnVzLm9mZih0eXBlLCBmbik8L2NvZGU+PC9oMj5cXG48cD5Vc2luZyB0aGlzIG1ldGhvZCB5b3UgY2FuIHJlbW92ZSBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFkZGVkIHVzaW5nIDxjb2RlPi5vbjwvY29kZT4gb3IgPGNvZGU+Lm9uY2U8L2NvZGU+LiBZb3UgbXVzdCBwcm92aWRlIHRoZSB0eXBlIG9mIGV2ZW50IHlvdSB3YW50IHRvIHJlbW92ZSBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uIHRoYXQgd2FzIG9yaWdpbmFsbHkgdXNlZCB3aGVuIGNhbGxpbmcgPGNvZGU+Lm9uPC9jb2RlPiBvciA8Y29kZT4ub25jZTwvY29kZT4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiLXRhdW51cy1pbnRlcmNlcHQtYWN0aW9uLWZuLVxcXCI+PGNvZGU+dGF1bnVzLmludGVyY2VwdChhY3Rpb24/LCBmbik8L2NvZGU+PC9oMj5cXG48cD5UaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBhbnRpY2lwYXRlIG1vZGVsIHJlcXVlc3RzLCBiZWZvcmUgdGhleSBldmVyIG1ha2UgaXQgaW50byBYSFIgcmVxdWVzdHMuIFlvdSBjYW4gYWRkIGludGVyY2VwdG9ycyBmb3Igc3BlY2lmaWMgYWN0aW9ucywgd2hpY2ggd291bGQgYmUgdHJpZ2dlcmVkIG9ubHkgaWYgdGhlIHJlcXVlc3QgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIDxjb2RlPmFjdGlvbjwvY29kZT4uIFlvdSBjYW4gYWxzbyBhZGQgZ2xvYmFsIGludGVyY2VwdG9ycyBieSBvbWl0dGluZyB0aGUgPGNvZGU+YWN0aW9uPC9jb2RlPiBwYXJhbWV0ZXIsIG9yIHNldHRpbmcgaXQgdG8gPGNvZGU+KjwvY29kZT4uPC9wPlxcbjxwPkFuIGludGVyY2VwdG9yIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhbiA8Y29kZT5ldmVudDwvY29kZT4gcGFyYW1ldGVyLCBjb250YWluaW5nIGEgZmV3IGRpZmZlcmVudCBwcm9wZXJ0aWVzLjwvcD5cXG48dWw+XFxuPGxpPjxjb2RlPnVybDwvY29kZT4gY29udGFpbnMgdGhlIFVSTCB0aGF0IG5lZWRzIGEgdmlldyBtb2RlbDwvbGk+XFxuPGxpPjxjb2RlPnJvdXRlPC9jb2RlPiBjb250YWlucyB0aGUgZnVsbCByb3V0ZSBvYmplY3QgYXMgeW91JiMzOTtkIGdldCBmcm9tIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXJvdXRlLXVybC1zdGFydGluZGV4LVxcXCI+PGNvZGU+dGF1bnVzLnJvdXRlKHVybCwgc3RhcnRJbmRleD8pPC9jb2RlPjwvYT48L2xpPlxcbjxsaT48Y29kZT5wYXJ0czwvY29kZT4gaXMganVzdCBhIHNob3J0Y3V0IGZvciA8Y29kZT5yb3V0ZS5wYXJ0czwvY29kZT48L2xpPlxcbjxsaT48Y29kZT5wcmV2ZW50RGVmYXVsdChkYXRhKTwvY29kZT4gYWxsb3dzIHlvdSB0byBzdXBwcmVzcyB0aGUgbmVlZCBmb3IgYW4gQUpBWCByZXF1ZXN0LCBjb21tYW5kaW5nIFRhdW51cyB0byB1c2UgdGhlIHJlc3BvbnNlIGRhdGEgeW91JiMzOTt2ZSBwcm92aWRlZCBpbnN0ZWFkPC9saT5cXG48bGk+PGNvZGU+ZGVmYXVsdFByZXZlbnRlZDwvY29kZT4gdGVsbHMgeW91IGlmIHNvbWUgb3RoZXIgaGFuZGxlciBoYXMgcHJldmVudGVkIHRoZSBkZWZhdWx0IGJlaGF2aW9yPC9saT5cXG48bGk+PGNvZGU+Y2FuUHJldmVudERlZmF1bHQ8L2NvZGU+IHRlbGxzIHlvdSBpZiBpbnZva2luZyA8Y29kZT5ldmVudC5wcmV2ZW50RGVmYXVsdDwvY29kZT4gd2lsbCBoYXZlIGFueSBlZmZlY3Q8L2xpPlxcbjxsaT48Y29kZT5kYXRhPC9jb2RlPiBzdGFydHMgYXMgPGNvZGU+bnVsbDwvY29kZT4sIGFuZCBpdCBjYW4gbGF0ZXIgYmVjb21lIHRoZSBkYXRhIHBhc3NlZCB0byA8Y29kZT5wcmV2ZW50RGVmYXVsdDwvY29kZT48L2xpPlxcbjwvdWw+XFxuPHA+SW50ZXJjZXB0b3JzIGFyZSBhc3luY2hyb25vdXMsIGJ1dCBpZiBhbiBpbnRlcmNlcHRvciBzcGVuZHMgbG9uZ2VyIHRoYW4gNTBtcyBpdCYjMzk7bGwgYmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBjYWxsaW5nIDxjb2RlPmV2ZW50LnByZXZlbnREZWZhdWx0PC9jb2RlPiBwYXN0IHRoYXQgcG9pbnQgd29uJiMzOTt0IGhhdmUgYW55IGVmZmVjdC48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItdGF1bnVzLXBhcnRpYWwtY29udGFpbmVyLWFjdGlvbi1tb2RlbC1cXFwiPjxjb2RlPnRhdW51cy5wYXJ0aWFsKGNvbnRhaW5lciwgYWN0aW9uLCBtb2RlbCk8L2NvZGU+PC9oMj5cXG48cD5UaGlzIG1ldGhvZCBwcm92aWRlcyB5b3Ugd2l0aCBhY2Nlc3MgdG8gdGhlIHZpZXctcmVuZGVyaW5nIGVuZ2luZSBvZiBUYXVudXMuIFlvdSBjYW4gdXNlIGl0IHRvIHJlbmRlciB0aGUgPGNvZGU+YWN0aW9uPC9jb2RlPiB2aWV3IGludG8gdGhlIDxjb2RlPmNvbnRhaW5lcjwvY29kZT4gRE9NIGVsZW1lbnQsIHVzaW5nIHRoZSBzcGVjaWZpZWQgPGNvZGU+bW9kZWw8L2NvZGU+LiBPbmNlIHRoZSB2aWV3IGlzIHJlbmRlcmVkLCB0aGUgPGNvZGU+cmVuZGVyPC9jb2RlPiBldmVudCB3aWxsIGJlIGZpcmVkIDxlbT4od2l0aCA8Y29kZT5jb250YWluZXIsIG1vZGVsPC9jb2RlPiBhcyBhcmd1bWVudHMpPC9lbT4gYW5kIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyIGZvciB0aGF0IHZpZXcgd2lsbCBiZSBleGVjdXRlZC48L3A+XFxuPHA+Tm90ZSB0aGF0IHRoZSBwYXJ0aWFsIG1heSBiZSByZW5kZXJlZCBhc3luY2hyb25vdXNseSBpZiB0aGUgPGNvZGU+YWN0aW9uPC9jb2RlPiBpcyA8YSBocmVmPVxcXCIjLWRlZmVyLWFjdGlvbnMtXFxcIj5kZWZlcnJlZDwvYT4gYW5kIGl0cyBjb21wb25lbnRzICh2aWV3IHRlbXBsYXRlLCBjb250cm9sbGVyKSBhcmVuJiMzOTt0IHJlYWRpbHkgYXZhaWxhYmxlIGluIHRoZSBjbGllbnQgeWV0LjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtbmF2aWdhdGUtdXJsLW9wdGlvbnMtXFxcIj48Y29kZT50YXVudXMubmF2aWdhdGUodXJsLCBvcHRpb25zKTwvY29kZT48L2gyPlxcbjxwPldoZW5ldmVyIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvIGEgVVJMLCBzYXkgd2hlbiBhbiBBSkFYIGNhbGwgZmluaXNoZXMgYWZ0ZXIgYSBidXR0b24gY2xpY2ssIHlvdSBjYW4gdXNlIDxjb2RlPnRhdW51cy5uYXZpZ2F0ZTwvY29kZT4gcGFzc2luZyBpdCBhIHBsYWluIFVSTCBvciBhbnl0aGluZyB0aGF0IHdvdWxkIGNhdXNlIDxjb2RlPnRhdW51cy5yb3V0ZSh1cmwsIHN0YXJ0SW5kZXg/KTwvY29kZT4gdG8gcmV0dXJuIGEgdmFsaWQgcm91dGUuPC9wPlxcbjxwPkJ5IGRlZmF1bHQsIGlmIDxjb2RlPnRhdW51cy5uYXZpZ2F0ZSh1cmwsIG9wdGlvbnMpPC9jb2RlPiBpcyBjYWxsZWQgd2l0aCBhbiA8Y29kZT51cmw8L2NvZGU+IHRoYXQgZG9lc24mIzM5O3QgbWF0Y2ggYW55IGNsaWVudC1zaWRlIHJvdXRlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgcmVkaXJlY3RlZCB2aWEgPGNvZGU+bG9jYXRpb24uaHJlZjwvY29kZT4uIEluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyIGRvZXNuJiMzOTt0IHN1cHBvcnQgdGhlIGhpc3RvcnkgQVBJLCA8Y29kZT5sb2NhdGlvbi5ocmVmPC9jb2RlPiB3aWxsIGJlIHVzZWQgYXMgd2VsbC48L3A+XFxuPHA+VGhlcmUmIzM5O3MgYSBmZXcgb3B0aW9ucyB5b3UgY2FuIHVzZSB0byB0d2VhayB0aGUgYmVoYXZpb3Igb2YgPGNvZGU+dGF1bnVzLm5hdmlnYXRlPC9jb2RlPi48L3A+XFxuPHRhYmxlPlxcbjx0aGVhZD5cXG48dHI+XFxuPHRoPk9wdGlvbjwvdGg+XFxuPHRoPkRlc2NyaXB0aW9uPC90aD5cXG48L3RyPlxcbjwvdGhlYWQ+XFxuPHRib2R5Plxcbjx0cj5cXG48dGQ+PGNvZGU+Y29udGV4dDwvY29kZT48L3RkPlxcbjx0ZD5BIERPTSBlbGVtZW50IHRoYXQgY2F1c2VkIHRoZSBuYXZpZ2F0aW9uIGV2ZW50LCB1c2VkIHdoZW4gZW1pdHRpbmcgZXZlbnRzPC90ZD5cXG48L3RyPlxcbjx0cj5cXG48dGQ+PGNvZGU+c3RyaWN0PC9jb2RlPjwvdGQ+XFxuPHRkPklmIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiBhbmQgdGhlIFVSTCBkb2VzbiYjMzk7dCBtYXRjaCBhbnkgcm91dGUsIHRoZW4gdGhlIG5hdmlnYXRpb24gYXR0ZW1wdCBtdXN0IGJlIGlnbm9yZWQ8L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT5zY3JvbGw8L2NvZGU+PC90ZD5cXG48dGQ+V2hlbiB0aGlzIGlzIHNldCB0byA8Y29kZT5mYWxzZTwvY29kZT4sIGVsZW1lbnRzIGFyZW4mIzM5O3Qgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIG5hdmlnYXRpb248L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT5mb3JjZTwvY29kZT48L3RkPlxcbjx0ZD5Vbmxlc3MgdGhpcyBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4sIG5hdmlnYXRpb24gd29uJiMzOTt0IDxlbT5mZXRjaCBhIG1vZGVsPC9lbT4gaWYgdGhlIHJvdXRlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcm91dGUsIGFuZCA8Y29kZT5zdGF0ZS5tb2RlbDwvY29kZT4gd2lsbCBiZSByZXVzZWQgaW5zdGVhZDwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPnJlcGxhY2VTdGF0ZTwvY29kZT48L3RkPlxcbjx0ZD5Vc2UgPGNvZGU+cmVwbGFjZVN0YXRlPC9jb2RlPiBpbnN0ZWFkIG9mIDxjb2RlPnB1c2hTdGF0ZTwvY29kZT4gd2hlbiBjaGFuZ2luZyBoaXN0b3J5PC90ZD5cXG48L3RyPlxcbjwvdGJvZHk+XFxuPC90YWJsZT5cXG48cD5Ob3RlIHRoYXQgdGhlIG5vdGlvbiBvZiA8ZW0+ZmV0Y2hpbmcgYSBtb2RlbDwvZW0+IG1pZ2h0IGJlIGRlY2VpdmluZyBhcyB0aGUgbW9kZWwgY291bGQgYmUgcHVsbGVkIGZyb20gdGhlIGNhY2hlIGV2ZW4gaWYgPGNvZGU+Zm9yY2U8L2NvZGU+IGlzIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItdGF1bnVzLXJvdXRlLXVybC1zdGFydGluZGV4LVxcXCI+PGNvZGU+dGF1bnVzLnJvdXRlKHVybCwgc3RhcnRJbmRleD8pPC9jb2RlPjwvaDI+XFxuPHA+VGhpcyBjb252ZW5pZW5jZSBtZXRob2QgYWxsb3dzIHlvdSB0byBicmVhayBkb3duIGEgVVJMIGludG8gaXRzIGluZGl2aWR1YWwgY29tcG9uZW50cy4gVGhlIG1ldGhvZCBhY2NlcHRzIGFueSBvZiB0aGUgZm9sbG93aW5nIFVSTCBwYXR0ZXJucywgYW5kIGl0IHJldHVybnMgYSBUYXVudXMgcm91dGUgb2JqZWN0LiBUaGUgb3B0aW9uYWwgPGNvZGU+c3RhcnRJbmRleDwvY29kZT4gYXJndW1lbnQgc3BlY2lmaWVzIHdoYXQgaW5kZXggdG8gc3RhcnQgYXQsIGFzIHNlZW4gb24gPGNvZGU+dGF1bnVzLnN0YXRlLnJvdXRlczwvY29kZT4uPC9wPlxcbjx1bD5cXG48bGk+QSBmdWxseSBxdWFsaWZpZWQgVVJMIG9uIHRoZSBzYW1lIG9yaWdpbiwgZS5nIDxjb2RlPmh0dHA6Ly90YXVudXMuYmV2YWNxdWEuaW8vYXBpPC9jb2RlPjwvbGk+XFxuPGxpPkFuIGFic29sdXRlIFVSTCB3aXRob3V0IGFuIG9yaWdpbiwgZS5nIDxjb2RlPi9hcGk8L2NvZGU+PC9saT5cXG48bGk+SnVzdCBhIGhhc2gsIGUuZyA8Y29kZT4jZm9vPC9jb2RlPiA8ZW0+KDxjb2RlPmxvY2F0aW9uLmhyZWY8L2NvZGU+IGlzIHVzZWQpPC9lbT48L2xpPlxcbjxsaT5GYWxzeSB2YWx1ZXMsIGUuZyA8Y29kZT5udWxsPC9jb2RlPiA8ZW0+KDxjb2RlPmxvY2F0aW9uLmhyZWY8L2NvZGU+IGlzIHVzZWQpPC9lbT48L2xpPlxcbjwvdWw+XFxuPHA+UmVsYXRpdmUgVVJMcyBhcmUgbm90IHN1cHBvcnRlZCA8ZW0+KGFueXRoaW5nIHRoYXQgZG9lc24mIzM5O3QgaGF2ZSBhIGxlYWRpbmcgc2xhc2gpPC9lbT4sIGUuZyA8Y29kZT5maWxlcy9kYXRhLmpzb248L2NvZGU+LiBBbnl0aGluZyB0aGF0JiMzOTtzIG5vdCBvbiB0aGUgc2FtZSBvcmlnaW4gb3IgZG9lc24mIzM5O3QgbWF0Y2ggb25lIG9mIHRoZSByZWdpc3RlcmVkIHJvdXRlcyBpcyBnb2luZyB0byB5aWVsZCA8Y29kZT5udWxsPC9jb2RlPi48L3A+XFxuPHA+PGVtPlRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiBkZWJ1Z2dpbmcgeW91ciByb3V0aW5nIHRhYmxlcywgYXMgaXQgZ2l2ZXMgeW91IGRpcmVjdCBhY2Nlc3MgdG8gdGhlIHJvdXRlciB1c2VkIGludGVybmFsbHkgYnkgVGF1bnVzLjwvZW0+PC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwiLXRhdW51cy1yb3V0ZS1lcXVhbHMtcm91dGUtcm91dGUtXFxcIj48Y29kZT50YXVudXMucm91dGUuZXF1YWxzKHJvdXRlLCByb3V0ZSk8L2NvZGU+PC9oND5cXG48cD5Db21wYXJlcyB0d28gcm91dGVzIGFuZCByZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgd291bGQgZmV0Y2ggdGhlIHNhbWUgbW9kZWwuIE5vdGUgdGhhdCBkaWZmZXJlbnQgVVJMcyBtYXkgc3RpbGwgcmV0dXJuIDxjb2RlPnRydWU8L2NvZGU+LiBGb3IgaW5zdGFuY2UsIDxjb2RlPi9mb288L2NvZGU+IGFuZCA8Y29kZT4vZm9vI2JhcjwvY29kZT4gd291bGQgZmV0Y2ggdGhlIHNhbWUgbW9kZWwgZXZlbiBpZiB0aGV5JiMzOTtyZSBkaWZmZXJlbnQgVVJMcy48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgyIGlkPVxcXCItdGF1bnVzLXJlc29sdmUtb24tdGhlLWNsaWVudFxcXCI+PGNvZGU+dGF1bnVzLnJlc29sdmU8L2NvZGU+IG9uIHRoZSBjbGllbnQ8L2gyPlxcbjxwPlRoaXMgbWV0aG9kIGlzIGlkZW50aWNhbCB0byB0aGUgc2VydmVyLXNpZGUgZmxhdm9yIG9mIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXJlc29sdmUtYWN0aW9uLWRhdGEtXFxcIj48Y29kZT50YXVudXMucmVzb2x2ZShhY3Rpb24sIGRhdGEpPC9jb2RlPjwvYT4sIGJ1dCBhdmFpbGFibGUgb24gdGhlIGNsaWVudC1zaWRlLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMtc3RhdGUtXFxcIj48Y29kZT50YXVudXMuc3RhdGU8L2NvZGU+PC9oMj5cXG48cD5UaGlzIGlzIGFuIGludGVybmFsIHN0YXRlIHZhcmlhYmxlLCBhbmQgaXQgY29udGFpbnMgYSBsb3Qgb2YgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvbi48L3A+XFxuPHVsPlxcbjxsaT48Y29kZT5jb250YWluZXI8L2NvZGU+IGlzIHRoZSBET00gZWxlbWVudCBwYXNzZWQgdG8gPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPjwvbGk+XFxuPGxpPjxjb2RlPmNvbnRyb2xsZXJzPC9jb2RlPiBhcmUgYWxsIHRoZSBjb250cm9sbGVycywgYXMgZGVmaW5lZCBpbiB0aGUgd2lyaW5nIG1vZHVsZTwvbGk+XFxuPGxpPjxjb2RlPnRlbXBsYXRlczwvY29kZT4gYXJlIGFsbCB0aGUgdGVtcGxhdGVzLCBhcyBkZWZpbmVkIGluIHRoZSB3aXJpbmcgbW9kdWxlPC9saT5cXG48bGk+PGNvZGU+cm91dGVzPC9jb2RlPiBhcmUgYWxsIHRoZSByb3V0ZXMsIGFzIGRlZmluZWQgaW4gdGhlIHdpcmluZyBtb2R1bGU8L2xpPlxcbjxsaT48Y29kZT5yb3V0ZTwvY29kZT4gaXMgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcm91dGU8L2xpPlxcbjxsaT48Y29kZT5tb2RlbDwvY29kZT4gaXMgYSByZWZlcmVuY2UgdG8gdGhlIG1vZGVsIHVzZWQgdG8gcmVuZGVyIHRoZSBjdXJyZW50IHZpZXc8L2xpPlxcbjxsaT48Y29kZT5wcmVmZXRjaDwvY29kZT4gZXhwb3NlcyB3aGV0aGVyIHByZWZldGNoaW5nIGlzIHR1cm5lZCBvbjwvbGk+XFxuPGxpPjxjb2RlPmNhY2hlPC9jb2RlPiBleHBvc2VzIHdoZXRoZXIgY2FjaGluZyBpcyBlbmFibGVkPC9saT5cXG48bGk+PGNvZGU+dmVyc2lvbjwvY29kZT4gZXhwb3NlcyB0aGUgdmVyc2lvbiBzdHJpbmcgdGhhdCYjMzk7cyBjdXJyZW50bHkgaW4gdXNlPC9saT5cXG48L3VsPlxcbjxwPlRoZXJlJiMzOTtzIGFsc28gYSA8Y29kZT5jbGVhcjwvY29kZT4gbWV0aG9kIGFjY2Vzc2libGUgdGhyb3VnaCA8Y29kZT50YXVudXMuc3RhdGUuY2xlYXI8L2NvZGU+LCB3aGljaCB3aWxsIGVtcHR5IHRoZSBjYWNoZSwgYXMgd2VsbCBhcyByZW1vdmUgZnJvbSB0aGUgPGNvZGU+c3RhdGU8L2NvZGU+IGFueSBjb250cm9sbGVycyBhbmQgdGVtcGxhdGVzIHRoYXQgd2VyZSBsYXp5IGxvYWRlZC48L3A+XFxuPHA+T2YgY291cnNlLCB5b3UmIzM5O3JlIG5vdCBzdXBwb3NlZCB0byBtZWRkbGUgd2l0aCBpdCwgc28gYmUgYSBnb29kIGNpdGl6ZW4gYW5kIGp1c3QgaW5zcGVjdCBpdHMgdmFsdWVzITwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDIgaWQ9XFxcIi10YXVudXMteGhyLXVybC1vcHRpb25zLWRvbmUtXFxcIj48Y29kZT50YXVudXMueGhyKHVybCwgb3B0aW9ucz8sIGRvbmUpPC9jb2RlPjwvaDI+XFxuPHA+VGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBpc3N1ZSB5b3VyIG93biBBSkFYIHJlcXVlc3RzIHRocm91Z2ggdGhlIDxjb2RlPnhocjwvY29kZT4gbW9kdWxlLiBJdCBzZXRzIGEgZmV3IGNvbnZlbmllbnQgZGVmYXVsdHMsIDxlbT5saXN0ZWQgYmVsb3c8L2VtPiwgd2hlcmUgPGNvZGU+dXJsPC9jb2RlPiByZWZlcnMgdG8gdGhlIFVSTCBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+e1xcbiAgdXJsOiB1cmwsXFxuICBqc29uOiB0cnVlLFxcbiAgaGVhZGVyczogeyBBY2NlcHQ6ICYjMzk7YXBwbGljYXRpb24vanNvbiYjMzk7IH1cXG59XFxuPC9jb2RlPjwvcHJlPlxcbjxwPlRoZSA8Y29kZT5kb25lKGVyciwgYm9keSwgcmVzKTwvY29kZT4gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMsIGFuZCBpdCYjMzk7bGwgYmUgcGFzc2VkIHRocmVlIHBhcmFtZXRlcnMsIGFuIG9wdGlvbmFsIGVycm9yIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nIDxlbT4ocmVxdWVzdCBmYWlsZWQsIHdhcyBhYm9ydGVkLCBldGMuKTwvZW0+IGFuZCBhIDxjb2RlPmJvZHk8L2NvZGU+IHBhcmFtZXRlciBjb250YWluaW5nIHRoZSByZXNwb25zZSBib2R5LiBUaGUgcmF3IDxjb2RlPnJlczwvY29kZT4gb2JqZWN0IHRoYXQmIzM5O3MgdHlwaWNhbGx5IHByb3ZpZGVkIGJ5IDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXFxcIj48Y29kZT54aHI8L2NvZGU+PC9hPiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBwcm92aWRlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIGluc3RlYWQuPC9wPlxcbjxwPkFzIGFuIGV4YW1wbGUsIGhlcmUgaXMgYSA8Y29kZT5HRVQ8L2NvZGU+IHJlcXVlc3QuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPnRhdW51cy54aHIoJiMzOTsvYXBpL3BsYWNlcyYjMzk7LCBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XFxuICBjb25zb2xlLmxvZyhib2R5KTtcXG4gIC8vICZsdDstIHsgcGxhY2VzOiBbJiMzOTt1bmRlcndhdGVyIGZvcnRyZXNzJiMzOTssICYjMzk7aXNsYW5kIG1hbnNpb24mIzM5O10gfVxcbn0pO1xcbjwvY29kZT48L3ByZT5cXG48cD5BbHdheXMgcmVtZW1iZXIgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIDxjb2RlPmVycjwvY29kZT4gaXMgc2V0ITwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDEgaWQ9XFxcInVzaW5nLXRhdW51cy1wcmVmZXRjaC11cmwtZWxlbWVudC1cXFwiPlVzaW5nIDxjb2RlPnRhdW51cy5wcmVmZXRjaCh1cmwsIGVsZW1lbnQpPC9jb2RlPjwvaDE+XFxuPHA+VGhlIHByZWZldGNoZXIgQVBJIGFsbG93cyB5b3UgdG8gc3RhcnQgZmV0Y2hpbmcgYW4gPGNvZGU+dXJsPC9jb2RlPiwgcHJvdmlkZWQgdGhhdCBpdCBtYXRjaGVzIGEga25vd24gVGF1bnVzIHZpZXcgcm91dGUgYW5kIHRoYXQgPGEgaHJlZj1cXFwiI2NhY2hpbmdcXFwiPnRoZSBjYWNoZTwvYT4gaXMgZW5hYmxlZC4gVGhlIDxjb2RlPmVsZW1lbnQ8L2NvZGU+IGlzIHVzZWQgbW9zdGx5IGFzIGNvbnRleHQgZHVyaW5nIGV2ZW50IGVtaXNzaW9uLCBhbmQgaXQgY2FuIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nIGFzIHdlbGwuPC9wPlxcbjxwPlVzZSBjYXNlcyBmb3IgcHJlZmV0Y2hpbmcgYXJlIGZ1cnRoZXIgZGlzY3Vzc2VkIGluIHRoZSA8YSBocmVmPVxcXCIvcGVyZm9ybWFuY2UjZW5hYmxlLXByZWZldGNoaW5nLWZvci1wcmVkaWN0aXZlLWNhY2hlLWxvYWRpbmdcXFwiPlBlcmZvcm1hbmNlIE9wdGltaXphdGlvbjwvYT4gZ3VpZGUuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMiBpZD1cXFwiZGVidWdnaW5nLXRhdW51c1xcXCI+RGVidWdnaW5nIFRhdW51czwvaDI+XFxuPHA+T24gdGhlIGNsaWVudC1zaWRlLCB5b3Ugd2lsbCB0eXBpY2FsbHkgPGNvZGU+cmVxdWlyZTwvY29kZT4gVGF1bnVzIHVzaW5nIHRoZSBzdGF0ZW1lbnQgYmVsb3cuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPnZhciB0YXVudXMgPSByZXF1aXJlKCYjMzk7dGF1bnVzJiMzOTspO1xcbjwvY29kZT48L3ByZT5cXG48cD5Ib3dldmVyLCB5b3UgY291bGQgYWxzbyB0dXJuIG9uIHRoZSBpbnRlcm5hbCBkZWJ1ZyBsb2dnZXIgc2ltcGx5IGJ5IHVzaW5nIGFub3RoZXIgZW50cnkgcG9pbnQhPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPnZhciB0YXVudXMgPSByZXF1aXJlKCYjMzk7dGF1bnVzL2Jyb3dzZXIvZGVidWcmIzM5Oyk7XFxuPC9jb2RlPjwvcHJlPlxcbjxwPlRoZSBzY3JlZW5zaG90IGJlbG93IGNvbnRhaW5zIGFuIGV4YW1wbGUgb2YgdGhpcyBtZWNoYW5pc20sIHdoZXJlIHVzaW5nIDxhIGhyZWY9XFxcIiMtdGF1bnVzLXBhcnRpYWwtY29udGFpbmVyLWFjdGlvbi1tb2RlbC1cXFwiPjxjb2RlPnRhdW51cy5wYXJ0aWFsPC9jb2RlPjwvYT4gdHJpZ2dlcnMgYSBmbHVycnkgb2YgZGVidWcgbWVzc2FnZXMuPC9wPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vQ2piSUh5MC5wbmdcXFwiIGFsdD1cXFwiZGVidWcucG5nXFxcIj48L3A+XFxuPHA+VGhpcyBpcyBwYXJ0aWN1bGFybHkgaGVscGZ1bCBkdXJpbmcgZGV2ZWxvcG1lbnQsIGJ1dCBhbHNvIHVzZWZ1bCBpZiB5b3UgZG9uJiMzOTt0IHVuZGVyc3RhbmQgZXhhY3RseSBob3cgVGF1bnVzIGlzIGRvaW5nIHNvbWV0aGluZywgYXMgdGhlIGxvZ2dlciBpcyBwcmV0dHkgdmVyYm9zZS48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJjbGllbnQtc2lkZS1jb250cm9sbGVyc1xcXCI+Q2xpZW50LVNpZGUgQ29udHJvbGxlcnM8L2gxPlxcbjxwPkNsaWVudC1zaWRlIGNvbnRyb2xsZXJzIGFyZSBleGVjdXRlZCByaWdodCBhZnRlciBhIHZpZXcgaXMgcmVuZGVyZWQsIGV2ZW4gaW4gdGhlIGNhc2Ugb2YgPGEgaHJlZj1cXFwiIy10YXVudXMtcGFydGlhbC1jb250YWluZXItYWN0aW9uLW1vZGVsLVxcXCI+cGFydGlhbCB2aWV3czwvYT4uIFRoZXNlIGNvbnRyb2xsZXJzIGFyZSB1c2VkIHRvIHByb2dyZXNzaXZlbHkgYWRkIGJlaGF2aW9yIG9uIHRvcCBvZiB0aGUgSFRNTCBmb3IgdGhhdCB2aWV3LjwvcD5cXG48cD5WaWV3IGNvbnRyb2xsZXJzIHRha2UgdGhyZWUgcGFyYW1ldGVycy48L3A+XFxuPHRhYmxlPlxcbjx0aGVhZD5cXG48dHI+XFxuPHRoPlBhcmFtZXRlcjwvdGg+XFxuPHRoPkRlc2NyaXB0aW9uPC90aD5cXG48L3RyPlxcbjwvdGhlYWQ+XFxuPHRib2R5Plxcbjx0cj5cXG48dGQ+PGNvZGU+bW9kZWw8L2NvZGU+PC90ZD5cXG48dGQ+TW9kZWwgdGhhdCB3YXMgdXNlZCB0byByZW5kZXIgdGhlIHZpZXc8L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT5jb250YWluZXI8L2NvZGU+PC90ZD5cXG48dGQ+VGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSB2aWV3IHdhcyByZW5kZXJlZDwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPnJvdXRlPzwvY29kZT48L3RkPlxcbjx0ZD5Sb3V0ZSB0aGF0IHRyaWdnZXJlZCB0aGUgcmVuZGVyaW5nIGVuZ2luZS4gTWF5IGJlIDxjb2RlPm51bGw8L2NvZGU+PC90ZD5cXG48L3RyPlxcbjwvdGJvZHk+XFxuPC90YWJsZT5cXG48cD5Ob3RlIHRoYXQgVGF1bnVzIHdpbGwgPGEgaHJlZj1cXFwiIy10YXVudXMtb24tdHlwZS1mbi1cXFwiPmVtaXQgYSA8Y29kZT5yZW5kZXI8L2NvZGU+IGV2ZW50PC9hPiByaWdodCBiZWZvcmUgdGhlIHZpZXcgY29udHJvbGxlciBnZXRzIGV4ZWN1dGVkLCBnaXZpbmcgeW91IGEgY2hhbmNlIHRvIHJlYWN0IHRvIHZpZXdzIGdldHRpbmcgcmVuZGVyZWQuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMSBpZD1cXFwidGhlLXRhdW51c3JjLW1hbmlmZXN0XFxcIj5UaGUgPGNvZGU+LnRhdW51c3JjPC9jb2RlPiBtYW5pZmVzdDwvaDE+XFxuPHA+SWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlcyBvdGhlciB0aGFuIHRoZSBjb252ZW50aW9uYWwgZGVmYXVsdHMgc2hvd24gaW4gdGhlIHRhYmxlIGJlbG93LCB0aGVuIHlvdSBzaG91bGQgY3JlYXRlIGEgPGNvZGU+LnRhdW51c3JjPC9jb2RlPiBmaWxlLiBOb3RlIHRoYXQgdGhlIGRlZmF1bHRzIG5lZWQgdG8gYmUgb3ZlcndyaXR0ZW4gaW4gYSBjYXNlLWJ5LWNhc2UgYmFzaXMuIFRoZXNlIG9wdGlvbnMgY2FuIGFsc28gYmUgY29uZmlndXJlZCBpbiB5b3VyIDxjb2RlPnBhY2thZ2UuanNvbjwvY29kZT4sIHVuZGVyIHRoZSA8Y29kZT50YXVudXM8L2NvZGU+IHByb3BlcnR5LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWpzb25cXFwiPntcXG4gICZxdW90O3ZpZXdzJnF1b3Q7OiAmcXVvdDsuYmluL3ZpZXdzJnF1b3Q7LFxcbiAgJnF1b3Q7c2VydmVyX3JvdXRlcyZxdW90OzogJnF1b3Q7Y29udHJvbGxlcnMvcm91dGVzLmpzJnF1b3Q7LFxcbiAgJnF1b3Q7c2VydmVyX2NvbnRyb2xsZXJzJnF1b3Q7OiAmcXVvdDtjb250cm9sbGVycyZxdW90OyxcXG4gICZxdW90O2NsaWVudF9jb250cm9sbGVycyZxdW90OzogJnF1b3Q7Y2xpZW50L2pzL2NvbnRyb2xsZXJzJnF1b3Q7LFxcbiAgJnF1b3Q7Y2xpZW50X3dpcmluZyZxdW90OzogJnF1b3Q7LmJpbi93aXJpbmcuanMmcXVvdDtcXG59XFxuPC9jb2RlPjwvcHJlPlxcbjx1bD5cXG48bGk+VGhlIDxjb2RlPnZpZXdzPC9jb2RlPiBkaXJlY3RvcnkgaXMgd2hlcmUgeW91ciB2aWV3cyA8ZW0+KGFscmVhZHkgY29tcGlsZWQgaW50byBKYXZhU2NyaXB0KTwvZW0+IGFyZSBwbGFjZWQuIFRoZXNlIHZpZXdzIGFyZSB1c2VkIGRpcmVjdGx5IG9uIGJvdGggdGhlIHNlcnZlci1zaWRlIGFuZCB0aGUgY2xpZW50LXNpZGU8L2xpPlxcbjxsaT5UaGUgPGNvZGU+c2VydmVyX3JvdXRlczwvY29kZT4gZmlsZSBpcyB0aGUgbW9kdWxlIHdoZXJlIHlvdSBleHBvcnQgYSBjb2xsZWN0aW9uIG9mIHJvdXRlcy4gVGhlIENMSSB3aWxsIHB1bGwgdGhlc2Ugcm91dGVzIHdoZW4gY3JlYXRpbmcgdGhlIGNsaWVudC1zaWRlIHJvdXRlcyBmb3IgdGhlIHdpcmluZyBtb2R1bGU8L2xpPlxcbjxsaT5UaGUgPGNvZGU+c2VydmVyX2NvbnRyb2xsZXJzPC9jb2RlPiBkaXJlY3RvcnkgaXMgdGhlIHJvb3QgZGlyZWN0b3J5IHdoZXJlIHlvdXIgc2VydmVyLXNpZGUgY29udHJvbGxlcnMgbGl2ZS4gSXQmIzM5O3MgdXNlZCB3aGVuIHNldHRpbmcgdXAgdGhlIHNlcnZlci1zaWRlIHJvdXRlcjwvbGk+XFxuPGxpPlRoZSA8Y29kZT5jbGllbnRfY29udHJvbGxlcnM8L2NvZGU+IGRpcmVjdG9yeSBpcyB3aGVyZSB5b3VyIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgbW9kdWxlcyBsaXZlLiBUaGUgQ0xJIHdpbGwgPGNvZGU+cmVxdWlyZTwvY29kZT4gdGhlc2UgY29udHJvbGxlcnMgaW4gaXRzIHJlc3VsdGluZyB3aXJpbmcgbW9kdWxlPC9saT5cXG48bGk+VGhlIDxjb2RlPmNsaWVudF93aXJpbmc8L2NvZGU+IGZpbGUgaXMgd2hlcmUgeW91ciB3aXJpbmcgbW9kdWxlIHdpbGwgYmUgcGxhY2VkIGJ5IHRoZSBDTEkuIFlvdSYjMzk7bGwgdGhlbiBoYXZlIHRvIDxjb2RlPnJlcXVpcmU8L2NvZGU+IGl0IGluIHlvdXIgYXBwbGljYXRpb24gd2hlbiBib290aW5nIHVwIFRhdW51czwvbGk+XFxuPC91bD5cXG48cD5IZXJlIGlzIHdoZXJlIHRoaW5ncyBnZXQgPGEgaHJlZj1cXFwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252ZW50aW9uX292ZXJfY29uZmlndXJhdGlvblxcXCI+YSBsaXR0bGUgY29udmVudGlvbmFsPC9hPi4gVmlld3MsIGFuZCBib3RoIHNlcnZlci1zaWRlIGFuZCBjbGllbnQtc2lkZSBjb250cm9sbGVycyBhcmUgZXhwZWN0ZWQgdG8gYmUgb3JnYW5pemVkIGJ5IGZvbGxvd2luZyB0aGUgPGNvZGU+e3Jvb3R9L3tjb250cm9sbGVyfS97YWN0aW9ufTwvY29kZT4gcGF0dGVybiwgYnV0IHlvdSBjb3VsZCBjaGFuZ2UgdGhhdCB1c2luZyA8Y29kZT5yZXNvbHZlcnM8L2NvZGU+IHdoZW4gaW52b2tpbmcgdGhlIENMSSBhbmQgdXNpbmcgdGhlIHNlcnZlci1zaWRlIEFQSS48L3A+XFxuPHA+Vmlld3MgYW5kIGNvbnRyb2xsZXJzIGFyZSBhbHNvIGV4cGVjdGVkIHRvIGJlIENvbW1vbkpTIG1vZHVsZXMgdGhhdCBleHBvcnQgYSBzaW5nbGUgbWV0aG9kLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2VjdGlvbj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7fS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnVuZGVmaW5lZDp0eXBlb2YgdW5kZWZpbmVkIT09XCJ1bmRlZmluZWRcIj91bmRlZmluZWQ6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn0gY2F0Y2ggKGVycikge1xuICBqYWRlLnJldGhyb3coZXJyLCBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lLCBqYWRlX2RlYnVnWzBdLmxpbmVubywgXCJzZWN0aW9uLmx5LXNlY3Rpb24ubWQtbWFya2Rvd25cXG4gIDptYXJrZG93blxcbiAgICAjIEFQSSBEb2N1bWVudGF0aW9uXFxuXFxuICAgIEhlcmUncyB0aGUgQVBJIGRvY3VtZW50YXRpb24gZm9yIFRhdW51cy4gSWYgeW91J3ZlIG5ldmVyIHVzZWQgaXQgYmVmb3JlLCB3ZSByZWNvbW1lbmQgZ29pbmcgb3ZlciB0aGUgW0dldHRpbmcgU3RhcnRlZF1bMV0gZ3VpZGUgYmVmb3JlIGp1bXBpbmcgaW50byB0aGUgQVBJIGRvY3VtZW50YXRpb24uIFRoYXQgd2F5LCB5b3UnbGwgZ2V0IGEgYmV0dGVyIGlkZWEgb2Ygd2hhdCB0byBsb29rIGZvciBhbmQgaG93IHRvIHB1dCB0b2dldGhlciBzaW1wbGUgYXBwbGljYXRpb25zIHVzaW5nIFRhdW51cywgYmVmb3JlIGdvaW5nIHRocm91Z2ggZG9jdW1lbnRhdGlvbiBvbiBldmVyeSBwdWJsaWMgaW50ZXJmYWNlIHRvIFRhdW51cy5cXG5cXG4gICAgVGF1bnVzIGV4cG9zZXMgX3RocmVlIGRpZmZlcmVudCBwdWJsaWMgQVBJc18sIGFuZCB0aGVyZSdzIGFsc28gKipwbHVnaW5zIHRvIGludGVncmF0ZSBUYXVudXMgYW5kIGFuIEhUVFAgc2VydmVyKiouIFRoaXMgZG9jdW1lbnQgY292ZXJzIGFsbCB0aHJlZSBBUElzIGV4dGVuc2l2ZWx5LiBJZiB5b3UncmUgY29uY2VybmVkIGFib3V0IHRoZSBpbm5lciB3b3JraW5ncyBvZiBUYXVudXMsIHBsZWFzZSByZWZlciB0byB0aGUgW0dldHRpbmcgU3RhcnRlZF1bMV0gZ3VpZGUuIFRoaXMgZG9jdW1lbnQgYWltcyB0byBvbmx5IGNvdmVyIGhvdyB0aGUgcHVibGljIGludGVyZmFjZSBhZmZlY3RzIGFwcGxpY2F0aW9uIHN0YXRlLCBidXQgKipkb2Vzbid0IGRlbHZlIGludG8gaW1wbGVtZW50YXRpb24gZGV0YWlscyoqLlxcblxcbiAgICAjIFRhYmxlIG9mIENvbnRlbnRzXFxuXFxuICAgIC0gQSBbc2VydmVyLXNpZGUgQVBJXSgjc2VydmVyLXNpZGUtYXBpKSB0aGF0IGRlYWxzIHdpdGggc2VydmVyLXNpZGUgcmVuZGVyaW5nXFxuICAgICAgLSBUaGUgW2B0YXVudXMubW91bnRgXSgjLXRhdW51cy1tb3VudC1hZGRyb3V0ZS1vcHRpb25zLSkgbWV0aG9kXFxuICAgICAgICAtIEl0cyBbYG9wdGlvbnNgXSgjdGhlLW9wdGlvbnMtb2JqZWN0KSBhcmd1bWVudFxcbiAgICAgICAgICAtIFtgbGF5b3V0YF0oIy1vcHRpb25zLWxheW91dC0pXFxuICAgICAgICAgIC0gW2Byb3V0ZXNgXSgjLW9wdGlvbnMtcm91dGVzLSlcXG4gICAgICAgICAgLSBbYGdldERlZmF1bHRWaWV3TW9kZWxgXSgjLW9wdGlvbnMtZ2V0ZGVmYXVsdHZpZXdtb2RlbC0pXFxuICAgICAgICAgIC0gW2BwbGFpbnRleHRgXSgjLW9wdGlvbnMtcGxhaW50ZXh0LSlcXG4gICAgICAgICAgLSBbYHJlc29sdmVyc2BdKCMtb3B0aW9ucy1yZXNvbHZlcnMtKVxcbiAgICAgICAgICAtIFtgdmVyc2lvbmBdKCMtb3B0aW9ucy12ZXJzaW9uLSlcXG4gICAgICAgICAgLSBbYGRlZmVyTWluaWZpZWRgXSgjLW9wdGlvbnMtZGVmZXJtaW5pZmllZC0pXFxuICAgICAgICAtIEl0cyBbYGFkZFJvdXRlYF0oIy1hZGRyb3V0ZS1kZWZpbml0aW9uLSkgYXJndW1lbnRcXG4gICAgICAtIFRoZSBbYHRhdW51cy5yZW5kZXJgXSgjLXRhdW51cy1yZW5kZXItYWN0aW9uLXZpZXdtb2RlbC1yZXEtcmVzLW5leHQtKSBtZXRob2RcXG4gICAgICAtIFRoZSBbYHRhdW51cy5yZXNvbHZlYF0oIy10YXVudXMtcmVzb2x2ZS1hY3Rpb24tZGF0YS0pIG1ldGhvZFxcbiAgICAgIC0gVGhlIFtgdGF1bnVzLnJlZGlyZWN0YF0oIy10YXVudXMtcmVkaXJlY3QtcmVxLXJlcy11cmwtKSBtZXRob2RcXG4gICAgICAtIFRoZSBbYHRhdW51cy5yZWJ1aWxkRGVmYXVsdFZpZXdNb2RlbGBdKCMtdGF1bnVzLXJlYnVpbGRkZWZhdWx0dmlld21vZGVsLWRvbmUtKSBtZXRob2RcXG4gICAgLSBbU2VydmVyLXNpZGUgY29udHJvbGxlcnNdKCNzZXJ2ZXItc2lkZS1jb250cm9sbGVycylcXG4gICAgLSBBIFtzdWl0ZSBvZiBwbHVnaW5zXSgjaHR0cC1mcmFtZXdvcmstcGx1Z2lucykgY2FuIGludGVncmF0ZSBUYXVudXMgYW5kIGFuIEhUVFAgc2VydmVyXFxuICAgICAgLSBVc2luZyBbYHRhdW51cy1leHByZXNzYF0oI3VzaW5nLXRhdW51cy1leHByZXNzLSkgZm9yIFtFeHByZXNzXVsyXVxcbiAgICAgIC0gVXNpbmcgW2B0YXVudXMtaGFwaWBdKCN1c2luZy10YXVudXMtaGFwaS0pIGZvciBbSGFwaV1bM11cXG4gICAgLSBBIFtDTEkgdGhhdCBwcm9kdWNlcyBhIHdpcmluZyBtb2R1bGVdKCNjb21tYW5kLWxpbmUtaW50ZXJmYWNlKSBmb3IgdGhlIGNsaWVudC1zaWRlXFxuICAgICAgLSBUaGUgW2AtLW91dHB1dGBdKCMtb3V0cHV0LSkgZmxhZ1xcbiAgICAgIC0gVGhlIFtgLS13YXRjaGBdKCMtd2F0Y2gtKSBmbGFnXFxuICAgICAgLSBUaGUgW2AtLXRyYW5zZm9ybSA8bW9kdWxlPmBdKCMtdHJhbnNmb3JtLW1vZHVsZS0pIGZsYWdcXG4gICAgICAtIFRoZSBbYC0tZGVmZXJgXSgjLWRlZmVyLWFjdGlvbnMtKSBmbGFnXFxuICAgICAgLSBUaGUgW2AtLXJlc29sdmVycyA8bW9kdWxlPmBdKCMtcmVzb2x2ZXJzLW1vZHVsZS0pIGZsYWdcXG4gICAgICAtIFRoZSBbYC0tYnVuZGxlYF0oIy1idW5kbGUtKSBmbGFnXFxuICAgIC0gQSBbY2xpZW50LXNpZGUgQVBJXSgjY2xpZW50LXNpZGUtYXBpKSB0aGF0IGRlYWxzIHdpdGggY2xpZW50LXNpZGUgcmVuZGVyaW5nXFxuICAgICAgLSBUaGUgW2B0YXVudXMubW91bnRgXSgjLXRhdW51cy1tb3VudC1jb250YWluZXItd2lyaW5nLW9wdGlvbnMtKSBtZXRob2RcXG4gICAgICAgIC0gVXNpbmcgdGhlIFtgYXV0b2BdKCN1c2luZy10aGUtYXV0by1zdHJhdGVneSkgc3RyYXRlZ3lcXG4gICAgICAgIC0gVXNpbmcgdGhlIFtgaW5saW5lYF0oI3VzaW5nLXRoZS1pbmxpbmUtc3RyYXRlZ3kpIHN0cmF0ZWd5XFxuICAgICAgICAtIFVzaW5nIHRoZSBbYG1hbnVhbGBdKCN1c2luZy10aGUtbWFudWFsLXN0cmF0ZWd5KSBzdHJhdGVneVxcbiAgICAgICAgLSBbQ2FjaGluZ10oI2NhY2hpbmcpXFxuICAgICAgICAtIFtQcmVmZXRjaGluZ10oI3ByZWZldGNoaW5nKVxcbiAgICAgICAgLSBbVmVyc2lvbmluZ10oI3ZlcnNpb25pbmcpXFxuICAgICAgLSBUaGUgW2B0YXVudXMub25gXSgjLXRhdW51cy1vbi10eXBlLWZuLSkgbWV0aG9kXFxuICAgICAgLSBUaGUgW2B0YXVudXMub25jZWBdKCMtdGF1bnVzLW9uY2UtdHlwZS1mbi0pIG1ldGhvZFxcbiAgICAgIC0gVGhlIFtgdGF1bnVzLm9mZmBdKCMtdGF1bnVzLW9mZi10eXBlLWZuLSkgbWV0aG9kXFxuICAgICAgLSBUaGUgW2B0YXVudXMuaW50ZXJjZXB0YF0oIy10YXVudXMtaW50ZXJjZXB0LWFjdGlvbi1mbi0pIG1ldGhvZFxcbiAgICAgIC0gVGhlIFtgdGF1bnVzLnBhcnRpYWxgXSgjLXRhdW51cy1wYXJ0aWFsLWNvbnRhaW5lci1hY3Rpb24tbW9kZWwtKSBtZXRob2RcXG4gICAgICAtIFRoZSBbYHRhdW51cy5uYXZpZ2F0ZWBdKCMtdGF1bnVzLW5hdmlnYXRlLXVybC1vcHRpb25zLSkgbWV0aG9kXFxuICAgICAgLSBUaGUgW2B0YXVudXMucm91dGVgXSgjLXRhdW51cy1yb3V0ZS11cmwtc3RhcnRpbmRleC0pIG1ldGhvZFxcbiAgICAgICAgLSBUaGUgW2B0YXVudXMucm91dGUuZXF1YWxzYF0oIy10YXVudXMtcm91dGUtZXF1YWxzLXJvdXRlLXJvdXRlLSkgbWV0aG9kXFxuICAgICAgLSBUaGUgW2B0YXVudXMucmVzb2x2ZWBdKCMtdGF1bnVzLXJlc29sdmUtb24tdGhlLWNsaWVudCkgbWV0aG9kXFxuICAgICAgLSBUaGUgW2B0YXVudXMuc3RhdGVgXSgjLXRhdW51cy1zdGF0ZS0pIHByb3BlcnR5XFxuICAgICAgLSBUaGUgW2B0YXVudXMueGhyYF0oIy10YXVudXMteGhyLXVybC1vcHRpb25zLWRvbmUtKSBtZXRob2RcXG4gICAgICAtIFRoZSBbYHRhdW51cy5wcmVmZXRjaGBdKCN1c2luZy10YXVudXMtcHJlZmV0Y2gtdXJsLWVsZW1lbnQtKSBtZXRob2RcXG4gICAgICAtIFtEZWJ1Z2dpbmcgVGF1bnVzXSgjZGVidWdnaW5nLXRhdW51cylcXG4gICAgLSBbQ2xpZW50LXNpZGUgY29udHJvbGxlcnNdKCNjbGllbnQtc2lkZS1jb250cm9sbGVycylcXG4gICAgLSBUaGUgW2AudGF1bnVzcmNgXSgjdGhlLXRhdW51c3JjLW1hbmlmZXN0KSBtYW5pZmVzdFxcblxcbiAgICAjIFNlcnZlci1zaWRlIEFQSVxcblxcbiAgICBUaGUgc2VydmVyLXNpZGUgQVBJIGlzIHVzZWQgdG8gc2V0IHVwIHRoZSB2aWV3IHJvdXRlci4gSXQgdGhlbiBnZXRzIG91dCBvZiB0aGUgd2F5LCBhbGxvd2luZyB0aGUgY2xpZW50LXNpZGUgdG8gZXZlbnR1YWxseSB0YWtlIG92ZXIgYW5kIGFkZCBhbnkgZXh0cmEgc3VnYXIgb24gdG9wLCBfaW5jbHVkaW5nIGNsaWVudC1zaWRlIHJlbmRlcmluZ18uXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGB0YXVudXMubW91bnQoYWRkUm91dGUsIG9wdGlvbnM/KWBcXG5cXG4gICAgTW91bnRzIFRhdW51cyBvbiB0b3Agb2YgYSBzZXJ2ZXItc2lkZSByb3V0ZXIsIGJ5IHJlZ2lzdGVyaW5nIGVhY2ggcm91dGUgaW4gYG9wdGlvbnMucm91dGVzYCB3aXRoIHRoZSBgYWRkUm91dGVgIG1ldGhvZC5cXG5cXG4gICAgPiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgdGltZSwgKip0aGlzIG1ldGhvZCBzaG91bGRuJ3QgYmUgaW52b2tlZCBkaXJlY3RseSoqLCBidXQgcmF0aGVyIHRocm91Z2ggb25lIG9mIHRoZSBbSFRUUCBmcmFtZXdvcmsgcGx1Z2luc10oI2h0dHAtZnJhbWV3b3JrLXBsdWdpbnMpIHByZXNlbnRlZCBiZWxvdy5cXG5cXG4gICAgSGVyZSdzIGFuIGluY29tcGxldGUgZXhhbXBsZSBvZiBob3cgdGhpcyBtZXRob2QgbWF5IGJlIHVzZWQuIEl0IGlzIGluY29tcGxldGUgYmVjYXVzZSByb3V0ZSBkZWZpbml0aW9ucyBoYXZlIG1vcmUgb3B0aW9ucyBiZXlvbmQgdGhlIGByb3V0ZWAgYW5kIGBhY3Rpb25gIHByb3BlcnRpZXMuXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgdGF1bnVzLm1vdW50KGFkZFJvdXRlLCB7XFxuICAgICAgcm91dGVzOiBbeyByb3V0ZTogJy8nLCBhY3Rpb246ICdob21lL2luZGV4JyB9XVxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gYWRkUm91dGUgKGRlZmluaXRpb24pIHtcXG4gICAgICBhcHAuZ2V0KGRlZmluaXRpb24ucm91dGUsIGRlZmluaXRpb24uYWN0aW9uKTtcXG4gICAgfVxcbiAgICBgYGBcXG5cXG4gICAgTGV0J3MgZ28gb3ZlciB0aGUgb3B0aW9ucyB5b3UgY2FuIHBhc3MgdG8gYHRhdW51cy5tb3VudGAgZmlyc3QuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVGhlIGBvcHRpb25zP2Agb2JqZWN0XFxuXFxuICAgIFRoZXJlJ3MgYSBmZXcgb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIHNlcnZlci1zaWRlIG1vdW50cG9pbnQuIFlvdSdyZSBwcm9iYWJseSBnb2luZyB0byBiZSBwYXNzaW5nIHRoZXNlIHRvIHlvdXIgW0hUVFAgZnJhbWV3b3JrIHBsdWdpbl0oI2h0dHAtZnJhbWV3b3JrLXBsdWdpbnMpLCByYXRoZXIgdGhhbiB1c2luZyBgdGF1bnVzLm1vdW50YCBkaXJlY3RseS5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyMjIGBvcHRpb25zLmxheW91dD9gXFxuXFxuICAgIFRoZSBgbGF5b3V0YCBwcm9wZXJ0eSBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgZnVuY3Rpb24oZGF0YSlgIHNpZ25hdHVyZS4gSXQnbGwgYmUgaW52b2tlZCB3aGVuZXZlciBhIGZ1bGwgSFRNTCBkb2N1bWVudCBuZWVkcyB0byBiZSByZW5kZXJlZCwgYW5kIGEgYGRhdGFgIG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0byBpdC4gVGhhdCBvYmplY3Qgd2lsbCBjb250YWluIGV2ZXJ5dGhpbmcgeW91J3ZlIHNldCBhcyB0aGUgdmlldyBtb2RlbCwgcGx1cyBhIGBwYXJ0aWFsYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSByYXcgSFRNTCBvZiB0aGUgcmVuZGVyZWQgcGFydGlhbCB2aWV3LiBZb3VyIGBsYXlvdXRgIG1ldGhvZCB3aWxsIHR5cGljYWxseSB3cmFwIHRoZSByYXcgSFRNTCBmb3IgdGhlIHBhcnRpYWwgd2l0aCB0aGUgYmFyZSBib25lcyBvZiBhbiBIVE1MIGRvY3VtZW50LiBDaGVjayBvdXQgW3RoZSBgbGF5b3V0LmphZGVgIHVzZWQgaW4gUG9ueSBGb29dWzRdIGFzIGFuIGV4YW1wbGUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMjIyBgb3B0aW9ucy5yb3V0ZXNgXFxuXFxuICAgIFRoZSBvdGhlciBiaWcgb3B0aW9uIGlzIGByb3V0ZXNgLCB3aGljaCBleHBlY3RzIGEgY29sbGVjdGlvbiBvZiByb3V0ZSBkZWZpbml0aW9ucy4gUm91dGUgZGVmaW5pdGlvbnMgdXNlIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgdG8gZGV0ZXJtaW5lIGhvdyB0aGUgcm91dGUgaXMgZ29pbmcgdG8gYmVoYXZlLlxcblxcbiAgICBIZXJlJ3MgYW4gZXhhbXBsZSByb3V0ZSB0aGF0IHVzZXMgdGhlIFtFeHByZXNzXVsyXSByb3V0aW5nIHNjaGVtZS5cXG5cXG4gICAgYGBganNcXG4gICAge1xcbiAgICAgIHJvdXRlOiAnL2FydGljbGVzLzpzbHVnJyxcXG4gICAgICBhY3Rpb246ICdhcnRpY2xlcy9hcnRpY2xlJyxcXG4gICAgICBpZ25vcmU6IGZhbHNlLFxcbiAgICAgIGNhY2hlOiA8aW5oZXJpdD5cXG4gICAgfVxcbiAgICBgYGBcXG5cXG4gICAgLSBgcm91dGVgIGlzIGEgcm91dGUgaW4gdGhlIGZvcm1hdCB5b3VyIEhUVFAgZnJhbWV3b3JrIG9mIGNob2ljZSB1bmRlcnN0YW5kc1xcbiAgICAtIGBhY3Rpb25gIGlzIHRoZSBuYW1lIG9mIHlvdXIgY29udHJvbGxlciBhY3Rpb24uIEl0J2xsIGJlIHVzZWQgdG8gZmluZCB0aGUgc2VydmVyLXNpZGUgY29udHJvbGxlciwgdGhlIGRlZmF1bHQgdmlldyB0aGF0IHNob3VsZCBiZSB1c2VkIHdpdGggdGhpcyByb3V0ZSwgYW5kIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyXFxuICAgIC0gYGNhY2hlYCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNsaWVudC1zaWRlIGNhY2hpbmcgYmVoYXZpb3IgaW4gdGhpcyBhcHBsaWNhdGlvbiBwYXRoLCBhbmQgaXQnbGwgZGVmYXVsdCB0byBpbmhlcml0aW5nIGZyb20gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGB0YXVudXMubW91bnRgIF9vbiB0aGUgY2xpZW50LXNpZGVfXFxuICAgIC0gYGlnbm9yZWAgaXMgdXNlZCBpbiB0aG9zZSBjYXNlcyB3aGVyZSB5b3Ugd2FudCBhIFVSTCB0byBiZSBpZ25vcmVkIGJ5IHRoZSBjbGllbnQtc2lkZSByb3V0ZXIgZXZlbiBpZiB0aGVyZSdzIGEgY2F0Y2gtYWxsIHJvdXRlIHRoYXQgd291bGQgbWF0Y2ggdGhhdCBVUkxcXG5cXG4gICAgQXMgYW4gZXhhbXBsZSBvZiB0aGUgYGlnbm9yZWAgdXNlIGNhc2UsIGNvbnNpZGVyIHRoZSByb3V0aW5nIHRhYmxlIHNob3duIGJlbG93LiBUaGUgY2xpZW50LXNpZGUgcm91dGVyIGRvZXNuJ3Qga25vdyBfKGFuZCBjYW4ndCBrbm93IHVubGVzcyB5b3UgcG9pbnQgaXQgb3V0KV8gd2hhdCByb3V0ZXMgYXJlIHNlcnZlci1zaWRlIG9ubHksIGFuZCBpdCdzIHVwIHRvIHlvdSB0byBwb2ludCB0aG9zZSBvdXQuXFxuXFxuICAgIGBgYGpzXFxuICAgIFtcXG4gICAgICB7IHJvdXRlOiAnLycsIGFjdGlvbjogJy9ob21lL2luZGV4JyB9LFxcbiAgICAgIHsgcm91dGU6ICcvZmVlZCcsIGlnbm9yZTogdHJ1ZSB9LFxcbiAgICAgIHsgcm91dGU6ICcvKicsIGFjdGlvbjogJ2Vycm9yL25vdC1mb3VuZCcgfVxcbiAgICBdXFxuICAgIGBgYFxcblxcbiAgICBUaGlzIHN0ZXAgaXMgbmVjZXNzYXJ5IHdoZW5ldmVyIHlvdSBoYXZlIGFuIGFuY2hvciBsaW5rIHBvaW50ZWQgYXQgc29tZXRoaW5nIGxpa2UgYW4gUlNTIGZlZWQuIFRoZSBgaWdub3JlYCBwcm9wZXJ0eSBpcyBlZmZlY3RpdmVseSB0ZWxsaW5nIHRoZSBjbGllbnQtc2lkZSBfXFxcImRvbid0IGhpamFjayBsaW5rcyBjb250YWluaW5nIHRoaXMgVVJMXFxcIl8uXFxuXFxuICAgIFBsZWFzZSBub3RlIHRoYXQgZXh0ZXJuYWwgbGlua3MgYXJlIG5ldmVyIGhpamFja2VkLiBPbmx5IHNhbWUtb3JpZ2luIGxpbmtzIGNvbnRhaW5pbmcgYSBVUkwgdGhhdCBtYXRjaGVzIG9uZSBvZiB0aGUgcm91dGVzIHdpbGwgYmUgaGlqYWNrZWQgYnkgVGF1bnVzLiBFeHRlcm5hbCBsaW5rcyBkb24ndCBuZWVkIHRvIGJlIGBpZ25vcmVgZC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyMjIGBvcHRpb25zLmdldERlZmF1bHRWaWV3TW9kZWw/YFxcblxcbiAgICBUaGUgYGdldERlZmF1bHRWaWV3TW9kZWwoZG9uZSlgIHByb3BlcnR5IGNhbiBiZSBhIG1ldGhvZCB0aGF0IHB1dHMgdG9nZXRoZXIgdGhlIGJhc2UgdmlldyBtb2RlbCwgd2hpY2ggd2lsbCB0aGVuIGJlIGV4dGVuZGVkIG9uIGFuIGFjdGlvbi1ieS1hY3Rpb24gYmFzaXMuIFdoZW4geW91J3JlIGRvbmUgY3JlYXRpbmcgYSB2aWV3IG1vZGVsLCB5b3UgY2FuIGludm9rZSBgZG9uZShudWxsLCBtb2RlbClgLiBJZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgYnVpbGRpbmcgdGhlIHZpZXcgbW9kZWwsIHlvdSBzaG91bGQgY2FsbCBgZG9uZShlcnIpYCBpbnN0ZWFkLlxcblxcbiAgICBUYXVudXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBgZG9uZWAgaXMgaW52b2tlZCB3aXRoIGFuIGVycm9yLCBzbyB5b3UgbWlnaHQgd2FudCB0byBwdXQgc2FmZWd1YXJkcyBpbiBwbGFjZSBhcyB0byBhdm9pZCB0aGF0IGZyb20gaGFwcGVubmluZy4gVGhlIHJlYXNvbiB0aGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgaXMgYmVjYXVzZSB5b3UgbWF5IG5lZWQgZGF0YWJhc2UgYWNjZXNzIG9yIHNvbWVzdWNoIHdoZW4gcHV0dGluZyB0b2dldGhlciB0aGUgZGVmYXVsdHMuIFRoZSByZWFzb24gdGhpcyBpcyBhIG1ldGhvZCBhbmQgbm90IGp1c3QgYW4gb2JqZWN0IGlzIHRoYXQgdGhlIGRlZmF1bHRzIG1heSBjaGFuZ2UgZHVlIHRvIGh1bWFuIGludGVyYWN0aW9uIHdpdGggdGhlIGFwcGxpY2F0aW9uLCBhbmQgaW4gdGhvc2UgY2FzZXMgW3RoZSBkZWZhdWx0cyBjYW4gYmUgcmVidWlsdF0oI3RhdW51cy1yZWJ1aWxkZGVmYXVsdHZpZXdtb2RlbCkuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMjIyBgb3B0aW9ucy5wbGFpbnRleHQ/YFxcblxcbiAgICBUaGUgYHBsYWludGV4dGAgb3B0aW9ucyBvYmplY3QgaXMgcGFzc2VkIGRpcmVjdGx5IHRvIFtoZ2V0XVs1XSwgYW5kIGl0J3MgdXNlZCB0byBbdHdlYWsgdGhlIHBsYWludGV4dCB2ZXJzaW9uXVs2XSBvZiB5b3VyIHNpdGUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMjIyBgb3B0aW9ucy5yZXNvbHZlcnM/YFxcblxcbiAgICBSZXNvbHZlcnMgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBsb2NhdGlvbiBvZiBzb21lIG9mIHRoZSBkaWZmZXJlbnQgcGllY2VzIG9mIHlvdXIgYXBwbGljYXRpb24uIFR5cGljYWxseSB5b3Ugd29uJ3QgaGF2ZSB0byB0b3VjaCB0aGVzZSBpbiB0aGUgc2xpZ2h0ZXN0LlxcblxcbiAgICBTaWduYXR1cmUgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgYGdldFNlcnZlckNvbnRyb2xsZXIoYWN0aW9uKWAgfCBSZXR1cm4gcGF0aCB0byBzZXJ2ZXItc2lkZSBjb250cm9sbGVyIGFjdGlvbiBoYW5kbGVyIG1vZHVsZVxcbiAgICBgZ2V0VmlldyhhY3Rpb24pYCAgICAgICAgICAgICB8IFJldHVybiBwYXRoIHRvIHZpZXcgdGVtcGxhdGUgbW9kdWxlXFxuXFxuICAgIFRoZSBgYWRkUm91dGVgIG1ldGhvZCBwYXNzZWQgdG8gYHRhdW51cy5tb3VudGAgb24gdGhlIHNlcnZlci1zaWRlIGlzIG1vc3RseSBnb2luZyB0byBiZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIEhUVFAgZnJhbWV3b3JrIHBsdWdpbnMsIHNvIGZlZWwgZnJlZSB0byBza2lwIG92ZXIgdGhlIGZvbGxvd2luZyBzZWN0aW9uLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIyMgYG9wdGlvbnMudmVyc2lvbj9gXFxuXFxuICAgIFJlZmVyIHRvIHRoZSBbVmVyc2lvbmluZ10oI3ZlcnNpb25pbmcpIHNlY3Rpb24uXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMjIyBgb3B0aW9ucy5nZXRQYXJ0aWFsP2BcXG5cXG4gICAgQnkgZGVmYXVsdCwgVGF1bnVzIHdpbGwgcmVuZGVyIHBhcnRpYWxzIG9uIHRoZSBzZXJ2ZXItc2lkZSBieSBsb29raW5nIHVwIHRoZSBtb2R1bGUgZm9yIGFuIGFjdGlvbiBtZXRob2QsIGFuZCBjYWxsaW5nIHRoYXQgYWN0aW9uIHBhc3NpbmcgaW4gYSBtb2RlbC5cXG5cXG4gICAgWW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBieSBzZXR0aW5nIGBvcHRpb25zLmdldFBhcnRpYWxgIHRvIGEgZnVuY3Rpb24uIFRoaXMgbWV0aG9kIHRha2VzIHRocmVlIHBhcmFtZXRlcnMuXFxuXFxuICAgIC0gYGFjdGlvbmAgaXMgdGhlIGFjdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHJlbmRlcmVkXFxuICAgIC0gYG1vZGVsYCBpcyB0aGUgbW9kZWwgeW91IGNhbiB1c2UgdG8gcmVuZGVyIHRoZSB2aWV3IGZvciB0aGF0IGFjdGlvblxcbiAgICAtIGBkb25lKGVyciwgaHRtbClgIGlzIGNhbGxlZCB3aGVuIHlvdSdyZSBkb25lLCBwYXNzaW5nIGluIHRoZSByZXN1bHRpbmcgYGh0bWxgIGZvciB0aGUgcGFydGlhbFxcblxcbiAgICBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHNldCBgZ2V0UGFydGlhbGAsIFRhdW51cyB3aWxsIGp1c3QgcmVxdWlyZSB5b3VyIGNvbnRyb2xsZXIgYWN0aW9uIG1ldGhvZCBhbmQgaW52b2tlIHRoYXQgaW5zdGVhZC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyMjIGBvcHRpb25zLmRlZmVyTWluaWZpZWQ/YFxcblxcbiAgICBXaGVuIHZpZXdzIGFuZCBjb250cm9sbGVycyBhcmUgbGF6aWx5IGxvYWRlZCwgdGhleSBhcmUgY29tcGlsZWQgYW5kIGJ1bmRsZWQgdXNpbmcgQnJvd3NlcmlmeS4gVGF1bnVzIHdpbGwgZXZlbiBwcm9kdWNlIGEgc291cmNlIG1hcC4gVG8gYXZvaWQgdGhlIHNvdXJjZSBtYXAsIGFuZCBtaW5pZnkgdGhlIGJ1bmRsZSBpbnN0ZWFkLCBzZXQgYGRlZmVyTWluaWZpZWRgIHRvIGB0cnVlYC5cXG5cXG4gICAgWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gc2V0IGBkZWZlck1pbmlmaWVkYCB0byB3aGV0aGVyIHRoZSBhcHBsaWNhdGlvbiBpcyBydW5uaW5nIG9uIHRoZSBwcm9kdWN0aW9uIGVudmlyb25tZW50LlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIGBhZGRSb3V0ZShkZWZpbml0aW9uKWBcXG5cXG4gICAgVGhlIGBhZGRSb3V0ZShkZWZpbml0aW9uKWAgbWV0aG9kIHdpbGwgYmUgcGFzc2VkIGEgcm91dGUgZGVmaW5pdGlvbiwgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMuIFRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvIHJlZ2lzdGVyIGEgcm91dGUgaW4geW91ciBIVFRQIGZyYW1ld29yaydzIHJvdXRlci5cXG5cXG4gICAgLSBgcm91dGVgIGlzIHRoZSByb3V0ZSB0aGF0IHlvdSBzZXQgYXMgYGRlZmluaXRpb24ucm91dGVgXFxuICAgIC0gYGFjdGlvbmAgaXMgdGhlIGFjdGlvbiBhcyBwYXNzZWQgdG8gdGhlIHJvdXRlIGRlZmluaXRpb25cXG4gICAgLSBgYWN0aW9uRm5gIHdpbGwgYmUgdGhlIGNvbnRyb2xsZXIgZm9yIHRoaXMgYWN0aW9uIG1ldGhvZFxcbiAgICAtIGBtaWRkbGV3YXJlYCB3aWxsIGJlIGFuIGFycmF5IG9mIG1ldGhvZHMgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIGBhY3Rpb25GbmBcXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5yZW5kZXIoYWN0aW9uLCB2aWV3TW9kZWwsIHJlcSwgcmVzLCBuZXh0KWBcXG5cXG4gICAgVGhpcyBtZXRob2QgaXMgYWxtb3N0IGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhcyB5b3Ugc2hvdWxkIGJlIHVzaW5nIFRhdW51cyB0aHJvdWdoIG9uZSBvZiB0aGUgcGx1Z2lucyBhbnl3YXlzLCBzbyB3ZSB3b24ndCBnbyB2ZXJ5IGRlZXAgaW50byBpdC5cXG5cXG4gICAgVGhlIHJlbmRlciBtZXRob2QgaXMgd2hhdCBUYXVudXMgdXNlcyB0byByZW5kZXIgdmlld3MgYnkgY29uc3RydWN0aW5nIEhUTUwsIEpTT04sIG9yIHBsYWludGV4dCByZXNwb25zZXMuIFRoZSBgYWN0aW9uYCBwcm9wZXJ0eSBkZXRlcm1pbmVzIHRoZSBkZWZhdWx0IHZpZXcgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLiBUaGUgYHZpZXdNb2RlbGAgd2lsbCBiZSBleHRlbmRlZCBieSBbdGhlIGRlZmF1bHQgdmlldyBtb2RlbF0oIy1vcHRpb25zLWdldGRlZmF1bHR2aWV3bW9kZWwtKSwgYW5kIGl0IG1heSBhbHNvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBhY3Rpb25gIGJ5IHNldHRpbmcgYHZpZXdNb2RlbC5tb2RlbC5hY3Rpb25gLlxcblxcbiAgICBUaGUgYHJlcWAsIGByZXNgLCBhbmQgYG5leHRgIGFyZ3VtZW50cyBhcmUgZXhwZWN0ZWQgdG8gYmUgdGhlIEV4cHJlc3Mgcm91dGluZyBhcmd1bWVudHMsIGJ1dCB0aGV5IGNhbiBhbHNvIGJlIG1vY2tlZCBfKHdoaWNoIGlzIGluIGZhY3Qgd2hhdCB0aGUgSGFwaSBwbHVnaW4gZG9lcylfLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgdGF1bnVzLnJlYnVpbGREZWZhdWx0Vmlld01vZGVsKGRvbmU/KWBcXG5cXG4gICAgT25jZSBUYXVudXMgaGFzIGJlZW4gbW91bnRlZCwgY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIHJlYnVpbGQgdGhlIHZpZXcgbW9kZWwgZGVmYXVsdHMgdXNpbmcgdGhlIGBnZXREZWZhdWx0Vmlld01vZGVsYCB0aGF0IHdhcyBwYXNzZWQgdG8gYHRhdW51cy5tb3VudGAgaW4gdGhlIG9wdGlvbnMuIEFuIG9wdGlvbmFsIGBkb25lYCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgbW9kZWwgaXMgcmVidWlsdC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5yZXNvbHZlKGFjdGlvbiwgZGF0YT8pYFxcblxcbiAgICBSZXR1cm5zIHRoZSBmaXJzdCByb3V0ZSB0aGF0IG1hdGNoZXMgYW4gYGFjdGlvbmAsIHJlcGxhY2luZyBuYW1lZCBwYXJhbWV0ZXJzIHdpdGggZGF0YSBmcm9tIHRoZSBgZGF0YWAgb2JqZWN0LiBJZiBhIG1hdGNoaW5nIHJvdXRlIGlzIG5vdCBmb3VuZCwgYG51bGxgIGlzIHJldHVybmVkLlxcblxcbiAgICA+IElmIGEgcm91dGUgaXMgbWF0Y2hlZCBidXQgYSByZXF1aXJlZCBuYW1lZCBwYXJhbWV0ZXIgaXNuJ3QgaW4gYGRhdGFgLCAqKmFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bioqLlxcblxcbiAgICBUaGlzIG1ldGhvZCBpcyBtb3N0IHVzZWZ1bCB3aGVuIGNvbXBvc2luZyB0aGUgVVJMIGZvciBhIHJlZGlyZWN0IG9yIGFuIGFjdGlvbiBsaW5rIHdpdGhpbiBhIHRlbXBsYXRlLCBhcyBhIG1lYW5zIHRvIGtlZXAgdGhlIHJvdXRlIGRlY2xhcmF0aW9uIGlzb2xhdGVkIGZyb20gdGhlIHJvdXRlIGl0c2VsZi4gSWYgdGhlIHJvdXRlIGNoYW5nZXMsIHRoZSBtZXRob2Qgd2lsbCByZWZsZWN0IHRoZSBuZXdlciByb3V0ZSBhcyBsb25nIGFzIHRoZSBwYXJhbWV0ZXJzIHN0YXkgdGhlIHNhbWUsIHJlc3VsdGluZyBpbiBpbmNyZWFzZWQgbWFpbnRhaW5hYmlsaXR5LiBfVGhlIG1ldGhvZCBpcyBhdmFpbGFibGUgaW4gYm90aCBsYXlvdXQgdGVtcGxhdGVzIGFuZCBwYXJ0aWFsIHZpZXcgdGVtcGxhdGVzLl9cXG5cXG4gICAgIyMjIyMjIEV4YW1wbGVcXG5cXG4gICAgYGBganNcXG4gICAgdGF1bnVzLnJlc29sdmUoJ3Byb2plY3RzL3Byb2plY3QnLCB7XFxuICAgICAgbmFtZTogJ3B1cHBpZXMnLCBvcmdhbml6YXRpb246ICdjYW5pdXNlJ1xcbiAgICB9KTtcXG4gICAgLy8gPC0gL3AvY2FuaXVzZS9wdXBwaWVzXFxuICAgIGBgYFxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgdGF1bnVzLnJlZGlyZWN0KHJlcSwgcmVzLCB1cmwpYFxcblxcbiAgICBSZWRpcmVjdHMgdGhlIHJlc3BvbnNlIHRvIGEgZGlmZmVyZW50IFVSTC4gSWYgdGhlIHBhZ2Ugd2FzIGJlaW5nIGxvYWRlZCBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYHJlcy5yZWRpcmVjdCh1cmwpYC4gSWYgdGhlIHBhZ2Ugd2FzIGJlaW5nIGxvYWRlZCB2aWEgdGhlIGNsaWVudC1zaWRlIEFKQVggcm91dGluZyBlbmdpbmUsIGEgc3BlY2lhbGx5IGNyYWZ0ZWQgSlNPTiByZXNwb25zZSB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVsb2FkIG9uIHRoZSBjbGllbnQtc2lkZS5cXG5cXG4gICAgIyMjIyMjIEV4YW1wbGVcXG5cXG4gICAgYGBganNcXG4gICAgdGF1bnVzLnJlZGlyZWN0KHJlcSwgcmVzLCAnL2xvZ2luJyk7XFxuICAgIGBgYFxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIFNlcnZlci1TaWRlIENvbnRyb2xsZXJzXFxuXFxuICAgIE9uIHRoZSBzZXJ2ZXItc2lkZSwgY29udHJvbGxlcnMgYXJlIG1vZHVsZXMgdGhhdCBleHBvcnQgYSBzaW5nbGUgZnVuY3Rpb24uIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGVzZSBjb250cm9sbGVycyBkZXBlbmQgb24gdGhlIHNlcnZlci1zaWRlIEhUVFAgZnJhbWV3b3JrIHRoYXQncyBiZWluZyB1c2VkLlxcblxcbiAgICBGb3IgZXhhbXBsZSwgRXhwcmVzcyBnaXZlcyB1cyB0aHJlZSBwYXJhbWV0ZXJzOiBgcmVxYCwgYHJlc2AgYW5kIGBuZXh0YC4gSGFwaSBnaXZlcyB1cyB0d28gaW5zdGVhZDogYHJlcXVlc3RgIGFuZCBgcmVwbHlgLlxcblxcbiAgICBIZXJlJ3MgYSBzYW1wbGUgY29udHJvbGxlciB1c2luZyBgdGF1bnVzLWV4cHJlc3NgLCBhcyBbZGV0YWlsZWQgYmVsb3ddKCN1c2luZy10YXVudXMtZXhwcmVzcy0pLiBUaGlzIGlzIGEgdmVyeSBzaW1wbGUgY29udHJvbGxlciB3aGVyZSB3ZSBhcmUgc2V0dGluZyB0aGUgc3BlY2lhbCBgdmlld01vZGVsYCBwcm9wZXJ0eSBvbiB0aGUgcmVzcG9uc2UsIGFuZCBjYWxsaW5nIGBuZXh0YC4gU3VwcG9zZSB0aGlzIGNvbnRyb2xsZXIgaXMgdGhlIGBwcm9kdWN0L2hvbWVgIGFjdGlvbiBoYW5kbGVyLlxcblxcbiAgICBgYGBqc1xcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xcbiAgICAgIHJlcy52aWV3TW9kZWwgPSB7XFxuICAgICAgICBtb2RlbDoge1xcbiAgICAgICAgICB0aXRsZTogJ3ZpZXcgdGl0bGUnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBuZXh0KCk7XFxuICAgIH07XFxuICAgIGBgYFxcblxcbiAgICBBcyB5b3UgY2FuIHNlZSwgVGF1bnVzIHdvbid0IGFsdGVyIHRoZSBBUEkgcHJvdmlkZWQgYnkgRXhwcmVzcy4gSW5zdGVhZCwgaXQgYnVpbGRzIHVwb24gdGhlIG5vdGlvbiBvZiB1c2luZyBtaWRkbGV3YXJlLiBPbmNlIHRoZSBgcHJvZHVjdC9ob21lYCB2aWV3IGlzIHJlbmRlcmVkIGFuZCBKYXZhU2NyaXB0IGxvYWRzLCB0aGUgYHByb2R1Y3QvaG9tZWAgdmlldyBjb250cm9sbGVyIGlzIGV4ZWN1dGVkIG9uIHRoZSBjbGllbnQtc2lkZS5cXG5cXG4gICAgWW91IGNvdWxkIGNoYW5nZSB0aGUgdmlldyB0byBiZSByZW5kZXJlZCBieSBzZXR0aW5nIHRoZSBgYWN0aW9uYCBwcm9wZXJ0eSBvbiB0aGUgYG1vZGVsYC4gSW4gdGhlIGV4YW1wbGUgc2hvd24gYmVsb3cgdGhpcyB3b3VsZCBtZWFuIHRoYXQgdGhlIGBlcnJvci9vZmZsaW5lYCB2aWV3IHdvdWxkIGJlIHJlbmRlcmVkLiBUaGUgY2xpZW50LXNpZGUgY29udHJvbGxlciB3aWxsIGJlIHRoYXQgb2YgYGVycm9yL29mZmxpbmVgLCBhcyB3ZWxsLiBWaWV3IGNvbnRyb2xsZXJzIGFyZSB0aWVkIHRvIHRoZSB2aWV3IHRoYXQgZ2V0cyByZW5kZXJlZC5cXG5cXG4gICAgYGBganNcXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHtcXG4gICAgICByZXMudmlld01vZGVsID0ge1xcbiAgICAgICAgbW9kZWw6IHtcXG4gICAgICAgICAgdGl0bGU6ICd2aWV3IHRpdGxlJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgaWYgKG9mZmxpbmUpIHtcXG4gICAgICAgIHJlcy52aWV3TW9kZWwubW9kZWwuYWN0aW9uID0gJ2Vycm9yL29mZmxpbmUnO1xcbiAgICAgIH1cXG4gICAgICBuZXh0KCk7XFxuICAgIH07XFxuICAgIGBgYFxcblxcbiAgICBIYXZpbmcgYSBkZWZhdWx0IGFjdGlvbiBhbmQgdGhlIGFiaWxpdHkgdG8gcmVkaXJlY3QgdG8gYW5vdGhlciBnaXZlcyB1cyBhIGxvdCBvZiBmbGV4aWJpbGl0eSB3aGVuIGRldGVybWluaW5nIGhvdyB0byByZXNwb25kIHRvIGEgcmVxdWVzdC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyBIVFRQIEZyYW1ld29yayBQbHVnaW5zXFxuXFxuICAgIFRoZXJlJ3MgY3VycmVudGx5IHR3byBkaWZmZXJlbnQgSFRUUCBmcmFtZXdvcmtzIF8oW0V4cHJlc3NdWzJdIGFuZCBbSGFwaV1bM10pXyB0aGF0IHlvdSBjYW4gcmVhZGlseSB1c2Ugd2l0aCBUYXVudXMgd2l0aG91dCBoYXZpbmcgdG8gZGVhbCB3aXRoIGFueSBvZiB0aGUgcm91dGUgcGx1bWJpbmcgeW91cnNlbGYuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIFVzaW5nIGB0YXVudXMtZXhwcmVzc2BcXG5cXG4gICAgVGhlIGB0YXVudXMtZXhwcmVzc2AgcGx1Z2luIGlzIHByb2JhYmx5IHRoZSBlYXNpZXN0IHRvIHVzZSwgYXMgVGF1bnVzIHdhcyBvcmlnaW5hbGx5IGRldmVsb3BlZCB3aXRoIGp1c3QgW0V4cHJlc3NdWzJdIGluIG1pbmQuIEluIGFkZGl0aW9uIHRvIHRoZSBvcHRpb25zIGFscmVhZHkgb3V0bGluZWQgZm9yIFt0YXVudXMubW91bnRdKCMtdGF1bnVzLW1vdW50LWFkZHJvdXRlLW9wdGlvbnMtKSwgeW91IGNhbiBhZGQgbWlkZGxld2FyZSBmb3IgYW55IHJvdXRlIGluZGl2aWR1YWxseS5cXG5cXG4gICAgLSBgbWlkZGxld2FyZWAgYXJlIGFueSBtZXRob2RzIHlvdSB3YW50IFRhdW51cyB0byBleGVjdXRlIGFzIG1pZGRsZXdhcmUgaW4gRXhwcmVzcyBhcHBsaWNhdGlvbnNcXG5cXG4gICAgVG8gZ2V0IGB0YXVudXMtZXhwcmVzc2AgZ29pbmcgeW91IGNhbiB1c2UgdGhlIGZvbGxvd2luZyBwaWVjZSBvZiBjb2RlLCBwcm92aWRlZCB0aGF0IHlvdSBjb21lIHVwIHdpdGggYW4gYG9wdGlvbnNgIG9iamVjdC5cXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgdGF1bnVzID0gcmVxdWlyZSgndGF1bnVzJyk7XFxuICAgIHZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgndGF1bnVzLWV4cHJlc3MnKTtcXG4gICAgdmFyIGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XFxuICAgIHZhciBhcHAgPSBleHByZXNzKCk7XFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIC8vIC4uLlxcbiAgICB9O1xcblxcbiAgICB0YXVudXNFeHByZXNzKHRhdW51cywgYXBwLCBvcHRpb25zKTtcXG4gICAgYGBgXFxuXFxuICAgIFRoZSBgdGF1bnVzRXhwcmVzc2AgbWV0aG9kIHdpbGwgbWVyZWx5IHNldCB1cCBUYXVudXMgYW5kIGFkZCB0aGUgcmVsZXZhbnQgcm91dGVzIHRvIHlvdXIgRXhwcmVzcyBhcHBsaWNhdGlvbiBieSBjYWxsaW5nIGBhcHAuZ2V0YCBhIGJ1bmNoIG9mIHRpbWVzLiBZb3UgY2FuIFtmaW5kIHRhdW51cy1leHByZXNzIG9uIEdpdEh1Yl1bN10uXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIFVzaW5nIGB0YXVudXMtaGFwaWBcXG5cXG4gICAgVGhlIGB0YXVudXMtaGFwaWAgcGx1Z2luIGlzIGEgYml0IG1vcmUgaW52b2x2ZWQsIGFuZCB5b3UnbGwgaGF2ZSB0byBjcmVhdGUgYSBQYWNrIGluIG9yZGVyIHRvIHVzZSBpdC4gSW4gYWRkaXRpb24gdG8gW3RoZSBvcHRpb25zIHdlJ3ZlIGFscmVhZHkgY292ZXJlZF0oIy10YXVudXMtbW91bnQtYWRkcm91dGUtb3B0aW9ucy0pLCB5b3UgY2FuIGFkZCBgY29uZmlnYCBvbiBhbnkgcm91dGUuXFxuXFxuICAgIC0gYGNvbmZpZ2AgaXMgcGFzc2VkIGRpcmVjdGx5IGludG8gdGhlIHJvdXRlIHJlZ2lzdGVyZWQgd2l0aCBIYXBpLCBnaXZpbmcgeW91IHRoZSBtb3N0IGZsZXhpYmlsaXR5XFxuXFxuICAgIFRvIGdldCBgdGF1bnVzLWhhcGlgIGdvaW5nIHlvdSBjYW4gdXNlIHRoZSBmb2xsb3dpbmcgcGllY2Ugb2YgY29kZSwgYW5kIHlvdSBjYW4gYnJpbmcgeW91ciBvd24gYG9wdGlvbnNgIG9iamVjdC5cXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgSGFwaSA9IHJlcXVpcmUoJ2hhcGknKTtcXG4gICAgdmFyIHRhdW51cyA9IHJlcXVpcmUoJ3RhdW51cycpO1xcbiAgICB2YXIgdGF1bnVzSGFwaSA9IHJlcXVpcmUoJ3RhdW51cy1oYXBpJykodGF1bnVzKTtcXG4gICAgdmFyIHBhY2sgPSBuZXcgSGFwaS5QYWNrKCk7XFxuXFxuICAgIHBhY2sucmVnaXN0ZXIoe1xcbiAgICAgIHBsdWdpbjogdGF1bnVzSGFwaSxcXG4gICAgICBvcHRpb25zOiB7XFxuICAgICAgICAvLyAuLi5cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBgYGBcXG5cXG4gICAgVGhlIGB0YXVudXNIYXBpYCBwbHVnaW4gd2lsbCBtb3VudCBUYXVudXMgYW5kIHJlZ2lzdGVyIGFsbCBvZiB0aGUgbmVjZXNzYXJ5IHJvdXRlcy4gWW91IGNhbiBbZmluZCB0YXVudXMtaGFwaSBvbiBHaXRIdWJdWzhdLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIENvbW1hbmQtTGluZSBJbnRlcmZhY2VcXG5cXG4gICAgT25jZSB5b3UndmUgc2V0IHVwIHRoZSBzZXJ2ZXItc2lkZSB0byByZW5kZXIgeW91ciB2aWV3cyB1c2luZyBUYXVudXMsIGl0J3Mgb25seSBsb2dpY2FsIHRoYXQgeW91J2xsIHdhbnQgdG8gcmVuZGVyIHRoZSB2aWV3cyBpbiB0aGUgY2xpZW50LXNpZGUgYXMgd2VsbCwgZWZmZWN0aXZlbHkgY29udmVydGluZyB5b3VyIGFwcGxpY2F0aW9uIGludG8gYSBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbiBhZnRlciB0aGUgZmlyc3QgdmlldyBoYXMgYmVlbiByZW5kZXJlZCBvbiB0aGUgc2VydmVyLXNpZGUuXFxuXFxuICAgIFRoZSBUYXVudXMgQ0xJIGlzIGFuIHVzZWZ1bCBpbnRlcm1lZGlhcnkgaW4gdGhlIHByb2Nlc3Mgb2YgZ2V0dGluZyB0aGUgY29uZmlndXJhdGlvbiB5b3Ugd3JvdGUgc28gZmFyIGZvciB0aGUgc2VydmVyLXNpZGUgdG8gYWxzbyB3b3JrIHdlbGwgaW4gdGhlIGNsaWVudC1zaWRlLlxcblxcbiAgICBJbnN0YWxsIGl0IGdsb2JhbGx5IGZvciBkZXZlbG9wbWVudCwgYnV0IHJlbWVtYmVyIHRvIHVzZSBsb2NhbCBjb3BpZXMgZm9yIHByb2R1Y3Rpb24tZ3JhZGUgdXNlcy5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbnBtIGluc3RhbGwgLWcgdGF1bnVzXFxuICAgIGBgYFxcblxcbiAgICBXaGVuIGludm9rZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzLCB0aGUgQ0xJIHdpbGwgc2ltcGx5IGZvbGxvdyB0aGUgZGVmYXVsdCBjb252ZW50aW9ucyB0byBmaW5kIHlvdXIgcm91dGUgZGVmaW5pdGlvbnMsIHZpZXdzLCBhbmQgY2xpZW50LXNpZGUgY29udHJvbGxlcnMuXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIHRhdW51c1xcbiAgICBgYGBcXG5cXG4gICAgQnkgZGVmYXVsdCwgdGhlIG91dHB1dCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIHN0YW5kYXJkIG91dHB1dCwgbWFraW5nIGZvciBhIGZhc3QgZGVidWdnaW5nIGV4cGVyaWVuY2UuIEhlcmUncyB0aGUgb3V0cHV0IGlmIHlvdSBqdXN0IGhhZCBhIHNpbmdsZSBgaG9tZS9pbmRleGAgcm91dGUsIGFuZCB0aGUgbWF0Y2hpbmcgdmlldyBhbmQgY2xpZW50LXNpZGUgY29udHJvbGxlciBleGlzdGVkLlxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHZhciB0ZW1wbGF0ZXMgPSB7XFxuICAgICAgJ2hvbWUvaW5kZXgnOiByZXF1aXJlKCcuL3ZpZXdzL2hvbWUvaW5kZXguanMnKVxcbiAgICB9O1xcblxcbiAgICB2YXIgY29udHJvbGxlcnMgPSB7XFxuICAgICAgJ2hvbWUvaW5kZXgnOiByZXF1aXJlKCcuLi9jbGllbnQvanMvY29udHJvbGxlcnMvaG9tZS9pbmRleC5qcycpXFxuICAgIH07XFxuXFxuICAgIHZhciByb3V0ZXMgPSBbXFxuICAgICAge1xcbiAgICAgICAgcm91dGU6ICcvJyxcXG4gICAgICAgIGFjdGlvbjogJ2hvbWUvaW5kZXgnXFxuICAgICAgfVxcbiAgICBdO1xcblxcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcXG4gICAgICBjb250cm9sbGVyczogY29udHJvbGxlcnMsXFxuICAgICAgcm91dGVzOiByb3V0ZXNcXG4gICAgfTtcXG4gICAgYGBgXFxuXFxuICAgIFlvdSBjYW4gdXNlIGEgZmV3IG9wdGlvbnMgdG8gYWx0ZXIgdGhlIG91dGNvbWUgb2YgaW52b2tpbmcgYHRhdW51c2AuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGAtLW91dHB1dGBcXG5cXG4gICAgPHN1Yj50aGUgYC1vYCBhbGlhcyBpcyBhdmFpbGFibGU8L3N1Yj5cXG5cXG4gICAgT3V0cHV0IGlzIHdyaXR0ZW4gdG8gYSBmaWxlIGluc3RlYWQgb2YgdG8gc3RhbmRhcmQgb3V0cHV0LiBUaGUgZmlsZSBwYXRoIHVzZWQgd2lsbCBiZSB0aGUgYGNsaWVudF93aXJpbmdgIG9wdGlvbiBpbiBbYC50YXVudXNyY2BdKCN0aGUtdGF1bnVzcmMtbWFuaWZlc3QpLCB3aGljaCBkZWZhdWx0cyB0byBgJy5iaW4vd2lyaW5nLmpzJ2AuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGAtLXdhdGNoYFxcblxcbiAgICA8c3ViPnRoZSBgLXdgIGFsaWFzIGlzIGF2YWlsYWJsZTwvc3ViPlxcblxcbiAgICBXaGVuZXZlciBhIHNlcnZlci1zaWRlIHJvdXRlIGRlZmluaXRpb24gY2hhbmdlcywgdGhlIG91dHB1dCBpcyBwcmludGVkIGFnYWluIHRvIGVpdGhlciBzdGFuZGFyZCBvdXRwdXQgb3IgYSBmaWxlLCBkZXBlbmRpbmcgb24gd2hldGhlciBgLS1vdXRwdXRgIHdhcyB1c2VkLlxcblxcbiAgICBUaGUgcHJvZ3JhbSB3b24ndCBleGl0LlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgLS10cmFuc2Zvcm0gPG1vZHVsZT5gXFxuXFxuICAgIDxzdWI+dGhlIGAtdGAgYWxpYXMgaXMgYXZhaWxhYmxlPC9zdWI+XFxuXFxuICAgIFRoaXMgZmxhZyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBzZXJ2ZXItc2lkZSByb3V0ZXMgaW50byBzb21ldGhpbmcgdGhlIGNsaWVudC1zaWRlIHVuZGVyc3RhbmRzLiBFeHByZXNzIHJvdXRlcyBhcmUgY29tcGxldGVseSBjb21wYXRpYmxlIHdpdGggdGhlIGNsaWVudC1zaWRlIHJvdXRlciwgYnV0IEhhcGkgcm91dGVzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIFtgaGFwaWlmeWBdWzldIG1vZHVsZS5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbnBtIGluc3RhbGwgaGFwaWlmeVxcbiAgICB0YXVudXMgLXQgaGFwaWlmeVxcbiAgICBgYGBcXG5cXG4gICAgVXNpbmcgdGhpcyB0cmFuc2Zvcm0gcmVsaWV2ZXMgeW91IGZyb20gaGF2aW5nIHRvIGRlZmluZSB0aGUgc2FtZSByb3V0ZXMgdHdpY2UgdXNpbmcgc2xpZ2h0bHkgZGlmZmVyZW50IGZvcm1hdHMgdGhhdCBjb252ZXkgdGhlIHNhbWUgbWVhbmluZy5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYC0tZGVmZXIgW2FjdGlvbnNdYFxcblxcbiAgICA8c3ViPnRoZSBgLWRgIGFsaWFzIGlzIGF2YWlsYWJsZTwvc3ViPlxcblxcbiAgICBIZXJlIGlzIHdoZXJlIHRoaW5ncyBnZXQgaW50ZXJlc3RpbmcuIFRoZSBgLS1kZWZlcmAgZmxhZyBhbGxvd3MgeW91IHRvIGRlZmVyIGxvYWRpbmcgZm9yIHplcm8gb3IgbW9yZSBhY3Rpb25zLiBFeGNsdWRpbmcgdGhlIGNvbnRyb2xsZXIgYW5kIHZpZXcgdGVtcGxhdGVzIGZvciBhbnkgZGVmZXJyZWQgYWN0aW9uIGNhbiBzaWduaWZpY2FudGx5IHJlZHVjZSB0aGUgZmluZ2VycHJpbnQgb2YgeW91ciBhcHBsaWNhdGlvbi5cXG5cXG4gICAgVGhlIGBbYWN0aW9uc11gIGFyZ3VtZW50IGRldGVybWluZXMgd2hhdCBhY3Rpb25zIGdldCBkZWZlcnJlZCwgYW5kIHdoaWNoIGRvbid0LiBJdCBleHBlY3RzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYWN0aW9ucywgd2hlcmUgeW91IGNhbiBwYXNzIGluIGVpdGhlciB0aGUgY29udHJvbGxlciBuYW1lLCBvciBib3RoIHRoZSBjb250cm9sbGVyIG5hbWUgYW5kIHRoZSBhY3Rpb24gbmFtZS4gVXNpbmcgYD9gIGFjdHMgYXMgYSB3aWxkY2FyZC5cXG5cXG4gICAgRm9yIGV4YW1wbGUsIHVzaW5nIGBhZG1pbmAgXyhlcXVpdmFsZW50IHRvIHVzaW5nIGBhZG1pbi8/YClfIHdpbGwgZGVmZXIgZXZlcnkgYWN0aW9uIHVuZGVyIHRoZSBgYWRtaW5gIGNvbnRyb2xsZXIuIFVzaW5nIGBhZG1pbi9udWtlYCB3aWxsIG9ubHkgZGVmZXIgdGhlIGBhZG1pbi9udWtlYCBhY3Rpb24uIElmIHlvdSBvbWl0IHRoZSBgW2FjdGlvbnNdYCBwYXJhbWV0ZXIgZW50aXJlbHksIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGAnPydgIHdpbGwgYmUgdXNlZCBhbmQgZXZlcnl0aGluZyB3aWxsIGJlIGRlZmVycmVkLlxcblxcbiAgICBXaGVuIGNvbXBvbmVudHMgZ2V0IGRlZmVycmVkLCB0aGV5J2xsIGJlIGxvYWRlZCBhcyBzb29uIGFzIFRhdW51cyBkZXRlY3RzIHRoYXQgdGhleSdyZSBuZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIGZldyBwbGFjZXMuXFxuXFxuICAgIC0gVGhlIHVzZXIgbmF2aWdhdGVzIHRvIChvciBbX3ByZWZldGNoZXNfXSgjcHJlZmV0Y2hpbmcpKSB0aGUgYC9hZG1pbmAgcm91dGUsIGFuZCBgYWRtaW4vaW5kZXhgIHdhcyBkZWZlcnJlZCwgYW5kIGl0cyBjb21wb25lbnRzIGFyZW4ndCBjYWNoZWQgb24gdGhlIGNsaWVudC1zaWRlIHlldFxcbiAgICAtIEEgY29udHJvbGxlciB1c2VzIGB0YXVudXMucGFydGlhbGAgdG8gcmVuZGVyIGFuIGFjdGlvbiB0aGF0IHdhcyBkZWZlcnJlZCwgYW5kIGl0cyBjb21wb25lbnRzIGFyZW4ndCBjYWNoZWQgb24gdGhlIGNsaWVudC1zaWRlIHlldFxcbiAgICAtIFRoZSB1c2VyIG5hdmlnYXRlcyB0byB0aGUgYC9hZG1pbmAgcm91dGUsIGFuZCBpdHMgbWF0Y2hpbmcgYGFkbWluL2luZGV4YCByb3V0ZSB3YXNuJ3QgZGVmZXJyZWQsIGJ1dCB0aGUgc2VydmVyLXNpZGUgY29udHJvbGxlciBkZWNpZGVzIHRvIGNoYW5nZSB0aGUgYWN0aW9uIHRvIGBhZG1pbi9zdXBlcmFkbWluYC4gV2hlbiB0aGUgcmVzcG9uc2UgZ2V0cyB0byB0aGUgY2xpZW50LCBpdCdsbCBuZWVkIHRvIGFzayB0aGUgc2VydmVyIGZvciB0aGUgYGFkbWluL3N1cGVyYWRtaW5gIHRlbXBsYXRlIGlmIHRoZSBjbGllbnQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXRcXG5cXG4gICAgWW91IGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhvc2UgZGlmZmVyZW50IHNjZW5hcmlvcywgdGhvdWdoLCBhcyBUYXVudXMgaGFuZGxlcyB0aGVtIGFsbCBmb3IgeW91IHRyYW5zcGFyZW50bHkuIFlvdSBzaG91bGQgW2xlYXJuIG1vcmUgYWJvdXQgZGVmZXJyZWQgbG9hZGluZyBvbiB0aGUgUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uIGd1aWRlXVsyMF0uXFxuXFxuICAgID4gQSBwb3NzaWJsZSBjb25jZXJuIHdpdGggZGVmZXJyZWQgZXhlY3V0aW9uIGlzIHRoYXQgcGFydGlhbCB2aWV3cyBtYXkgbm90IGJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5LCBhcyBhIHJlcXVlc3QgbWF5IGJlIG5lY2Vzc2FyeSB0byBmZXRjaCB0aGUgY29udHJvbGxlciBvciB0ZW1wbGF0ZSBmb3IgdGhlIHBhcnRpYWwuXFxuXFxuICAgIFNvbWUgb3RoZXIgY29uc2lkZXJhdGlvbnMsIHJlZ2FyZGluZyBob3cgZGVmZXJyZWQgY29tcG9uZW50cyBnZXQgYnVuZGxlZCwgYXJlIGxpc3RlZCBpbiB0aGUgW1BlcmZvcm1hbmNlIE9wdGltaXphdGlvbl1bMjBdIGd1aWRlLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgLS1yZXNvbHZlcnMgPG1vZHVsZT5gXFxuXFxuICAgIDxzdWI+dGhlIGAtcmAgYWxpYXMgaXMgYXZhaWxhYmxlPC9zdWI+XFxuXFxuICAgIFNpbWlsYXJseSB0byB0aGUgW2ByZXNvbHZlcnNgXSgjLW9wdGlvbnMtcmVzb2x2ZXJzLSkgb3B0aW9uIHRoYXQgeW91IGNhbiBwYXNzIHRvIFtgdGF1bnVzLm1vdW50YF0oIy10YXVudXMtbW91bnQtYWRkcm91dGUtb3B0aW9ucy0pLCB0aGVzZSByZXNvbHZlcnMgY2FuIGNoYW5nZSB0aGUgd2F5IGluIHdoaWNoIGZpbGUgcGF0aHMgYXJlIHJlc29sdmVkLlxcblxcbiAgICBTaWduYXR1cmUgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgYGdldENsaWVudENvbnRyb2xsZXIoYWN0aW9uKWAgfCBSZXR1cm4gcGF0aCB0byBjbGllbnQtc2lkZSBjb250cm9sbGVyIGFjdGlvbiBoYW5kbGVyIG1vZHVsZVxcbiAgICBgZ2V0VmlldyhhY3Rpb24pYCAgICAgICAgICAgICB8IFJldHVybiBwYXRoIHRvIHZpZXcgdGVtcGxhdGUgbW9kdWxlXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGAtLWJ1bmRsZWBcXG5cXG4gICAgPHN1Yj50aGUgYC1iYCBhbGlhcyBpcyBhdmFpbGFibGU8L3N1Yj5cXG5cXG4gICAgVW5kZXIgdGhpcyBleHBlcmltZW50YWwgZmxhZywgdGhlIENMSSB3aWxsIHVzZSBCcm93c2VyaWZ5IHRvIGNvbXBpbGUgYSBzdGFuZGFsb25lIG1vZHVsZSB0aGF0IGluY2x1ZGVzIHRoZSB3aXJpbmcgbm9ybWFsbHkgZXhwb3J0ZWQgYnkgdGhlIENMSSBwbHVzIGFsbCBvZiBUYXVudXMgW2FzIGEgVU1EIG1vZHVsZV1bMTBdLlxcblxcbiAgICBUaGlzIGFsbG93cyB5b3UgdG8gdXNlIFRhdW51cyBvbiB0aGUgY2xpZW50LXNpZGUgZXZlbiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgW0Jyb3dzZXJpZnldWzExXSBkaXJlY3RseS5cXG5cXG4gICAgRmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIGFib3V0IHRoaXMgZmxhZywgX2FuZCBwb3NzaWJsZSBhbHRlcm5hdGl2ZXMgdGhhdCB3b3VsZCBtYWtlIFRhdW51cyBlYXNpZXIgdG8gdXNlXywgYXJlIHdlbGNvbWUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMgQ2xpZW50LXNpZGUgQVBJXFxuXFxuICAgIEp1c3QgbGlrZSB0aGUgc2VydmVyLXNpZGUsIGV2ZXJ5dGhpbmcgaW4gdGhlIGNsaWVudC1zaWRlIGJlZ2lucyBhdCB0aGUgbW91bnRwb2ludC4gT25jZSB0aGUgYXBwbGljYXRpb24gaXMgbW91bnRlZCwgYW5jaG9yIGxpbmtzIHdpbGwgYmUgaGlqYWNrZWQgYW5kIHRoZSBjbGllbnQtc2lkZSByb3V0ZXIgd2lsbCB0YWtlIG92ZXIgdmlldyByZW5kZXJpbmcuIENsaWVudC1zaWRlIGNvbnRyb2xsZXJzIGFyZSBleGVjdXRlZCB3aGVuZXZlciBhIHZpZXcgaXMgcmVuZGVyZWQuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGB0YXVudXMubW91bnQoY29udGFpbmVyLCB3aXJpbmcsIG9wdGlvbnM/KWBcXG5cXG4gICAgVGhlIG1vdW50cG9pbnQgdGFrZXMgYSByb290IGNvbnRhaW5lciwgdGhlIHdpcmluZyBtb2R1bGUsIGFuZCBhbiBvcHRpb25zIHBhcmFtZXRlci4gVGhlIGBjb250YWluZXJgIGlzIHdoZXJlIGNsaWVudC1zaWRlLXJlbmRlcmVkIHZpZXdzIHdpbGwgYmUgcGxhY2VkLCBieSByZXBsYWNpbmcgd2hhdGV2ZXIgSFRNTCBjb250ZW50cyBhbHJlYWR5IGV4aXN0LiBZb3UgY2FuIHBhc3MgaW4gdGhlIGB3aXJpbmdgIG1vZHVsZSBleGFjdGx5IGFzIGJ1aWx0IGJ5IHRoZSBDTEksIGFuZCBubyBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24gaXMgbmVjZXNzYXJ5LlxcblxcbiAgICBXaGVuIHRoZSBtb3VudHBvaW50IGV4ZWN1dGVzLCBUYXVudXMgd2lsbCBjb25maWd1cmUgaXRzIGludGVybmFsIHN0YXRlLCBfc2V0IHVwIHRoZSBjbGllbnQtc2lkZSByb3V0ZXJfLCBydW4gdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgZm9yIHRoZSBzZXJ2ZXItc2lkZSByZW5kZXJlZCB2aWV3LCBhbmQgc3RhcnQgaGlqYWNraW5nIGxpbmtzLlxcblxcbiAgICBBcyBhbiBleGFtcGxlLCBjb25zaWRlciBhIGJyb3dzZXIgbWFrZXMgYSBgR0VUYCByZXF1ZXN0IGZvciBgL2FydGljbGVzL3RoZS1mb3hgIGZvciB0aGUgZmlyc3QgdGltZS4gT25jZSBgdGF1bnVzLm1vdW50KGNvbnRhaW5lciwgd2lyaW5nKWAgaXMgaW52b2tlZCBvbiB0aGUgY2xpZW50LXNpZGUsIHNldmVyYWwgdGhpbmdzIHdvdWxkIGhhcHBlbiBpbiB0aGUgb3JkZXIgbGlzdGVkIGJlbG93LlxcblxcbiAgICAtIFRhdW51cyBzZXRzIHVwIHRoZSBjbGllbnQtc2lkZSB2aWV3IHJvdXRpbmcgZW5naW5lXFxuICAgIC0gSWYgZW5hYmxlZCBfKHZpYSBgb3B0aW9uc2ApXywgdGhlIGNhY2hpbmcgZW5naW5lIGlzIGNvbmZpZ3VyZWRcXG4gICAgLSBUYXVudXMgb2J0YWlucyB0aGUgdmlldyBtb2RlbCBfKG1vcmUgb24gdGhpcyBsYXRlcilfXFxuICAgIC0gV2hlbiBhIHZpZXcgbW9kZWwgaXMgb2J0YWluZWQsIHRoZSBgJ3N0YXJ0J2AgZXZlbnQgaXMgZW1pdHRlZFxcbiAgICAtIEFuY2hvciBsaW5rcyBzdGFydCBiZWluZyBtb25pdG9yZWQgZm9yIGNsaWNrcyBfKGF0IHRoaXMgcG9pbnQgeW91ciBhcHBsaWNhdGlvbiBiZWNvbWVzIGEgW1NQQV1bMTNdKV9cXG4gICAgLSBUaGUgYGFydGljbGVzL2FydGljbGVgIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgaXMgZXhlY3V0ZWRcXG5cXG4gICAgVGhhdCdzIHF1aXRlIGEgYml0IG9mIGZ1bmN0aW9uYWxpdHksIGJ1dCBpZiB5b3UgdGhpbmsgYWJvdXQgaXQsIG1vc3Qgb3RoZXIgZnJhbWV3b3JrcyBhbHNvIHJlbmRlciB0aGUgdmlldyBhdCB0aGlzIHBvaW50LCBfcmF0aGVyIHRoYW4gb24gdGhlIHNlcnZlci1zaWRlIV9cXG5cXG4gICAgSW4gb3JkZXIgdG8gYmV0dGVyIHVuZGVyc3RhbmQgdGhlIHByb2Nlc3MsIEknbGwgd2FsayB5b3UgdGhyb3VnaCB0aGUgYG9wdGlvbnNgIHBhcmFtZXRlci5cXG5cXG4gICAgRmlyc3Qgb2ZmLCB0aGUgYGJvb3RzdHJhcGAgb3B0aW9uIGRldGVybWluZXMgdGhlIHN0cmF0ZWd5IHVzZWQgdG8gcHVsbCB0aGUgdmlldyBtb2RlbCBvZiB0aGUgc2VydmVyLXNpZGUgcmVuZGVyZWQgdmlldyBpbnRvIHRoZSBjbGllbnQtc2lkZS4gVGhlcmUgYXJlIHRocmVlIHBvc3NpYmxlIHN0cmF0ZWdpZXMgYXZhaWxhYmxlOiBgYXV0b2AgXyh0aGUgZGVmYXVsdCBzdHJhdGVneSlfLCBgaW5saW5lYCwgb3IgYG1hbnVhbGAuIFRoZSBgYXV0b2Agc3RyYXRlZ3kgaW52b2x2ZXMgdGhlIGxlYXN0IHdvcmssIHdoaWNoIGlzIHdoeSBpdCdzIHRoZSBkZWZhdWx0LlxcblxcbiAgICAtIGBhdXRvYCB3aWxsIG1ha2UgYW4gQUpBWCByZXF1ZXN0IGZvciB0aGUgdmlldyBtb2RlbFxcbiAgICAtIGBpbmxpbmVgIGV4cGVjdHMgeW91IHRvIHBsYWNlIHRoZSBtb2RlbCBpbnRvIGEgYDxzY3JpcHQgdHlwZT0ndGV4dC90YXVudXMnPmAgdGFnXFxuICAgIC0gYG1hbnVhbGAgZXhwZWN0cyB5b3UgdG8gZ2V0IHRoZSB2aWV3IG1vZGVsIGhvd2V2ZXIgeW91IHdhbnQgdG8sIGFuZCB0aGVuIGxldCBUYXVudXMga25vdyB3aGVuIGl0J3MgcmVhZHlcXG5cXG4gICAgTGV0J3MgZ28gaW50byBkZXRhaWwgYWJvdXQgZWFjaCBvZiB0aGVzZSBzdHJhdGVnaWVzLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIFVzaW5nIHRoZSBgYXV0b2Agc3RyYXRlZ3lcXG5cXG4gICAgVGhlIGBhdXRvYCBzdHJhdGVneSBtZWFucyB0aGF0IFRhdW51cyB3aWxsIG1ha2UgdXNlIG9mIGFuIEFKQVggcmVxdWVzdCB0byBvYnRhaW4gdGhlIHZpZXcgbW9kZWwuIF9Zb3UgZG9uJ3QgaGF2ZSB0byBkbyBhbnl0aGluZyBlbHNlXyBhbmQgdGhpcyBpcyB0aGUgZGVmYXVsdCBzdHJhdGVneS4gVGhpcyBpcyB0aGUgKiptb3N0IGNvbnZlbmllbnQgc3RyYXRlZ3ksIGJ1dCBhbHNvIHRoZSBzbG93ZXN0Kiogb25lLlxcblxcbiAgICBJdCdzIHNsb3cgYmVjYXVzZSB0aGUgdmlldyBtb2RlbCB3b24ndCBiZSByZXF1ZXN0ZWQgdW50aWwgdGhlIGJ1bGsgb2YgeW91ciBKYXZhU2NyaXB0IGNvZGUgaGFzIGJlZW4gZG93bmxvYWRlZCwgcGFyc2VkLCBleGVjdXRlZCwgYW5kIGB0YXVudXMubW91bnRgIGlzIGludm9rZWQuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVXNpbmcgdGhlIGBpbmxpbmVgIHN0cmF0ZWd5XFxuXFxuICAgIFRoZSBgaW5saW5lYCBzdHJhdGVneSBleHBlY3RzIHlvdSB0byBhZGQgYSBgZGF0YS10YXVudXNgIGF0dHJpYnV0ZSBvbiB0aGUgYGNvbnRhaW5lcmAgZWxlbWVudC4gVGhpcyBhdHRyaWJ1dGUgbXVzdCBiZSBlcXVhbCB0byB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgYSBgPHNjcmlwdD5gIHRhZyBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIHZpZXcgbW9kZWwgYWxvbmdzaWRlIHRoZSB2ZXJzaW9uIGluZm9ybWF0aW9uIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgYnkgVGF1bnVzIGludG8gdGhlIGxheW91dCB0ZW1wbGF0ZSBkYXRhLlxcblxcbiAgICBgYGBqYWRlXFxuICAgIGRpdihkYXRhLXRhdW51cz0nbW9kZWwnKSE9cGFydGlhbFxcbiAgICBzY3JpcHQodHlwZT0ndGV4dC90YXVudXMnLCBkYXRhLXRhdW51cz0nbW9kZWwnKT1KU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IHZlcnNpb24sIG1vZGVsOiBtb2RlbCB9KVxcbiAgICBgYGBcXG5cXG4gICAgUGF5IHNwZWNpYWwgYXR0ZW50aW9uIHRvIHRoZSBmYWN0IHRoYXQgdGhlIG1vZGVsIGlzIG5vdCBvbmx5IG1hZGUgaW50byBhIEpTT04gc3RyaW5nLCBfYnV0IGFsc28gSFRNTCBlbmNvZGVkIGJ5IEphZGVfLiBXaGVuIFRhdW51cyBleHRyYWN0cyB0aGUgbW9kZWwgZnJvbSB0aGUgYDxzY3JpcHQ+YCB0YWcgaXQnbGwgdW5lc2NhcGUgaXQsIGFuZCB0aGVuIHBhcnNlIGl0IGFzIEpTT04uXFxuXFxuICAgIFRoaXMgc3RyYXRlZ3kgaXMgYWxzbyBmYWlybHkgY29udmVuaWVudCB0byBzZXQgdXAsIGJ1dCBpdCBpbnZvbHZlcyBhIGxpdHRsZSBtb3JlIHdvcmsuIEl0IG1pZ2h0IGJlIHdvcnRod2hpbGUgdG8gdXNlIGluIGNhc2VzIHdoZXJlIG1vZGVscyBhcmUgc21hbGwsIGJ1dCBpdCB3aWxsIHNsb3cgZG93biBzZXJ2ZXItc2lkZSB2aWV3IHJlbmRlcmluZywgYXMgdGhlIG1vZGVsIGlzIGlubGluZWQgYWxvbmdzaWRlIHRoZSBIVE1MLlxcblxcbiAgICBUaGF0IG1lYW5zIHRoYXQgdGhlIGNvbnRlbnQgeW91IGFyZSBzdXBwb3NlZCB0byBiZSBwcmlvcml0aXppbmcgaXMgZ29pbmcgdG8gdGFrZSBsb25nZXIgdG8gZ2V0IHRvIHlvdXIgaHVtYW5zLCBidXQgb25jZSB0aGV5IGdldCB0aGUgSFRNTCwgdGhpcyBzdHJhdGVneSB3aWxsIGV4ZWN1dGUgdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgYWxtb3N0IGltbWVkaWF0ZWx5LlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIFVzaW5nIHRoZSBgbWFudWFsYCBzdHJhdGVneVxcblxcbiAgICBUaGUgYG1hbnVhbGAgc3RyYXRlZ3kgaXMgdGhlIG1vc3QgaW52b2x2ZWQgb2YgdGhlIHRocmVlLCBidXQgYWxzbyB0aGUgbW9zdCBwZXJmb3JtYW50LiBJbiB0aGlzIHN0cmF0ZWd5IHlvdSdyZSBzdXBwb3NlZCB0byBhZGQgdGhlIGZvbGxvd2luZyBfKHNlZW1pbmdseSBwb2ludGxlc3MpXyBzbmlwcGV0IG9mIGNvZGUgaW4gYSBgPHNjcmlwdD5gIG90aGVyIHRoYW4gdGhlIG9uZSB0aGF0J3MgcHVsbGluZyBkb3duIFRhdW51cywgc28gdGhhdCB0aGV5IGFyZSBwdWxsZWQgY29uY3VycmVudGx5IHJhdGhlciB0aGFuIHNlcmlhbGx5LlxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHdpbmRvdy50YXVudXNSZWFkeSA9IGZ1bmN0aW9uIChtb2RlbCkge1xcbiAgICAgIHdpbmRvdy50YXVudXNSZWFkeSA9IG1vZGVsO1xcbiAgICB9O1xcbiAgICBgYGBcXG5cXG4gICAgT25jZSB5b3Ugc29tZWhvdyBnZXQgeW91ciBoYW5kcyBvbiB0aGUgdmlldyBtb2RlbCwgeW91IHNob3VsZCBpbnZva2UgYHRhdW51c1JlYWR5KG1vZGVsKWAuIENvbnNpZGVyaW5nIHlvdSdsbCBiZSBwdWxsaW5nIGJvdGggdGhlIHZpZXcgbW9kZWwgYW5kIFRhdW51cyBhdCB0aGUgc2FtZSB0aW1lLCBhIG51bWJlciBvZiBkaWZmZXJlbnQgc2NlbmFyaW9zIG1heSBwbGF5IG91dC5cXG5cXG4gICAgLSBUaGUgdmlldyBtb2RlbCBpcyBsb2FkZWQgZmlyc3QsIHlvdSBjYWxsIGB0YXVudXNSZWFkeShtb2RlbClgIGFuZCB3YWl0IGZvciBUYXVudXMgdG8gdGFrZSB0aGUgbW9kZWwgb2JqZWN0IGFuZCBib290IHRoZSBhcHBsaWNhdGlvbiBhcyBzb29uIGFzIGB0YXVudXMubW91bnRgIGlzIGV4ZWN1dGVkXFxuICAgIC0gVGF1bnVzIGxvYWRzIGZpcnN0IGFuZCBgdGF1bnVzLm1vdW50YCBpcyBjYWxsZWQgZmlyc3QuIEluIHRoaXMgY2FzZSwgVGF1bnVzIHdpbGwgcmVwbGFjZSBgd2luZG93LnRhdW51c1JlYWR5YCB3aXRoIGEgc3BlY2lhbCBgYm9vdGAgbWV0aG9kLiBXaGVuIHRoZSB2aWV3IG1vZGVsIGZpbmlzaGVzIGxvYWRpbmcsIHlvdSBjYWxsIGB0YXVudXNSZWFkeShtb2RlbClgIGFuZCB0aGUgYXBwbGljYXRpb24gZmluaXNoZXMgYm9vdGluZ1xcblxcbiAgICA+IElmIHRoaXMgc291bmRzIGEgbGl0dGxlIG1pbmQtYmVuZGluZyBpdCdzIGJlY2F1c2UgaXQgaXMuIEl0J3Mgbm90IGRlc2lnbmVkIHRvIGJlIHByZXR0eSwgYnV0IG1lcmVseSB0byBiZSBwZXJmb3JtYW50LlxcblxcbiAgICBOb3cgdGhhdCB3ZSd2ZSBhZGRyZXNzZWQgdGhlIGF3a3dhcmQgYml0cywgbGV0J3MgY292ZXIgdGhlIF9cXFwic29tZWhvdyBnZXQgeW91ciBoYW5kcyBvbiB0aGUgdmlldyBtb2RlbFxcXCJfIGFzcGVjdC4gTXkgcHJlZmVycmVkIG1ldGhvZCBpcyB1c2luZyBKU09OUCwgYXMgaXQncyBhYmxlIHRvIGRlbGl2ZXIgdGhlIHNtYWxsZXN0IHNuaXBwZXQgcG9zc2libGUsIGFuZCBpdCBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2Ygc2VydmVyLXNpZGUgY2FjaGluZy4gQ29uc2lkZXJpbmcgeW91J2xsIHByb2JhYmx5IHdhbnQgdGhpcyB0byBiZSBhbiBpbmxpbmUgc2NyaXB0LCBrZWVwaW5nIGl0IHNtYWxsIGlzIGltcG9ydGFudC5cXG5cXG4gICAgVGhlIGdvb2QgbmV3cyBpcyB0aGF0IHRoZSBzZXJ2ZXItc2lkZSBzdXBwb3J0cyBKU09OUCBvdXQgdGhlIGJveC4gSGVyZSdzIGEgc25pcHBldCBvZiBjb2RlIHlvdSBjb3VsZCB1c2UgdG8gcHVsbCBkb3duIHRoZSB2aWV3IG1vZGVsIGFuZCBib290IFRhdW51cyB1cCBhcyBzb29uIGFzIGJvdGggb3BlcmF0aW9ucyBhcmUgcmVhZHkuXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgZnVuY3Rpb24gaW5qZWN0ICh1cmwpIHtcXG4gICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XFxuICAgICAgc2NyaXB0LnNyYyA9IHVybDtcXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW5qZWN0b3IgKCkge1xcbiAgICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XFxuICAgICAgdmFyIHNlYXJjaFF1ZXJ5ID0gc2VhcmNoID8gJyYnICsgc2VhcmNoLnN1YnN0cigxKSA6ICcnO1xcbiAgICAgIHZhciBzZWFyY2hKc29uID0gJz9qc29uJmNhbGxiYWNrPXRhdW51c1JlYWR5JyArIHNlYXJjaFF1ZXJ5O1xcbiAgICAgIGluamVjdChsb2NhdGlvbi5wYXRobmFtZSArIHNlYXJjaEpzb24pO1xcbiAgICB9XFxuXFxuICAgIHdpbmRvdy50YXVudXNSZWFkeSA9IGZ1bmN0aW9uIChtb2RlbCkge1xcbiAgICAgIHdpbmRvdy50YXVudXNSZWFkeSA9IG1vZGVsO1xcbiAgICB9O1xcblxcbiAgICBpbmplY3RvcigpO1xcbiAgICBgYGBcXG5cXG4gICAgQXMgbWVudGlvbmVkIGVhcmxpZXIsIHRoaXMgYXBwcm9hY2ggaW52b2x2ZXMgZ2V0dGluZyB5b3VyIGhhbmRzIGRpcnRpZXIgYnV0IGl0IHBheXMgb2ZmIGJ5IGJlaW5nIHRoZSBmYXN0ZXN0IG9mIHRoZSB0aHJlZS5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBDYWNoaW5nXFxuXFxuICAgIFRoZSBjbGllbnQtc2lkZSBpbiBUYXVudXMgc3VwcG9ydHMgY2FjaGluZyBpbi1tZW1vcnkgYW5kIHVzaW5nIHRoZSBlbWJlZGRlZCBJbmRleGVkREIgc3lzdGVtIGJ5IG1lcmVseSB0dXJuaW5nIG9uIHRoZSBgY2FjaGVgIGZsYWcgaW4gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGB0YXVudXMubW91bnRgIG9uIHRoZSBjbGllbnQtc2lkZS5cXG5cXG4gICAgSWYgeW91IHNldCBgY2FjaGVgIHRvIGB0cnVlYCB0aGVuIGNhY2hlZCBpdGVtcyB3aWxsIGJlIGNvbnNpZGVyZWQgX1xcXCJmcmVzaFxcXCIgKHZhbGlkIGNvcGllcyBvZiB0aGUgb3JpZ2luYWwpXyBmb3IgKioxNSBzZWNvbmRzKiouIFlvdSBjYW4gYWxzbyBzZXQgYGNhY2hlYCB0byBhIG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIG9mIHNlY29uZHMgd2lsbCBiZSB1c2VkIGFzIHRoZSBkZWZhdWx0IGluc3RlYWQuXFxuXFxuICAgIENhY2hpbmcgY2FuIGFsc28gYmUgdHdlYWtlZCBvbiBpbmRpdmlkdWFsIHJvdXRlcy4gRm9yIGluc3RhbmNlLCB5b3UgY291bGQgc2V0IGB7IGNhY2hlOiB0cnVlIH1gIHdoZW4gbW91bnRpbmcgVGF1bnVzIGFuZCB0aGVuIGhhdmUgYHsgY2FjaGU6IDM2MDAgfWAgb24gYSByb3V0ZSB0aGF0IHlvdSB3YW50IHRvIGNhY2hlIGZvciBhIGxvbmdlciBwZXJpb2Qgb2YgdGltZS5cXG5cXG4gICAgVGhlIGNhY2hpbmcgbGF5ZXIgaXMgX3NlYW1sZXNzbHkgaW50ZWdyYXRlZF8gaW50byBUYXVudXMsIG1lYW5pbmcgdGhhdCBhbnkgdmlld3MgcmVuZGVyZWQgYnkgVGF1bnVzIHdpbGwgYmUgY2FjaGVkIGFjY29yZGluZyB0byB0aGVzZSBjYWNoaW5nIHJ1bGVzLiBLZWVwIGluIG1pbmQsIGhvd2V2ZXIsIHRoYXQgcGVyc2lzdGVuY2UgYXQgdGhlIGNsaWVudC1zaWRlIGNhY2hpbmcgbGF5ZXIgd2lsbCBvbmx5IGJlIHBvc3NpYmxlIGluIFticm93c2VycyB0aGF0IHN1cHBvcnQgSW5kZXhlZERCXVsxNF0uIEluIHRoZSBjYXNlIG9mIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBJbmRleGVkREIsIFRhdW51cyB3aWxsIHVzZSBhbiBpbi1tZW1vcnkgY2FjaGUsIHdoaWNoIHdpbGwgYmUgd2lwZWQgb3V0IHdoZW5ldmVyIHRoZSBodW1hbiBkZWNpZGVzIHRvIGNsb3NlIHRoZSB0YWIgaW4gdGhlaXIgYnJvd3Nlci5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBQcmVmZXRjaGluZ1xcblxcbiAgICBJZiBjYWNoaW5nIGlzIGVuYWJsZWQsIHRoZSBuZXh0IGxvZ2ljYWwgc3RlcCBpcyBwcmVmZXRjaGluZy4gVGhpcyBpcyBlbmFibGVkIGp1c3QgYnkgYWRkaW5nIGBwcmVmZXRjaDogdHJ1ZWAgdG8gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGB0YXVudXMubW91bnRgLiBUaGUgcHJlZmV0Y2hpbmcgZmVhdHVyZSB3aWxsIGZpcmUgZm9yIGFueSBhbmNob3IgbGluayB0aGF0J3MgdHJpcHMgb3ZlciBhIGBtb3VzZW92ZXJgIG9yIGEgYHRvdWNoc3RhcnRgIGV2ZW50LiBJZiBhIHJvdXRlIG1hdGNoZXMgdGhlIFVSTCBpbiB0aGUgYGhyZWZgLCBhbiBBSkFYIHJlcXVlc3Qgd2lsbCBwcmVmZXRjaCB0aGUgdmlldyBhbmQgY2FjaGUgaXRzIGNvbnRlbnRzLCBpbXByb3ZpbmcgcGVyY2VpdmVkIHBlcmZvcm1hbmNlLlxcblxcbiAgICBXaGVuIGxpbmtzIGFyZSBjbGlja2VkIGJlZm9yZSBwcmVmZXRjaGluZyBmaW5pc2hlcywgdGhleSdsbCB3YWl0IG9uIHRoZSBwcmVmZXRjaGVyIHRvIGZpbmlzaCBiZWZvcmUgaW1tZWRpYXRlbHkgc3dpdGNoaW5nIHRvIHRoZSB2aWV3LCBlZmZlY3RpdmVseSBjdXR0aW5nIGRvd24gdGhlIHJlc3BvbnNlIHRpbWUuIElmIHRoZSBsaW5rIHdhcyBhbHJlYWR5IHByZWZldGNoZWQgb3Igb3RoZXJ3aXNlIGNhY2hlZCwgdGhlIHZpZXcgd2lsbCBiZSBsb2FkZWQgaW1tZWRpYXRlbHkuIElmIHRoZSBodW1hbiBob3ZlcnMgb3ZlciBhIGxpbmsgYW5kIGFub3RoZXIgb25lIHdhcyBhbHJlYWR5IGJlaW5nIHByZWZldGNoZWQsIHRoZW4gdGhhdCBvbmUgaXMgYWJvcnRlZC4gVGhpcyBwcmV2ZW50cyBwcmVmZXRjaGluZyBmcm9tIGRyYWluaW5nIHRoZSBiYW5kd2lkdGggb24gY2xpZW50cyB3aXRoIGxpbWl0ZWQgb3IgaW50ZXJtaXR0ZW50IGNvbm5lY3Rpdml0eS5cXG5cXG4gICAgIyMjIyBWZXJzaW9uaW5nXFxuXFxuICAgIFdoZW4gZW5hYmxlZCwgdmVyc2lvbmluZyB3aWxsIGxvb2sgb3V0IGZvciBkaXNjcmVwYW5jaWVzIGJldHdlZW4gd2hhdCdzIGN1cnJlbnRseSBvbiB0aGUgY2xpZW50IGFuZCB3aGF0J3Mgb24gdGhlIHNlcnZlciwgYW5kIHJlbG9hZCBldmVyeXRoaW5nIG5lY2Vzc2FyeSB0byBtYWtlIHdoYXQncyBvbiB0aGUgY2xpZW50IG1hdGNoIHdoYXQncyBvbiB0aGUgc2VydmVyLlxcblxcbiAgICBJbiBvcmRlciB0byB0dXJuIGl0IG9uLCBzZXQgdGhlIGB2ZXJzaW9uYCBmaWVsZCBpbiB0aGUgb3B0aW9ucyB3aGVuIGludm9raW5nIGB0YXVudXMubW91bnRgICoqb24gYm90aCB0aGUgc2VydmVyLXNpZGUgYW5kIHRoZSBjbGllbnQtc2lkZSwgdXNpbmcgdGhlIHNhbWUgdmFsdWUqKi4gVGhlIFRhdW51cyB2ZXJzaW9uIHN0cmluZyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBvbmUgeW91IHByb3ZpZGVkLCBzbyB0aGF0IFRhdW51cyB3aWxsIGtub3cgdG8gc3RheSBhbGVydCBmb3IgY2hhbmdlcyB0byBUYXVudXMgaXRzZWxmLCBhcyB3ZWxsLlxcblxcbiAgICA+IFRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgZm9yZ2V0IHRvIGNoYW5nZSB0aGUgdmVyc2lvbiBzdHJpbmcgaW4gb25lIG9mIHRoZSBtb3VudHBvaW50cywgcGxlYXNlIGNyZWF0ZSBhIEpTT04gZmlsZSB3aXRoIGp1c3QgdGhlIHZlcnNpb24gc3RyaW5nIGFuZCBgcmVxdWlyZWAgdGhhdCBmaWxlIGluIGJvdGggc2lkZXMuXFxuICAgID5cXG4gICAgPiBgYGBzaGVsbFxcbiAgICA+IGVjaG8gJ1xcXCIxLjAuMFxcXCInID4gdmVyc2lvbi5qc29uXFxuICAgID4gYGBgXFxuXFxuICAgIFRoZSBkZWZhdWx0IHZlcnNpb24gc3RyaW5nIGlzIHNldCB0byBgMWAuIFRoZSBUYXVudXMgdmVyc2lvbiB3aWxsIGJlIHByZXBlbmRlZCB0byB5b3VycywgcmVzdWx0aW5nIGluIGEgdmFsdWUgc3VjaCBhcyBgdDMuMC4wO3YxYCB3aGVyZSBUYXVudXMgaXMgcnVubmluZyB2ZXJzaW9uIGAzLjAuMGAgYW5kIHlvdXIgYXBwbGljYXRpb24gaXMgcnVubmluZyB2ZXJzaW9uIGAxYC5cXG5cXG4gICAgUmVmZXIgdG8gdGhlIEdldHRpbmcgU3RhcnRlZCBndWlkZSBmb3IgYSBtb3JlIGRldGFpbGVkIFthbmFseXNpcyBvZiB0aGUgdXNlcyBmb3IgdmVyc2lvbmluZ11bMTVdLiBUaGVyZSdzIHNvbWUgbW9yZSBudWdnZXRzIG9mIGluZm9ybWF0aW9uIGluIHRoZSBbUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uXVsxOF0gZ3VpZGUgYXMgd2VsbC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5vbih0eXBlLCBmbilgXFxuXFxuICAgIFRhdW51cyBlbWl0cyBhIHNlcmllcyBvZiBldmVudHMgZHVyaW5nIGl0cyBsaWZlY3ljbGUsIGFuZCBgdGF1bnVzLm9uYCBpcyB0aGUgd2F5IHlvdSBjYW4gdHVuZSBpbiBhbmQgbGlzdGVuIGZvciB0aGVzZSBldmVudHMgdXNpbmcgYSBzdWJzY3JpcHRpb24gZnVuY3Rpb24gYGZuYC5cXG5cXG4gICAgRXZlbnQgICAgICAgICAgICB8IEFyZ3VtZW50cyAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvblxcbiAgICAtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGAnc3RhcnQnYCAgICAgICAgfCBgY29udGFpbmVyLCBtb2RlbCwgcm91dGVgIHwgRW1pdHRlZCB3aGVuIGB0YXVudXMubW91bnRgIGZpbmlzaGVkIHRoZSByb3V0ZSBzZXR1cCBhbmQgaXMgYWJvdXQgdG8gaW52b2tlIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyLiBTdWJzY3JpYmUgdG8gdGhpcyBldmVudCBiZWZvcmUgY2FsbGluZyBgdGF1bnVzLm1vdW50YC5cXG4gICAgYCdyZW5kZXInYCAgICAgICB8IGBjb250YWluZXIsIG1vZGVsLCByb3V0ZWAgfCBBIHZpZXcgaGFzIGp1c3QgYmVlbiByZW5kZXJlZCBhbmQgaXRzIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgaXMgYWJvdXQgdG8gYmUgaW52b2tlZFxcbiAgICBgJ2NoYW5nZSdgICAgICAgIHwgYHJvdXRlLCBtb2RlbGAgICAgICAgICAgICB8IFNhbWUgYXMgYCdyZW5kZXInYCwgYnV0IG9ubHkgaWYgYGNvbnRhaW5lcmAgaXMgdGhlIG1vdW50cG9pbnQgYW5kIHRoZSByb3V0ZSBoYXMgY2hhbmdlZC5cXG4gICAgYCdmZXRjaC5zdGFydCdgICB8ICBgcm91dGUsIGNvbnRleHRgICAgICAgICAgfCBFbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IHN0YXJ0cy5cXG4gICAgYCdmZXRjaC5kb25lJ2AgICB8ICBgcm91dGUsIGNvbnRleHQsIGRhdGFgICAgfCBFbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IGVuZHMgc3VjY2Vzc2Z1bGx5LlxcbiAgICBgJ2ZldGNoLmFib3J0J2AgIHwgIGByb3V0ZSwgY29udGV4dGAgICAgICAgICB8IEVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3QgaXMgcHVycG9zZWx5IGFib3J0ZWQuXFxuICAgIGAnZmV0Y2guZXJyb3InYCAgfCAgYHJvdXRlLCBjb250ZXh0LCBlcnJgICAgIHwgRW1pdHRlZCB3aGVuZXZlciBhbiBYSFIgcmVxdWVzdCByZXN1bHRzIGluIGFuIEhUVFAgZXJyb3IuXFxuXFxuICAgIENvbnNpZGVyIGZvciBpbnN0YW5jZSB0aGF0IHlvdSdkIGxpa2UgdG8ga2VlcCB0cmFjayBvZiBldmVyeSB2aWV3IHRoYXQgZ2V0cyByZW5kZXJlZCwgYW5kIHdoYXQgRE9NIGVsZW1lbnQgaXQgZ2V0cyBwbGFjZWQgaW50by4gVGhlIHBpZWNlIG9mIGNvZGUgYmVsb3cgd291bGQgcXVpY2tseSBkbyB0aGF0IGZvciB1cy5cXG5cXG4gICAgYGBganNcXG4gICAgdGF1bnVzLm9uKCdyZW5kZXInLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XFxuICAgICAgY29uc29sZS5sb2coJ1JlbmRlcmVkIGEgdmlldyBvbicsIGNvbnRhaW5lcik7XFxuICAgIH0pO1xcbiAgICBgYGBcXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5vbmNlKHR5cGUsIGZuKWBcXG5cXG4gICAgVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBbYHRhdW51cy5vbmBdKCMtdGF1bnVzLW9uLXR5cGUtZm4tKSwgZXhjZXB0IHRoZSBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSB1c2VkIG9uY2UgYW5kIHRoZW4gaXQnbGwgYmUgZGlzY2FyZGVkLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgdGF1bnVzLm9mZih0eXBlLCBmbilgXFxuXFxuICAgIFVzaW5nIHRoaXMgbWV0aG9kIHlvdSBjYW4gcmVtb3ZlIGFueSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgYWRkZWQgdXNpbmcgYC5vbmAgb3IgYC5vbmNlYC4gWW91IG11c3QgcHJvdmlkZSB0aGUgdHlwZSBvZiBldmVudCB5b3Ugd2FudCB0byByZW1vdmUgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IHdhcyBvcmlnaW5hbGx5IHVzZWQgd2hlbiBjYWxsaW5nIGAub25gIG9yIGAub25jZWAuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGB0YXVudXMuaW50ZXJjZXB0KGFjdGlvbj8sIGZuKWBcXG5cXG4gICAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gYW50aWNpcGF0ZSBtb2RlbCByZXF1ZXN0cywgYmVmb3JlIHRoZXkgZXZlciBtYWtlIGl0IGludG8gWEhSIHJlcXVlc3RzLiBZb3UgY2FuIGFkZCBpbnRlcmNlcHRvcnMgZm9yIHNwZWNpZmljIGFjdGlvbnMsIHdoaWNoIHdvdWxkIGJlIHRyaWdnZXJlZCBvbmx5IGlmIHRoZSByZXF1ZXN0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBgYWN0aW9uYC4gWW91IGNhbiBhbHNvIGFkZCBnbG9iYWwgaW50ZXJjZXB0b3JzIGJ5IG9taXR0aW5nIHRoZSBgYWN0aW9uYCBwYXJhbWV0ZXIsIG9yIHNldHRpbmcgaXQgdG8gYCpgLlxcblxcbiAgICBBbiBpbnRlcmNlcHRvciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYW4gYGV2ZW50YCBwYXJhbWV0ZXIsIGNvbnRhaW5pbmcgYSBmZXcgZGlmZmVyZW50IHByb3BlcnRpZXMuXFxuXFxuICAgIC0gYHVybGAgY29udGFpbnMgdGhlIFVSTCB0aGF0IG5lZWRzIGEgdmlldyBtb2RlbFxcbiAgICAtIGByb3V0ZWAgY29udGFpbnMgdGhlIGZ1bGwgcm91dGUgb2JqZWN0IGFzIHlvdSdkIGdldCBmcm9tIFtgdGF1bnVzLnJvdXRlKHVybCwgc3RhcnRJbmRleD8pYF0oIy10YXVudXMtcm91dGUtdXJsLXN0YXJ0aW5kZXgtKVxcbiAgICAtIGBwYXJ0c2AgaXMganVzdCBhIHNob3J0Y3V0IGZvciBgcm91dGUucGFydHNgXFxuICAgIC0gYHByZXZlbnREZWZhdWx0KGRhdGEpYCBhbGxvd3MgeW91IHRvIHN1cHByZXNzIHRoZSBuZWVkIGZvciBhbiBBSkFYIHJlcXVlc3QsIGNvbW1hbmRpbmcgVGF1bnVzIHRvIHVzZSB0aGUgcmVzcG9uc2UgZGF0YSB5b3UndmUgcHJvdmlkZWQgaW5zdGVhZFxcbiAgICAtIGBkZWZhdWx0UHJldmVudGVkYCB0ZWxscyB5b3UgaWYgc29tZSBvdGhlciBoYW5kbGVyIGhhcyBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYmVoYXZpb3JcXG4gICAgLSBgY2FuUHJldmVudERlZmF1bHRgIHRlbGxzIHlvdSBpZiBpbnZva2luZyBgZXZlbnQucHJldmVudERlZmF1bHRgIHdpbGwgaGF2ZSBhbnkgZWZmZWN0XFxuICAgIC0gYGRhdGFgIHN0YXJ0cyBhcyBgbnVsbGAsIGFuZCBpdCBjYW4gbGF0ZXIgYmVjb21lIHRoZSBkYXRhIHBhc3NlZCB0byBgcHJldmVudERlZmF1bHRgXFxuXFxuICAgIEludGVyY2VwdG9ycyBhcmUgYXN5bmNocm9ub3VzLCBidXQgaWYgYW4gaW50ZXJjZXB0b3Igc3BlbmRzIGxvbmdlciB0aGFuIDUwbXMgaXQnbGwgYmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBjYWxsaW5nIGBldmVudC5wcmV2ZW50RGVmYXVsdGAgcGFzdCB0aGF0IHBvaW50IHdvbid0IGhhdmUgYW55IGVmZmVjdC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5wYXJ0aWFsKGNvbnRhaW5lciwgYWN0aW9uLCBtb2RlbClgXFxuXFxuICAgIFRoaXMgbWV0aG9kIHByb3ZpZGVzIHlvdSB3aXRoIGFjY2VzcyB0byB0aGUgdmlldy1yZW5kZXJpbmcgZW5naW5lIG9mIFRhdW51cy4gWW91IGNhbiB1c2UgaXQgdG8gcmVuZGVyIHRoZSBgYWN0aW9uYCB2aWV3IGludG8gdGhlIGBjb250YWluZXJgIERPTSBlbGVtZW50LCB1c2luZyB0aGUgc3BlY2lmaWVkIGBtb2RlbGAuIE9uY2UgdGhlIHZpZXcgaXMgcmVuZGVyZWQsIHRoZSBgcmVuZGVyYCBldmVudCB3aWxsIGJlIGZpcmVkIF8od2l0aCBgY29udGFpbmVyLCBtb2RlbGAgYXMgYXJndW1lbnRzKV8gYW5kIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyIGZvciB0aGF0IHZpZXcgd2lsbCBiZSBleGVjdXRlZC5cXG5cXG4gICAgTm90ZSB0aGF0IHRoZSBwYXJ0aWFsIG1heSBiZSByZW5kZXJlZCBhc3luY2hyb25vdXNseSBpZiB0aGUgYGFjdGlvbmAgaXMgW2RlZmVycmVkXSgjLWRlZmVyLWFjdGlvbnMtKSBhbmQgaXRzIGNvbXBvbmVudHMgKHZpZXcgdGVtcGxhdGUsIGNvbnRyb2xsZXIpIGFyZW4ndCByZWFkaWx5IGF2YWlsYWJsZSBpbiB0aGUgY2xpZW50IHlldC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5uYXZpZ2F0ZSh1cmwsIG9wdGlvbnMpYFxcblxcbiAgICBXaGVuZXZlciB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0byBhIFVSTCwgc2F5IHdoZW4gYW4gQUpBWCBjYWxsIGZpbmlzaGVzIGFmdGVyIGEgYnV0dG9uIGNsaWNrLCB5b3UgY2FuIHVzZSBgdGF1bnVzLm5hdmlnYXRlYCBwYXNzaW5nIGl0IGEgcGxhaW4gVVJMIG9yIGFueXRoaW5nIHRoYXQgd291bGQgY2F1c2UgYHRhdW51cy5yb3V0ZSh1cmwsIHN0YXJ0SW5kZXg/KWAgdG8gcmV0dXJuIGEgdmFsaWQgcm91dGUuXFxuXFxuICAgIEJ5IGRlZmF1bHQsIGlmIGB0YXVudXMubmF2aWdhdGUodXJsLCBvcHRpb25zKWAgaXMgY2FsbGVkIHdpdGggYW4gYHVybGAgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBjbGllbnQtc2lkZSByb3V0ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHJlZGlyZWN0ZWQgdmlhIGBsb2NhdGlvbi5ocmVmYC4gSW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBoaXN0b3J5IEFQSSwgYGxvY2F0aW9uLmhyZWZgIHdpbGwgYmUgdXNlZCBhcyB3ZWxsLlxcblxcbiAgICBUaGVyZSdzIGEgZmV3IG9wdGlvbnMgeW91IGNhbiB1c2UgdG8gdHdlYWsgdGhlIGJlaGF2aW9yIG9mIGB0YXVudXMubmF2aWdhdGVgLlxcblxcbiAgICBPcHRpb24gICAgICAgICAgIHwgRGVzY3JpcHRpb25cXG4gICAgLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBgY29udGV4dGAgICAgICAgIHwgQSBET00gZWxlbWVudCB0aGF0IGNhdXNlZCB0aGUgbmF2aWdhdGlvbiBldmVudCwgdXNlZCB3aGVuIGVtaXR0aW5nIGV2ZW50c1xcbiAgICBgc3RyaWN0YCAgICAgICAgIHwgSWYgc2V0IHRvIGB0cnVlYCBhbmQgdGhlIFVSTCBkb2Vzbid0IG1hdGNoIGFueSByb3V0ZSwgdGhlbiB0aGUgbmF2aWdhdGlvbiBhdHRlbXB0IG11c3QgYmUgaWdub3JlZFxcbiAgICBgc2Nyb2xsYCAgICAgICAgIHwgV2hlbiB0aGlzIGlzIHNldCB0byBgZmFsc2VgLCBlbGVtZW50cyBhcmVuJ3Qgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIG5hdmlnYXRpb25cXG4gICAgYGZvcmNlYCAgICAgICAgICB8IFVubGVzcyB0aGlzIGlzIHNldCB0byBgdHJ1ZWAsIG5hdmlnYXRpb24gd29uJ3QgX2ZldGNoIGEgbW9kZWxfIGlmIHRoZSByb3V0ZSBtYXRjaGVzIHRoZSBjdXJyZW50IHJvdXRlLCBhbmQgYHN0YXRlLm1vZGVsYCB3aWxsIGJlIHJldXNlZCBpbnN0ZWFkXFxuICAgIGByZXBsYWNlU3RhdGVgICAgfCBVc2UgYHJlcGxhY2VTdGF0ZWAgaW5zdGVhZCBvZiBgcHVzaFN0YXRlYCB3aGVuIGNoYW5naW5nIGhpc3RvcnlcXG5cXG4gICAgTm90ZSB0aGF0IHRoZSBub3Rpb24gb2YgX2ZldGNoaW5nIGEgbW9kZWxfIG1pZ2h0IGJlIGRlY2VpdmluZyBhcyB0aGUgbW9kZWwgY291bGQgYmUgcHVsbGVkIGZyb20gdGhlIGNhY2hlIGV2ZW4gaWYgYGZvcmNlYCBpcyBzZXQgdG8gYHRydWVgLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgdGF1bnVzLnJvdXRlKHVybCwgc3RhcnRJbmRleD8pYFxcblxcbiAgICBUaGlzIGNvbnZlbmllbmNlIG1ldGhvZCBhbGxvd3MgeW91IHRvIGJyZWFrIGRvd24gYSBVUkwgaW50byBpdHMgaW5kaXZpZHVhbCBjb21wb25lbnRzLiBUaGUgbWV0aG9kIGFjY2VwdHMgYW55IG9mIHRoZSBmb2xsb3dpbmcgVVJMIHBhdHRlcm5zLCBhbmQgaXQgcmV0dXJucyBhIFRhdW51cyByb3V0ZSBvYmplY3QuIFRoZSBvcHRpb25hbCBgc3RhcnRJbmRleGAgYXJndW1lbnQgc3BlY2lmaWVzIHdoYXQgaW5kZXggdG8gc3RhcnQgYXQsIGFzIHNlZW4gb24gYHRhdW51cy5zdGF0ZS5yb3V0ZXNgLlxcblxcbiAgICAtIEEgZnVsbHkgcXVhbGlmaWVkIFVSTCBvbiB0aGUgc2FtZSBvcmlnaW4sIGUuZyBgaHR0cDovL3RhdW51cy5iZXZhY3F1YS5pby9hcGlgXFxuICAgIC0gQW4gYWJzb2x1dGUgVVJMIHdpdGhvdXQgYW4gb3JpZ2luLCBlLmcgYC9hcGlgXFxuICAgIC0gSnVzdCBhIGhhc2gsIGUuZyBgI2Zvb2AgXyhgbG9jYXRpb24uaHJlZmAgaXMgdXNlZClfXFxuICAgIC0gRmFsc3kgdmFsdWVzLCBlLmcgYG51bGxgIF8oYGxvY2F0aW9uLmhyZWZgIGlzIHVzZWQpX1xcblxcbiAgICBSZWxhdGl2ZSBVUkxzIGFyZSBub3Qgc3VwcG9ydGVkIF8oYW55dGhpbmcgdGhhdCBkb2Vzbid0IGhhdmUgYSBsZWFkaW5nIHNsYXNoKV8sIGUuZyBgZmlsZXMvZGF0YS5qc29uYC4gQW55dGhpbmcgdGhhdCdzIG5vdCBvbiB0aGUgc2FtZSBvcmlnaW4gb3IgZG9lc24ndCBtYXRjaCBvbmUgb2YgdGhlIHJlZ2lzdGVyZWQgcm91dGVzIGlzIGdvaW5nIHRvIHlpZWxkIGBudWxsYC5cXG5cXG4gICAgX1RoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiBkZWJ1Z2dpbmcgeW91ciByb3V0aW5nIHRhYmxlcywgYXMgaXQgZ2l2ZXMgeW91IGRpcmVjdCBhY2Nlc3MgdG8gdGhlIHJvdXRlciB1c2VkIGludGVybmFsbHkgYnkgVGF1bnVzLl9cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBgdGF1bnVzLnJvdXRlLmVxdWFscyhyb3V0ZSwgcm91dGUpYFxcblxcbiAgICBDb21wYXJlcyB0d28gcm91dGVzIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGV5IHdvdWxkIGZldGNoIHRoZSBzYW1lIG1vZGVsLiBOb3RlIHRoYXQgZGlmZmVyZW50IFVSTHMgbWF5IHN0aWxsIHJldHVybiBgdHJ1ZWAuIEZvciBpbnN0YW5jZSwgYC9mb29gIGFuZCBgL2ZvbyNiYXJgIHdvdWxkIGZldGNoIHRoZSBzYW1lIG1vZGVsIGV2ZW4gaWYgdGhleSdyZSBkaWZmZXJlbnQgVVJMcy5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMgYHRhdW51cy5yZXNvbHZlYCBvbiB0aGUgY2xpZW50XFxuXFxuICAgIFRoaXMgbWV0aG9kIGlzIGlkZW50aWNhbCB0byB0aGUgc2VydmVyLXNpZGUgZmxhdm9yIG9mIFtgdGF1bnVzLnJlc29sdmUoYWN0aW9uLCBkYXRhKWBdKCMtdGF1bnVzLXJlc29sdmUtYWN0aW9uLWRhdGEtKSwgYnV0IGF2YWlsYWJsZSBvbiB0aGUgY2xpZW50LXNpZGUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIGB0YXVudXMuc3RhdGVgXFxuXFxuICAgIFRoaXMgaXMgYW4gaW50ZXJuYWwgc3RhdGUgdmFyaWFibGUsIGFuZCBpdCBjb250YWlucyBhIGxvdCBvZiB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uLlxcblxcbiAgICAtIGBjb250YWluZXJgIGlzIHRoZSBET00gZWxlbWVudCBwYXNzZWQgdG8gYHRhdW51cy5tb3VudGBcXG4gICAgLSBgY29udHJvbGxlcnNgIGFyZSBhbGwgdGhlIGNvbnRyb2xsZXJzLCBhcyBkZWZpbmVkIGluIHRoZSB3aXJpbmcgbW9kdWxlXFxuICAgIC0gYHRlbXBsYXRlc2AgYXJlIGFsbCB0aGUgdGVtcGxhdGVzLCBhcyBkZWZpbmVkIGluIHRoZSB3aXJpbmcgbW9kdWxlXFxuICAgIC0gYHJvdXRlc2AgYXJlIGFsbCB0aGUgcm91dGVzLCBhcyBkZWZpbmVkIGluIHRoZSB3aXJpbmcgbW9kdWxlXFxuICAgIC0gYHJvdXRlYCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByb3V0ZVxcbiAgICAtIGBtb2RlbGAgaXMgYSByZWZlcmVuY2UgdG8gdGhlIG1vZGVsIHVzZWQgdG8gcmVuZGVyIHRoZSBjdXJyZW50IHZpZXdcXG4gICAgLSBgcHJlZmV0Y2hgIGV4cG9zZXMgd2hldGhlciBwcmVmZXRjaGluZyBpcyB0dXJuZWQgb25cXG4gICAgLSBgY2FjaGVgIGV4cG9zZXMgd2hldGhlciBjYWNoaW5nIGlzIGVuYWJsZWRcXG4gICAgLSBgdmVyc2lvbmAgZXhwb3NlcyB0aGUgdmVyc2lvbiBzdHJpbmcgdGhhdCdzIGN1cnJlbnRseSBpbiB1c2VcXG5cXG4gICAgVGhlcmUncyBhbHNvIGEgYGNsZWFyYCBtZXRob2QgYWNjZXNzaWJsZSB0aHJvdWdoIGB0YXVudXMuc3RhdGUuY2xlYXJgLCB3aGljaCB3aWxsIGVtcHR5IHRoZSBjYWNoZSwgYXMgd2VsbCBhcyByZW1vdmUgZnJvbSB0aGUgYHN0YXRlYCBhbnkgY29udHJvbGxlcnMgYW5kIHRlbXBsYXRlcyB0aGF0IHdlcmUgbGF6eSBsb2FkZWQuXFxuXFxuICAgIE9mIGNvdXJzZSwgeW91J3JlIG5vdCBzdXBwb3NlZCB0byBtZWRkbGUgd2l0aCBpdCwgc28gYmUgYSBnb29kIGNpdGl6ZW4gYW5kIGp1c3QgaW5zcGVjdCBpdHMgdmFsdWVzIVxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyBgdGF1bnVzLnhocih1cmwsIG9wdGlvbnM/LCBkb25lKWBcXG5cXG4gICAgVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBpc3N1ZSB5b3VyIG93biBBSkFYIHJlcXVlc3RzIHRocm91Z2ggdGhlIGB4aHJgIG1vZHVsZS4gSXQgc2V0cyBhIGZldyBjb252ZW5pZW50IGRlZmF1bHRzLCBfbGlzdGVkIGJlbG93Xywgd2hlcmUgYHVybGAgcmVmZXJzIHRvIHRoZSBVUkwgcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXFxuXFxuICAgIGBgYGpzXFxuICAgIHtcXG4gICAgICB1cmw6IHVybCxcXG4gICAgICBqc29uOiB0cnVlLFxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicgfVxcbiAgICB9XFxuICAgIGBgYFxcblxcbiAgICBUaGUgYGRvbmUoZXJyLCBib2R5LCByZXMpYCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlcywgYW5kIGl0J2xsIGJlIHBhc3NlZCB0aHJlZSBwYXJhbWV0ZXJzLCBhbiBvcHRpb25hbCBlcnJvciBpZiBzb21ldGhpbmcgd2VudCB3cm9uZyBfKHJlcXVlc3QgZmFpbGVkLCB3YXMgYWJvcnRlZCwgZXRjLilfIGFuZCBhIGBib2R5YCBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgcmVzcG9uc2UgYm9keS4gVGhlIHJhdyBgcmVzYCBvYmplY3QgdGhhdCdzIHR5cGljYWxseSBwcm92aWRlZCBieSBbYHhocmBdWzE2XSBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBwcm92aWRlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIGluc3RlYWQuXFxuXFxuICAgIEFzIGFuIGV4YW1wbGUsIGhlcmUgaXMgYSBgR0VUYCByZXF1ZXN0LlxcblxcbiAgICBgYGBqc1xcbiAgICB0YXVudXMueGhyKCcvYXBpL3BsYWNlcycsIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcXG4gICAgICBjb25zb2xlLmxvZyhib2R5KTtcXG4gICAgICAvLyA8LSB7IHBsYWNlczogWyd1bmRlcndhdGVyIGZvcnRyZXNzJywgJ2lzbGFuZCBtYW5zaW9uJ10gfVxcbiAgICB9KTtcXG4gICAgYGBgXFxuXFxuICAgIEFsd2F5cyByZW1lbWJlciB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYGVycmAgaXMgc2V0IVxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIFVzaW5nIGB0YXVudXMucHJlZmV0Y2godXJsLCBlbGVtZW50KWBcXG5cXG4gICAgVGhlIHByZWZldGNoZXIgQVBJIGFsbG93cyB5b3UgdG8gc3RhcnQgZmV0Y2hpbmcgYW4gYHVybGAsIHByb3ZpZGVkIHRoYXQgaXQgbWF0Y2hlcyBhIGtub3duIFRhdW51cyB2aWV3IHJvdXRlIGFuZCB0aGF0IFt0aGUgY2FjaGVdKCNjYWNoaW5nKSBpcyBlbmFibGVkLiBUaGUgYGVsZW1lbnRgIGlzIHVzZWQgbW9zdGx5IGFzIGNvbnRleHQgZHVyaW5nIGV2ZW50IGVtaXNzaW9uLCBhbmQgaXQgY2FuIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nIGFzIHdlbGwuXFxuXFxuICAgIFVzZSBjYXNlcyBmb3IgcHJlZmV0Y2hpbmcgYXJlIGZ1cnRoZXIgZGlzY3Vzc2VkIGluIHRoZSBbUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uXVsxOV0gZ3VpZGUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIERlYnVnZ2luZyBUYXVudXNcXG5cXG4gICAgT24gdGhlIGNsaWVudC1zaWRlLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYHJlcXVpcmVgIFRhdW51cyB1c2luZyB0aGUgc3RhdGVtZW50IGJlbG93LlxcblxcbiAgICBgYGBqc1xcbiAgICB2YXIgdGF1bnVzID0gcmVxdWlyZSgndGF1bnVzJyk7XFxuICAgIGBgYFxcblxcbiAgICBIb3dldmVyLCB5b3UgY291bGQgYWxzbyB0dXJuIG9uIHRoZSBpbnRlcm5hbCBkZWJ1ZyBsb2dnZXIgc2ltcGx5IGJ5IHVzaW5nIGFub3RoZXIgZW50cnkgcG9pbnQhXFxuXFxuICAgIGBgYGpzXFxuICAgIHZhciB0YXVudXMgPSByZXF1aXJlKCd0YXVudXMvYnJvd3Nlci9kZWJ1ZycpO1xcbiAgICBgYGBcXG5cXG4gICAgVGhlIHNjcmVlbnNob3QgYmVsb3cgY29udGFpbnMgYW4gZXhhbXBsZSBvZiB0aGlzIG1lY2hhbmlzbSwgd2hlcmUgdXNpbmcgW2B0YXVudXMucGFydGlhbGBdKCMtdGF1bnVzLXBhcnRpYWwtY29udGFpbmVyLWFjdGlvbi1tb2RlbC0pIHRyaWdnZXJzIGEgZmx1cnJ5IG9mIGRlYnVnIG1lc3NhZ2VzLlxcblxcbiAgICAhW2RlYnVnLnBuZ11bMTddXFxuXFxuICAgIFRoaXMgaXMgcGFydGljdWxhcmx5IGhlbHBmdWwgZHVyaW5nIGRldmVsb3BtZW50LCBidXQgYWxzbyB1c2VmdWwgaWYgeW91IGRvbid0IHVuZGVyc3RhbmQgZXhhY3RseSBob3cgVGF1bnVzIGlzIGRvaW5nIHNvbWV0aGluZywgYXMgdGhlIGxvZ2dlciBpcyBwcmV0dHkgdmVyYm9zZS5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyBDbGllbnQtU2lkZSBDb250cm9sbGVyc1xcblxcbiAgICBDbGllbnQtc2lkZSBjb250cm9sbGVycyBhcmUgZXhlY3V0ZWQgcmlnaHQgYWZ0ZXIgYSB2aWV3IGlzIHJlbmRlcmVkLCBldmVuIGluIHRoZSBjYXNlIG9mIFtwYXJ0aWFsIHZpZXdzXSgjLXRhdW51cy1wYXJ0aWFsLWNvbnRhaW5lci1hY3Rpb24tbW9kZWwtKS4gVGhlc2UgY29udHJvbGxlcnMgYXJlIHVzZWQgdG8gcHJvZ3Jlc3NpdmVseSBhZGQgYmVoYXZpb3Igb24gdG9wIG9mIHRoZSBIVE1MIGZvciB0aGF0IHZpZXcuXFxuXFxuICAgIFZpZXcgY29udHJvbGxlcnMgdGFrZSB0aHJlZSBwYXJhbWV0ZXJzLlxcblxcbiAgICBQYXJhbWV0ZXIgICB8IERlc2NyaXB0aW9uXFxuICAgIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBgbW9kZWxgICAgICB8IE1vZGVsIHRoYXQgd2FzIHVzZWQgdG8gcmVuZGVyIHRoZSB2aWV3XFxuICAgIGBjb250YWluZXJgIHwgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSB2aWV3IHdhcyByZW5kZXJlZFxcbiAgICBgcm91dGU/YCAgICB8IFJvdXRlIHRoYXQgdHJpZ2dlcmVkIHRoZSByZW5kZXJpbmcgZW5naW5lLiBNYXkgYmUgYG51bGxgXFxuXFxuICAgIE5vdGUgdGhhdCBUYXVudXMgd2lsbCBbZW1pdCBhIGByZW5kZXJgIGV2ZW50XSgjLXRhdW51cy1vbi10eXBlLWZuLSkgcmlnaHQgYmVmb3JlIHRoZSB2aWV3IGNvbnRyb2xsZXIgZ2V0cyBleGVjdXRlZCwgZ2l2aW5nIHlvdSBhIGNoYW5jZSB0byByZWFjdCB0byB2aWV3cyBnZXR0aW5nIHJlbmRlcmVkLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIFRoZSBgLnRhdW51c3JjYCBtYW5pZmVzdFxcblxcbiAgICBJZiB5b3Ugd2FudCB0byB1c2UgdmFsdWVzIG90aGVyIHRoYW4gdGhlIGNvbnZlbnRpb25hbCBkZWZhdWx0cyBzaG93biBpbiB0aGUgdGFibGUgYmVsb3csIHRoZW4geW91IHNob3VsZCBjcmVhdGUgYSBgLnRhdW51c3JjYCBmaWxlLiBOb3RlIHRoYXQgdGhlIGRlZmF1bHRzIG5lZWQgdG8gYmUgb3ZlcndyaXR0ZW4gaW4gYSBjYXNlLWJ5LWNhc2UgYmFzaXMuIFRoZXNlIG9wdGlvbnMgY2FuIGFsc28gYmUgY29uZmlndXJlZCBpbiB5b3VyIGBwYWNrYWdlLmpzb25gLCB1bmRlciB0aGUgYHRhdW51c2AgcHJvcGVydHkuXFxuXFxuICAgIGBgYGpzb25cXG4gICAge1xcbiAgICAgIFxcXCJ2aWV3c1xcXCI6IFxcXCIuYmluL3ZpZXdzXFxcIixcXG4gICAgICBcXFwic2VydmVyX3JvdXRlc1xcXCI6IFxcXCJjb250cm9sbGVycy9yb3V0ZXMuanNcXFwiLFxcbiAgICAgIFxcXCJzZXJ2ZXJfY29udHJvbGxlcnNcXFwiOiBcXFwiY29udHJvbGxlcnNcXFwiLFxcbiAgICAgIFxcXCJjbGllbnRfY29udHJvbGxlcnNcXFwiOiBcXFwiY2xpZW50L2pzL2NvbnRyb2xsZXJzXFxcIixcXG4gICAgICBcXFwiY2xpZW50X3dpcmluZ1xcXCI6IFxcXCIuYmluL3dpcmluZy5qc1xcXCJcXG4gICAgfVxcbiAgICBgYGBcXG5cXG4gICAgLSBUaGUgYHZpZXdzYCBkaXJlY3RvcnkgaXMgd2hlcmUgeW91ciB2aWV3cyBfKGFscmVhZHkgY29tcGlsZWQgaW50byBKYXZhU2NyaXB0KV8gYXJlIHBsYWNlZC4gVGhlc2Ugdmlld3MgYXJlIHVzZWQgZGlyZWN0bHkgb24gYm90aCB0aGUgc2VydmVyLXNpZGUgYW5kIHRoZSBjbGllbnQtc2lkZVxcbiAgICAtIFRoZSBgc2VydmVyX3JvdXRlc2AgZmlsZSBpcyB0aGUgbW9kdWxlIHdoZXJlIHlvdSBleHBvcnQgYSBjb2xsZWN0aW9uIG9mIHJvdXRlcy4gVGhlIENMSSB3aWxsIHB1bGwgdGhlc2Ugcm91dGVzIHdoZW4gY3JlYXRpbmcgdGhlIGNsaWVudC1zaWRlIHJvdXRlcyBmb3IgdGhlIHdpcmluZyBtb2R1bGVcXG4gICAgLSBUaGUgYHNlcnZlcl9jb250cm9sbGVyc2AgZGlyZWN0b3J5IGlzIHRoZSByb290IGRpcmVjdG9yeSB3aGVyZSB5b3VyIHNlcnZlci1zaWRlIGNvbnRyb2xsZXJzIGxpdmUuIEl0J3MgdXNlZCB3aGVuIHNldHRpbmcgdXAgdGhlIHNlcnZlci1zaWRlIHJvdXRlclxcbiAgICAtIFRoZSBgY2xpZW50X2NvbnRyb2xsZXJzYCBkaXJlY3RvcnkgaXMgd2hlcmUgeW91ciBjbGllbnQtc2lkZSBjb250cm9sbGVyIG1vZHVsZXMgbGl2ZS4gVGhlIENMSSB3aWxsIGByZXF1aXJlYCB0aGVzZSBjb250cm9sbGVycyBpbiBpdHMgcmVzdWx0aW5nIHdpcmluZyBtb2R1bGVcXG4gICAgLSBUaGUgYGNsaWVudF93aXJpbmdgIGZpbGUgaXMgd2hlcmUgeW91ciB3aXJpbmcgbW9kdWxlIHdpbGwgYmUgcGxhY2VkIGJ5IHRoZSBDTEkuIFlvdSdsbCB0aGVuIGhhdmUgdG8gYHJlcXVpcmVgIGl0IGluIHlvdXIgYXBwbGljYXRpb24gd2hlbiBib290aW5nIHVwIFRhdW51c1xcblxcbiAgICBIZXJlIGlzIHdoZXJlIHRoaW5ncyBnZXQgW2EgbGl0dGxlIGNvbnZlbnRpb25hbF1bMTJdLiBWaWV3cywgYW5kIGJvdGggc2VydmVyLXNpZGUgYW5kIGNsaWVudC1zaWRlIGNvbnRyb2xsZXJzIGFyZSBleHBlY3RlZCB0byBiZSBvcmdhbml6ZWQgYnkgZm9sbG93aW5nIHRoZSBge3Jvb3R9L3tjb250cm9sbGVyfS97YWN0aW9ufWAgcGF0dGVybiwgYnV0IHlvdSBjb3VsZCBjaGFuZ2UgdGhhdCB1c2luZyBgcmVzb2x2ZXJzYCB3aGVuIGludm9raW5nIHRoZSBDTEkgYW5kIHVzaW5nIHRoZSBzZXJ2ZXItc2lkZSBBUEkuXFxuXFxuICAgIFZpZXdzIGFuZCBjb250cm9sbGVycyBhcmUgYWxzbyBleHBlY3RlZCB0byBiZSBDb21tb25KUyBtb2R1bGVzIHRoYXQgZXhwb3J0IGEgc2luZ2xlIG1ldGhvZC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgWzFdOiAvZ2V0dGluZy1zdGFydGVkXFxuICAgIFsyXTogaHR0cDovL2V4cHJlc3Nqcy5jb21cXG4gICAgWzNdOiBodHRwOi8vaGFwaWpzLmNvbVxcbiAgICBbNF06IGh0dHBzOi8vZ2l0aHViLmNvbS9wb255Zm9vL3Bvbnlmb28vYmxvYi8zMzI3MTc1MTMxMmRiNmU5MjA1OWQ5ODI5M2QwYTdhYzZlOWU4ZTViL3ZpZXdzL3NlcnZlci9sYXlvdXQvbGF5b3V0LmphZGVcXG4gICAgWzVdOiBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvaGdldFxcbiAgICBbNl06IGh0dHBzOi8vZ2l0aHViLmNvbS9wb255Zm9vL3Bvbnlmb28vYmxvYi9mNmQ2YjUwNjhmZjAzYTM4N2Y1MDM5MDAxNjBkOWZkYzFlNzQ5NzUwL2NvbnRyb2xsZXJzL3JvdXRpbmcuanMjTDcwLUw3MlxcbiAgICBbN106IGh0dHBzOi8vZ2l0aHViLmNvbS90YXVudXMvdGF1bnVzLWV4cHJlc3NcXG4gICAgWzhdOiBodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy1oYXBpXFxuICAgIFs5XTogaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy9oYXBpaWZ5XFxuICAgIFsxMF06IGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWRcXG4gICAgWzExXTogaHR0cDovL2Jyb3dzZXJpZnkub3JnXFxuICAgIFsxMl06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmVudGlvbl9vdmVyX2NvbmZpZ3VyYXRpb25cXG4gICAgWzEzXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW5nbGUtcGFnZV9hcHBsaWNhdGlvblxcbiAgICBbMTRdOiBodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9aW5kZXhlZGRiXFxuICAgIFsxNV06IC9nZXR0aW5nLXN0YXJ0ZWQjdmVyc2lvbmluZ1xcbiAgICBbMTZdOiBodHRwczovL2dpdGh1Yi5jb20vUmF5bm9zL3hoclxcbiAgICBbMTddOiBodHRwOi8vaS5pbWd1ci5jb20vQ2piSUh5MC5wbmdcXG4gICAgWzE4XTogL3BlcmZvcm1hbmNlI3VzZS12ZXJzaW9uaW5nLXRvLWVuc3VyZS1jYWNoZS12YWxpZGl0eVxcbiAgICBbMTldOiAvcGVyZm9ybWFuY2UjZW5hYmxlLXByZWZldGNoaW5nLWZvci1wcmVkaWN0aXZlLWNhY2hlLWxvYWRpbmdcXG4gICAgWzIwXTogL3BlcmZvcm1hbmNlI3NlbmQtdmlld3MtYW5kLWNvbnRyb2xsZXJzLXRvLXRoZS1jbGllbnQtc2VsZWN0aXZlbHlcXG5cIik7XG59XG59IiwidmFyIGphZGUgPSByZXF1aXJlKFwiamFkdW0vcnVudGltZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGxlbWVudHMobG9jYWxzKSB7XG52YXIgamFkZV9kZWJ1ZyA9IFt7IGxpbmVubzogMSwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9jb21wbGVtZW50cy5qYWRlXCIgfV07XG50cnkge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vY29tcGxlbWVudHMuamFkZVwiIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAxLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2NvbXBsZW1lbnRzLmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPHNlY3Rpb24gY2xhc3M9XFxcImx5LXNlY3Rpb24gbWQtbWFya2Rvd25cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMiwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9jb21wbGVtZW50cy5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMSBpZD1cXFwiY29tcGxlbWVudGFyeS1tb2R1bGVzXFxcIj5Db21wbGVtZW50YXJ5IE1vZHVsZXM8L2gxPlxcbjxwPlRhdW51cyBpcyBhIHNtYWxsIGxpYnJhcnkgYnkgTVZDIGZyYW1ld29yayBzdGFuZGFyZHMsIHNpdHRpbmcgPHN0cm9uZz5iZWxvdyAxNWtCIG1pbmlmaWVkIGFuZCBnemlwcGVkPC9zdHJvbmc+LiBJdCBpcyBkZXNpZ25lZCB0byBiZSBzbWFsbC4gSXQgaXMgYWxzbyBkZXNpZ25lZCB0byBkbyBvbmUgdGhpbmcgd2VsbCwgYW5kIHRoYXQmIzM5O3MgPGVtPmJlaW5nIGEgc2hhcmVkLXJlbmRlcmluZyBNVkMgZW5naW5lPC9lbT4uPC9wPlxcbjxwPlRhdW51cyBjYW4gYmUgdXNlZCBmb3Igcm91dGluZywgcHV0dGluZyB0b2dldGhlciBjb250cm9sbGVycywgbW9kZWxzIGFuZCB2aWV3cyB0byBoYW5kbGUgaHVtYW4gaW50ZXJhY3Rpb24uIElmIHlvdSA8YSBocmVmPVxcXCIvYXBpXFxcIj5oZWFkIG92ZXIgdG8gdGhlIEFQSSBkb2N1bWVudGF0aW9uPC9hPiwgeW91JiMzOTtsbCBub3RpY2UgdGhhdCB0aGUgc2VydmVyLXNpZGUgQVBJLCB0aGUgY29tbWFuZC1saW5lIGludGVyZmFjZSwgYW5kIHRoZSA8Y29kZT4udGF1bnVzcmM8L2NvZGU+IG1hbmlmZXN0IGFyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIHByb3ZpZGluZyBhIGNvbnZlbnRpb25hbCBzaGFyZWQtcmVuZGVyaW5nIE1WQyBlbmdpbmUuPC9wPlxcbjxwPkluIHRoZSBzZXJ2ZXItc2lkZSB5b3UgbWlnaHQgbmVlZCB0byBkbyBvdGhlciB0aGluZ3MgYmVzaWRlcyByb3V0aW5nIGFuZCByZW5kZXJpbmcgdmlld3MsIGFuZCBvdGhlciBtb2R1bGVzIGNhbiB0YWtlIGNhcmUgb2YgdGhhdC4gSG93ZXZlciwgeW91JiMzOTtyZSB1c2VkIHRvIGhhdmluZyBkYXRhYmFzZSBhY2Nlc3MsIHNlYXJjaCwgbG9nZ2luZywgYW5kIGEgdmFyaWV0eSBvZiBzZXJ2aWNlcyBoYW5kbGVkIGJ5IHNlcGFyYXRlIGxpYnJhcmllcywgaW5zdGVhZCBvZiBhIHNpbmdsZSBiZWhlbW90aCB0aGF0IHRyaWVzIHRvIGRvIGV2ZXJ5dGhpbmcuPC9wPlxcbjxibG9ja3F1b3RlPlxcbjxwPkluIHRoZSBjbGllbnQtc2lkZSwgeW91IG1pZ2h0IGJlIHVzZWQgdG8geW91ciBNVkMgZnJhbWV3b3JrIG9mIGNob2ljZSByZXNvbHZpbmcgZXZlcnl0aGluZyBvbiB5b3VyIGJlaGFsZiwgZnJvbSBET00gbWFuaXB1bGF0aW9uIGFuZCBkYXRhLWJpbmRpbmcgdG8gaG9va2luZyB1cCB3aXRoIGEgUkVTVCBBUEksIGFuZCBldmVyeXdoZXJlIGluIGJldHdlZW4uPC9wPlxcbjwvYmxvY2txdW90ZT5cXG48cD5UYXVudXMgYXR0ZW1wdHMgdG8gYnJpbmcgdGhlIHNlcnZlci1zaWRlIG1lbnRhbGl0eSBvZiA8ZW0+JnF1b3Q7bm90IGRvaW5nIGV2ZXJ5dGhpbmcgaXMgb2theSZxdW90OzwvZW0+IGludG8gdGhlIHdvcmxkIG9mIGNsaWVudC1zaWRlIHdlYiBhcHBsaWNhdGlvbiBkZXZlbG9wbWVudCBhcyB3ZWxsLiBUbyB0aGF0IGVuZCwgVGF1bnVzIHJlY29tbWVuZHMgdGhhdCB5b3UgZ2l2ZSBhIHNob3QgdG8gbGlicmFyaWVzIHRoYXQgYWxzbyBkbyA8c3Ryb25nPm9uZSB0aGluZyB3ZWxsPC9zdHJvbmc+LjwvcD5cXG48cD5JbiB0aGlzIGJyaWVmIGFydGljbGUgd2UmIzM5O2xsIHJlY29tbWVuZCBhIGNvdXBsZSBkaWZmZXJlbnQgbGlicmFyaWVzIHRoYXQgcGxheSB3ZWxsIHdpdGggVGF1bnVzLCBhbmQgeW91JiMzOTtsbCBhbHNvIGxlYXJuIGhvdyB0byBzZWFyY2ggZm9yIG1vZHVsZXMgdGhhdCBjYW4gZ2l2ZSB5b3UgYWNjZXNzIHRvIG90aGVyIGZ1bmN0aW9uYWxpdHkgeW91IG1heSBiZSBpbnRlcmVzdGVkIGluLjwvcD5cXG48aDEgaWQ9XFxcInVzaW5nLWRvbWludXMtZm9yLWRvbS1xdWVyeWluZ1xcXCI+VXNpbmcgPGNvZGU+ZG9taW51czwvY29kZT4gZm9yIERPTSBxdWVyeWluZzwvaDE+XFxuPHA+PGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RvbWludXNcXFwiPkRvbWludXM8L2E+IGlzIGFuIGV4dHJhLXNtYWxsIERPTSBxdWVyeWluZyBsaWJyYXJ5LCBjdXJyZW50bHkgY2xvY2tpbmcgYXJvdW5kIDxzdHJvbmc+NGtCIG1pbmlmaWVkIGFuZCBnemlwcGVkPC9zdHJvbmc+LCBhbG1vc3QgPGVtPnRlbiB0aW1lcyBzbWFsbGVyPC9lbT4gdGhhbiBpdCYjMzk7cyBjb21wZXRpdGlvbi4gVW5saWtlIGpRdWVyeSBhbmQgcG9wdWxhciBmcmllbmRzLCBEb21pbnVzIGRvZXNuJiMzOTt0IHByb3ZpZGUgQUpBWCBmZWF0dXJlcywgbGF5b3V0IG1hdGgsIDxjb2RlPiZsdDtmb3JtJmd0OzwvY29kZT4gbWFuaXB1bGF0aW9uLCBwcm9taXNlcywgdGVucyBvZiBldmVudCBiaW5kaW5nIG1ldGhvZHMsIGEgc2VsZWN0b3IgZW5naW5lIHdyaXR0ZW4gaW4gcGxhaW4gSmF2YVNjcmlwdCwgbm9yIGEgbXlyaWFkIG9mIHV0aWxpdHkgZnVuY3Rpb25zLiBJbnN0ZWFkLCBEb21pbnVzIGZvY3VzZXMgc29sZWx5IG9uIHByb3ZpZGluZyBhIHJpY2ggRE9NIHF1ZXJ5aW5nIGFuZCBtYW5pcHVsYXRpb24gQVBJIHRoYXQgZ2V0cyByaWQgb2YgaW5jb25zaXN0ZW5jaWVzIGFjcm9zcyBicm93c2Vycy48L3A+XFxuPHA+V2hpbGUgdGhlIEFQSSBpc24mIzM5O3QgZXhhY3RseSBjb21wYXRpYmxlIHdpdGggalF1ZXJ5LCBpdCBpcyBkZWZpbml0ZWx5IGZhbWlsaWFyIHRvIHRoZSBqUXVlcnkgYWRlcHQuIENoYWluaW5nLCB2ZXJzYXRpbGl0eSwgZXhwcmVzc2l2ZW5lc3MsIGFuZCByYXcgcG93ZXIgYXJlIGFsbCBjb3JlIGNvbmNlcm5zIGZvciBEb21pbnVzLiBZb3UmIzM5O2xsIGZpbmQgdGhhdCBEb21pbnVzIGhhcyBtb3JlIGNvbnNpc3RlbnRseSBuYW1lZCBtZXRob2RzLCBnaXZlbiB0aGF0IGl0IHdhcyBidWlsdCB3aXRoIGEgY29uY2lzZSBBUEkgaW4gbWluZC48L3A+XFxuPHA+VGhlcmUmIzM5O3MgYSBmZXcgZGlmZmVyZW5jZXMgaW4gc2VtYW50aWNzLCBhbmQgSSBiZWxpZXZlIHRoYXQmIzM5O3MgYSBnb29kIHRoaW5nLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBkbyA8Y29kZT4udmFsdWU8L2NvZGU+IG9uIGEgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uIHlvdSYjMzk7bGwgZ2V0IGJhY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgY2hlY2tlZC4gU2ltaWxhcmx5LCBpZiB5b3UgY2FsbCA8Y29kZT4udGV4dDwvY29kZT4gb24gdGhlIGlucHV0IHlvdSYjMzk7bGwgZ2V0IHRoZSB0ZXh0IGJhY2ssIHdoaWNoIGlzIG1vc3Qgb2Z0ZW4gd2hhdCB5b3Ugd2FudGVkIHRvIGdldC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+dmFyIGEgPSByZXF1aXJlKCYjMzk7ZG9taW51cyYjMzk7KTtcXG52YXIgYiA9IGpRdWVyeTtcXG5cXG5hKCYjMzk7Jmx0O2lucHV0Jmd0OyYjMzk7KS5hdHRyKHsgdHlwZTogJiMzOTtyYWRpbyYjMzk7LCB2YWx1ZTogJiMzOTtGb28mIzM5OyB9KS50ZXh0KCk7XFxuLy8gJmx0Oy0gJiMzOTtGb28mIzM5O1xcblxcbmEoJiMzOTsmbHQ7aW5wdXQmZ3Q7JiMzOTspLmF0dHIoeyB0eXBlOiAmIzM5O3JhZGlvJiMzOTssIGNoZWNrZWQ6IHRydWUgfSkudmFsdWUoKTtcXG4vLyAmbHQ7LSB0cnVlXFxuXFxuYigmIzM5OyZsdDtpbnB1dCZndDsmIzM5OykuYXR0cih7IHR5cGU6ICYjMzk7cmFkaW8mIzM5OywgdmFsdWU6ICYjMzk7Rm9vJiMzOTsgfSkudGV4dCgpO1xcbi8vICZsdDstICYjMzk7JiMzOTtcXG5cXG5iKCYjMzk7Jmx0O2lucHV0Jmd0OyYjMzk7KS5hdHRyKHsgdHlwZTogJiMzOTtyYWRpbyYjMzk7LCBjaGVja2VkOiB0cnVlIH0pLnZhbCgpO1xcbi8vICZsdDstICYjMzk7Rm9vJiMzOTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+T25lIG9mIHRoZSBiZXN0IGFzcGVjdHMgb2YgRG9taW51cywgPGVtPmJlc2lkZXMgaXRzIHNtYWxsIHNpemU8L2VtPiwgaXMgdGhlIGZhY3QgdGhhdCBpdCBleHRlbmRzIG5hdGl2ZSBKYXZhU2NyaXB0IGFycmF5cyA8ZW0+KHVzaW5nIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9wb3NlclxcXCI+PGNvZGU+cG9zZXI8L2NvZGU+PC9hPik8L2VtPi4gVGhhdCBtZWFucyB5b3UgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSA8Y29kZT5BcnJheTwvY29kZT4gZnVuY3Rpb25hbCBtZXRob2RzIG9uIGFueSA8Y29kZT5Eb21pbnVzPC9jb2RlPiBjb2xsZWN0aW9ucywgc3VjaCBhcyA8Y29kZT4uZm9yRWFjaDwvY29kZT4sIDxjb2RlPi5tYXA8L2NvZGU+LCA8Y29kZT4uZmlsdGVyPC9jb2RlPiwgPGNvZGU+LnNvcnQ8L2NvZGU+IGFuZCBzbyBvbi48L3A+XFxuPHA+VGF1bnVzIGRvZXNuJiMzOTt0IG1ha2UgYW55IGV4dGVuc2l2ZSBET00gbWFuaXB1bGF0aW9uIDxlbT4obm9yIHF1ZXJ5aW5nKTwvZW0+IGFuZCBkb2VzbiYjMzk7dCBuZWVkIHRvIHVzZSBEb21pbnVzLCBidXQgaXQgbWF5IGZpbmQgYSBob21lIGluIHlvdXIgYXBwbGljYXRpb24uPC9wPlxcbjxwPllvdSBjYW4gY2hlY2sgb3V0IHRoZSA8ZW0+Y29tcGxldGUgQVBJIGRvY3VtZW50YXRpb248L2VtPiBmb3IgPGNvZGU+ZG9taW51czwvY29kZT4gb24gPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RvbWludXNcXFwiPml0cyBHaXRIdWIgcmVwb3NpdG9yeTwvYT4uPC9wPlxcbjxoMSBpZD1cXFwidXNpbmcteGhyLXRvLW1ha2UtYWpheC1yZXF1ZXN0c1xcXCI+VXNpbmcgPGNvZGU+eGhyPC9jb2RlPiB0byBtYWtlIEFKQVggcmVxdWVzdHM8L2gxPlxcbjxwPkEgc21hbGwgcHJvZ3JhbSBjYWxsZWQgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHJcXFwiPjxjb2RlPnhocjwvY29kZT48L2E+IGNhbiBiZSB1c2VkIHRvIG1ha2UgQUpBWCByZXF1ZXN0cyBhbmQgaXQmIzM5O3MgYnVuZGxlZCB3aXRoIFRhdW51cywgYmVjYXVzZSBpdCBuZWVkcyBpdCBpbnRlcm5hbGx5IHRvIGNvbW11bmljYXRlIHdpdGggdGhlIHNlcnZlci4gQXMgc3VjaCwgaXQgd2FzIHRyaXZpYWwgZm9yIFRhdW51cyB0byBleHBvc2UgdGhpcyBlbmdpbmUgYW5kIGdpdmUgeW91IHRoZSBhYmlsaXR5IHRvIG1ha2UgQUpBWCBjYWxscyBvZiB5b3VyIG93biB1c2luZyBpdCBhcyB3ZWxsLjwvcD5cXG48cD5Zb3UgY2FuIGNoZWNrIG91dCA8YSBocmVmPVxcXCIvYXBpIy10YXVudXMteGhyLXVybC1vcHRpb25zLWRvbmUtXFxcIj50aGUgQVBJIGRvY3VtZW50YXRpb248L2E+IGZvciBhbiBleHBsYW5hdGlvbiBvZiBob3cgb3VyIGludGVyZmFjZSB0byA8Y29kZT54aHI8L2NvZGU+IHdvcmtzLCBvciB5b3UgY291bGQgYWxzbyA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vUmF5bm9zL3hoclxcXCI+c2VlIHRoZWlyIEFQSSBkb2N1bWVudGF0aW9uPC9hPiBhbmQgdXNlIHRoYXQgZGlyZWN0bHkgaW5zdGVhZC48L3A+XFxuPGgxIGlkPVxcXCJjb21wbGVtZW50aW5nLXlvdXItY29kZS13aXRoLXNtYWxsLW1vZHVsZXNcXFwiPkNvbXBsZW1lbnRpbmcgeW91ciBjb2RlIHdpdGggc21hbGwgbW9kdWxlczwvaDE+XFxuPHA+VGhlcmUmIzM5O3MgYW4gaW5maW5pdGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBkbyBqdXN0IG9uZSB0aGluZyB3ZWxsIGFuZCBhcmUgZWFnZXIgdG8gYmUgcGFydCBvZiB5b3VyIGFwcGxpY2F0aW9ucy4gTGV2ZXJhZ2UgdGhlIEludGVybmV0IHRvIGZpbmQgd2hhdCB5b3UgbmVlZC4gU21hbGwgbGlicmFyaWVzIHRlbmQgdG8gYmUgYmV0dGVyIGRvY3VtZW50ZWQsIGNvbmNpc2UgdG8gdXNlLCBhbmQgc2ltcGxlci48L3A+XFxuPHA+SGVyZSYjMzk7cyBhIGZldyBleGFtcGxlcyBvZiBtb2R1bGVzIHlvdSBjb3VsZCBjb25zaWRlci48L3A+XFxuPHVsPlxcbjxsaT48YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20veXl4OTkwODAzL3Z1ZVxcXCI+PGNvZGU+dnVlPC9jb2RlPjwvYT4gZ2l2ZXMgeW91IE1WVk0gY2FwYWJpbGl0aWVzPC9saT5cXG48bGk+PGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL3BvbHltZXIvb2JzZXJ2ZS1qc1xcXCI+PGNvZGU+b2JzZXJ2ZS1qczwvY29kZT48L2E+IHRvIGdldCBkYXRhLWJpbmRpbmc8L2xpPlxcbjxsaT48YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vTWF0dC1Fc2NoL3ZpcnR1YWwtZG9tXFxcIj48Y29kZT52aXJ0dWFsLWRvbTwvY29kZT48L2E+IHRvIHVzZSBhIHZpcnR1YWwgRE9NIGRpZmZpbmcgYWxnb3JpdGhtIGEgbGEgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0XFxcIj5GYWNlYm9vayBSZWFjdDwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvaGludFxcXCI+PGNvZGU+aGludDwvY29kZT48L2E+IHByb2dyZXNzaXZlbHkgZW5oYW5jZXMgeW91ciBIVE1MIGdpdmluZyB5b3UgbW9yZSBjb2xvcmZ1bCB0b29sdGlwczwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9yb21lXFxcIj48Y29kZT5yb21lPC9jb2RlPjwvYT4gaXMgYSBzbWFsbCBjYWxlbmRhciBjb21wb25lbnQ8L2xpPlxcbjwvdWw+XFxuPHA+WW91IGNhbiBsb29rIGZvciByZWxldmFudCBtb2R1bGVzIHVzaW5nIDxhIGhyZWY9XFxcImh0dHA6Ly9icm93c2VyaWZ5c2VhcmNoLm9yZy9cXFwiPkJyb3dzZXJpZnlTZWFyY2gub3JnPC9hPiwgdGhlIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9cXFwiPjxjb2RlPm5wbTwvY29kZT4gc2VhcmNoPC9hPiwgYXNraW5nIGFyb3VuZCBvbiBUd2l0dGVyLCBvciBqdXN0IGJ5IEdvb2dsaW5nITwvcD5cXG5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2VjdGlvbj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7fS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnVuZGVmaW5lZDp0eXBlb2YgdW5kZWZpbmVkIT09XCJ1bmRlZmluZWRcIj91bmRlZmluZWQ6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn0gY2F0Y2ggKGVycikge1xuICBqYWRlLnJldGhyb3coZXJyLCBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lLCBqYWRlX2RlYnVnWzBdLmxpbmVubywgXCJzZWN0aW9uLmx5LXNlY3Rpb24ubWQtbWFya2Rvd25cXG4gIDptYXJrZG93blxcbiAgICAjIENvbXBsZW1lbnRhcnkgTW9kdWxlc1xcblxcbiAgICBUYXVudXMgaXMgYSBzbWFsbCBsaWJyYXJ5IGJ5IE1WQyBmcmFtZXdvcmsgc3RhbmRhcmRzLCBzaXR0aW5nICoqYmVsb3cgMTVrQiBtaW5pZmllZCBhbmQgZ3ppcHBlZCoqLiBJdCBpcyBkZXNpZ25lZCB0byBiZSBzbWFsbC4gSXQgaXMgYWxzbyBkZXNpZ25lZCB0byBkbyBvbmUgdGhpbmcgd2VsbCwgYW5kIHRoYXQncyBfYmVpbmcgYSBzaGFyZWQtcmVuZGVyaW5nIE1WQyBlbmdpbmVfLlxcblxcbiAgICBUYXVudXMgY2FuIGJlIHVzZWQgZm9yIHJvdXRpbmcsIHB1dHRpbmcgdG9nZXRoZXIgY29udHJvbGxlcnMsIG1vZGVscyBhbmQgdmlld3MgdG8gaGFuZGxlIGh1bWFuIGludGVyYWN0aW9uLiBJZiB5b3UgW2hlYWQgb3ZlciB0byB0aGUgQVBJIGRvY3VtZW50YXRpb25dWzFdLCB5b3UnbGwgbm90aWNlIHRoYXQgdGhlIHNlcnZlci1zaWRlIEFQSSwgdGhlIGNvbW1hbmQtbGluZSBpbnRlcmZhY2UsIGFuZCB0aGUgYC50YXVudXNyY2AgbWFuaWZlc3QgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggcHJvdmlkaW5nIGEgY29udmVudGlvbmFsIHNoYXJlZC1yZW5kZXJpbmcgTVZDIGVuZ2luZS5cXG5cXG4gICAgSW4gdGhlIHNlcnZlci1zaWRlIHlvdSBtaWdodCBuZWVkIHRvIGRvIG90aGVyIHRoaW5ncyBiZXNpZGVzIHJvdXRpbmcgYW5kIHJlbmRlcmluZyB2aWV3cywgYW5kIG90aGVyIG1vZHVsZXMgY2FuIHRha2UgY2FyZSBvZiB0aGF0LiBIb3dldmVyLCB5b3UncmUgdXNlZCB0byBoYXZpbmcgZGF0YWJhc2UgYWNjZXNzLCBzZWFyY2gsIGxvZ2dpbmcsIGFuZCBhIHZhcmlldHkgb2Ygc2VydmljZXMgaGFuZGxlZCBieSBzZXBhcmF0ZSBsaWJyYXJpZXMsIGluc3RlYWQgb2YgYSBzaW5nbGUgYmVoZW1vdGggdGhhdCB0cmllcyB0byBkbyBldmVyeXRoaW5nLlxcblxcbiAgICA+IEluIHRoZSBjbGllbnQtc2lkZSwgeW91IG1pZ2h0IGJlIHVzZWQgdG8geW91ciBNVkMgZnJhbWV3b3JrIG9mIGNob2ljZSByZXNvbHZpbmcgZXZlcnl0aGluZyBvbiB5b3VyIGJlaGFsZiwgZnJvbSBET00gbWFuaXB1bGF0aW9uIGFuZCBkYXRhLWJpbmRpbmcgdG8gaG9va2luZyB1cCB3aXRoIGEgUkVTVCBBUEksIGFuZCBldmVyeXdoZXJlIGluIGJldHdlZW4uXFxuXFxuICAgIFRhdW51cyBhdHRlbXB0cyB0byBicmluZyB0aGUgc2VydmVyLXNpZGUgbWVudGFsaXR5IG9mIF9cXFwibm90IGRvaW5nIGV2ZXJ5dGhpbmcgaXMgb2theVxcXCJfIGludG8gdGhlIHdvcmxkIG9mIGNsaWVudC1zaWRlIHdlYiBhcHBsaWNhdGlvbiBkZXZlbG9wbWVudCBhcyB3ZWxsLiBUbyB0aGF0IGVuZCwgVGF1bnVzIHJlY29tbWVuZHMgdGhhdCB5b3UgZ2l2ZSBhIHNob3QgdG8gbGlicmFyaWVzIHRoYXQgYWxzbyBkbyAqKm9uZSB0aGluZyB3ZWxsKiouXFxuXFxuICAgIEluIHRoaXMgYnJpZWYgYXJ0aWNsZSB3ZSdsbCByZWNvbW1lbmQgYSBjb3VwbGUgZGlmZmVyZW50IGxpYnJhcmllcyB0aGF0IHBsYXkgd2VsbCB3aXRoIFRhdW51cywgYW5kIHlvdSdsbCBhbHNvIGxlYXJuIGhvdyB0byBzZWFyY2ggZm9yIG1vZHVsZXMgdGhhdCBjYW4gZ2l2ZSB5b3UgYWNjZXNzIHRvIG90aGVyIGZ1bmN0aW9uYWxpdHkgeW91IG1heSBiZSBpbnRlcmVzdGVkIGluLlxcblxcbiAgICAjIFVzaW5nIGBkb21pbnVzYCBmb3IgRE9NIHF1ZXJ5aW5nXFxuXFxuICAgIFtEb21pbnVzXVsyXSBpcyBhbiBleHRyYS1zbWFsbCBET00gcXVlcnlpbmcgbGlicmFyeSwgY3VycmVudGx5IGNsb2NraW5nIGFyb3VuZCAqKjRrQiBtaW5pZmllZCBhbmQgZ3ppcHBlZCoqLCBhbG1vc3QgX3RlbiB0aW1lcyBzbWFsbGVyXyB0aGFuIGl0J3MgY29tcGV0aXRpb24uIFVubGlrZSBqUXVlcnkgYW5kIHBvcHVsYXIgZnJpZW5kcywgRG9taW51cyBkb2Vzbid0IHByb3ZpZGUgQUpBWCBmZWF0dXJlcywgbGF5b3V0IG1hdGgsIGA8Zm9ybT5gIG1hbmlwdWxhdGlvbiwgcHJvbWlzZXMsIHRlbnMgb2YgZXZlbnQgYmluZGluZyBtZXRob2RzLCBhIHNlbGVjdG9yIGVuZ2luZSB3cml0dGVuIGluIHBsYWluIEphdmFTY3JpcHQsIG5vciBhIG15cmlhZCBvZiB1dGlsaXR5IGZ1bmN0aW9ucy4gSW5zdGVhZCwgRG9taW51cyBmb2N1c2VzIHNvbGVseSBvbiBwcm92aWRpbmcgYSByaWNoIERPTSBxdWVyeWluZyBhbmQgbWFuaXB1bGF0aW9uIEFQSSB0aGF0IGdldHMgcmlkIG9mIGluY29uc2lzdGVuY2llcyBhY3Jvc3MgYnJvd3NlcnMuXFxuXFxuICAgIFdoaWxlIHRoZSBBUEkgaXNuJ3QgZXhhY3RseSBjb21wYXRpYmxlIHdpdGggalF1ZXJ5LCBpdCBpcyBkZWZpbml0ZWx5IGZhbWlsaWFyIHRvIHRoZSBqUXVlcnkgYWRlcHQuIENoYWluaW5nLCB2ZXJzYXRpbGl0eSwgZXhwcmVzc2l2ZW5lc3MsIGFuZCByYXcgcG93ZXIgYXJlIGFsbCBjb3JlIGNvbmNlcm5zIGZvciBEb21pbnVzLiBZb3UnbGwgZmluZCB0aGF0IERvbWludXMgaGFzIG1vcmUgY29uc2lzdGVudGx5IG5hbWVkIG1ldGhvZHMsIGdpdmVuIHRoYXQgaXQgd2FzIGJ1aWx0IHdpdGggYSBjb25jaXNlIEFQSSBpbiBtaW5kLlxcblxcbiAgICBUaGVyZSdzIGEgZmV3IGRpZmZlcmVuY2VzIGluIHNlbWFudGljcywgYW5kIEkgYmVsaWV2ZSB0aGF0J3MgYSBnb29kIHRoaW5nLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBkbyBgLnZhbHVlYCBvbiBhIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbiB5b3UnbGwgZ2V0IGJhY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgY2hlY2tlZC4gU2ltaWxhcmx5LCBpZiB5b3UgY2FsbCBgLnRleHRgIG9uIHRoZSBpbnB1dCB5b3UnbGwgZ2V0IHRoZSB0ZXh0IGJhY2ssIHdoaWNoIGlzIG1vc3Qgb2Z0ZW4gd2hhdCB5b3Ugd2FudGVkIHRvIGdldC5cXG5cXG4gICAgYGBganNcXG4gICAgdmFyIGEgPSByZXF1aXJlKCdkb21pbnVzJyk7XFxuICAgIHZhciBiID0galF1ZXJ5O1xcblxcbiAgICBhKCc8aW5wdXQ+JykuYXR0cih7IHR5cGU6ICdyYWRpbycsIHZhbHVlOiAnRm9vJyB9KS50ZXh0KCk7XFxuICAgIC8vIDwtICdGb28nXFxuXFxuICAgIGEoJzxpbnB1dD4nKS5hdHRyKHsgdHlwZTogJ3JhZGlvJywgY2hlY2tlZDogdHJ1ZSB9KS52YWx1ZSgpO1xcbiAgICAvLyA8LSB0cnVlXFxuXFxuICAgIGIoJzxpbnB1dD4nKS5hdHRyKHsgdHlwZTogJ3JhZGlvJywgdmFsdWU6ICdGb28nIH0pLnRleHQoKTtcXG4gICAgLy8gPC0gJydcXG5cXG4gICAgYignPGlucHV0PicpLmF0dHIoeyB0eXBlOiAncmFkaW8nLCBjaGVja2VkOiB0cnVlIH0pLnZhbCgpO1xcbiAgICAvLyA8LSAnRm9vJ1xcbiAgICBgYGBcXG5cXG4gICAgT25lIG9mIHRoZSBiZXN0IGFzcGVjdHMgb2YgRG9taW51cywgX2Jlc2lkZXMgaXRzIHNtYWxsIHNpemVfLCBpcyB0aGUgZmFjdCB0aGF0IGl0IGV4dGVuZHMgbmF0aXZlIEphdmFTY3JpcHQgYXJyYXlzIF8odXNpbmcgW2Bwb3NlcmBdWzVdKV8uIFRoYXQgbWVhbnMgeW91IGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYEFycmF5YCBmdW5jdGlvbmFsIG1ldGhvZHMgb24gYW55IGBEb21pbnVzYCBjb2xsZWN0aW9ucywgc3VjaCBhcyBgLmZvckVhY2hgLCBgLm1hcGAsIGAuZmlsdGVyYCwgYC5zb3J0YCBhbmQgc28gb24uXFxuXFxuICAgIFRhdW51cyBkb2Vzbid0IG1ha2UgYW55IGV4dGVuc2l2ZSBET00gbWFuaXB1bGF0aW9uIF8obm9yIHF1ZXJ5aW5nKV8gYW5kIGRvZXNuJ3QgbmVlZCB0byB1c2UgRG9taW51cywgYnV0IGl0IG1heSBmaW5kIGEgaG9tZSBpbiB5b3VyIGFwcGxpY2F0aW9uLlxcblxcbiAgICBZb3UgY2FuIGNoZWNrIG91dCB0aGUgX2NvbXBsZXRlIEFQSSBkb2N1bWVudGF0aW9uXyBmb3IgYGRvbWludXNgIG9uIFtpdHMgR2l0SHViIHJlcG9zaXRvcnldWzJdLlxcblxcbiAgICAjIFVzaW5nIGB4aHJgIHRvIG1ha2UgQUpBWCByZXF1ZXN0c1xcblxcbiAgICBBIHNtYWxsIHByb2dyYW0gY2FsbGVkIFtgeGhyYF1bNF0gY2FuIGJlIHVzZWQgdG8gbWFrZSBBSkFYIHJlcXVlc3RzIGFuZCBpdCdzIGJ1bmRsZWQgd2l0aCBUYXVudXMsIGJlY2F1c2UgaXQgbmVlZHMgaXQgaW50ZXJuYWxseSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBzZXJ2ZXIuIEFzIHN1Y2gsIGl0IHdhcyB0cml2aWFsIGZvciBUYXVudXMgdG8gZXhwb3NlIHRoaXMgZW5naW5lIGFuZCBnaXZlIHlvdSB0aGUgYWJpbGl0eSB0byBtYWtlIEFKQVggY2FsbHMgb2YgeW91ciBvd24gdXNpbmcgaXQgYXMgd2VsbC5cXG5cXG4gICAgWW91IGNhbiBjaGVjayBvdXQgW3RoZSBBUEkgZG9jdW1lbnRhdGlvbl1bNl0gZm9yIGFuIGV4cGxhbmF0aW9uIG9mIGhvdyBvdXIgaW50ZXJmYWNlIHRvIGB4aHJgIHdvcmtzLCBvciB5b3UgY291bGQgYWxzbyBbc2VlIHRoZWlyIEFQSSBkb2N1bWVudGF0aW9uXVs0XSBhbmQgdXNlIHRoYXQgZGlyZWN0bHkgaW5zdGVhZC5cXG5cXG4gICAgIyBDb21wbGVtZW50aW5nIHlvdXIgY29kZSB3aXRoIHNtYWxsIG1vZHVsZXNcXG5cXG4gICAgVGhlcmUncyBhbiBpbmZpbml0ZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IGRvIGp1c3Qgb25lIHRoaW5nIHdlbGwgYW5kIGFyZSBlYWdlciB0byBiZSBwYXJ0IG9mIHlvdXIgYXBwbGljYXRpb25zLiBMZXZlcmFnZSB0aGUgSW50ZXJuZXQgdG8gZmluZCB3aGF0IHlvdSBuZWVkLiBTbWFsbCBsaWJyYXJpZXMgdGVuZCB0byBiZSBiZXR0ZXIgZG9jdW1lbnRlZCwgY29uY2lzZSB0byB1c2UsIGFuZCBzaW1wbGVyLlxcblxcbiAgICBIZXJlJ3MgYSBmZXcgZXhhbXBsZXMgb2YgbW9kdWxlcyB5b3UgY291bGQgY29uc2lkZXIuXFxuXFxuICAgIC0gW2B2dWVgXVsxNV0gZ2l2ZXMgeW91IE1WVk0gY2FwYWJpbGl0aWVzXFxuICAgIC0gW2BvYnNlcnZlLWpzYF1bN10gdG8gZ2V0IGRhdGEtYmluZGluZ1xcbiAgICAtIFtgdmlydHVhbC1kb21gXVs4XSB0byB1c2UgYSB2aXJ0dWFsIERPTSBkaWZmaW5nIGFsZ29yaXRobSBhIGxhIFtGYWNlYm9vayBSZWFjdF1bOV1cXG4gICAgLSBbYGhpbnRgXVsxMF0gcHJvZ3Jlc3NpdmVseSBlbmhhbmNlcyB5b3VyIEhUTUwgZ2l2aW5nIHlvdSBtb3JlIGNvbG9yZnVsIHRvb2x0aXBzXFxuICAgIC0gW2Byb21lYF1bMTFdIGlzIGEgc21hbGwgY2FsZW5kYXIgY29tcG9uZW50XFxuXFxuICAgIFlvdSBjYW4gbG9vayBmb3IgcmVsZXZhbnQgbW9kdWxlcyB1c2luZyBbQnJvd3NlcmlmeVNlYXJjaC5vcmddWzEzXSwgdGhlIFtgbnBtYCBzZWFyY2hdWzE0XSwgYXNraW5nIGFyb3VuZCBvbiBUd2l0dGVyLCBvciBqdXN0IGJ5IEdvb2dsaW5nIVxcblxcbiAgICBbMV06IC9hcGlcXG4gICAgWzJdOiBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZG9taW51c1xcbiAgICBbNF06IGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXFxuICAgIFs1XTogaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL3Bvc2VyXFxuICAgIFs2XTogL2FwaSMtdGF1bnVzLXhoci11cmwtb3B0aW9ucy1kb25lLVxcbiAgICBbN106IGh0dHBzOi8vZ2l0aHViLmNvbS9wb2x5bWVyL29ic2VydmUtanNcXG4gICAgWzhdOiBodHRwczovL2dpdGh1Yi5jb20vTWF0dC1Fc2NoL3ZpcnR1YWwtZG9tXFxuICAgIFs5XTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0XFxuICAgIFsxMF06IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9oaW50XFxuICAgIFsxMV06IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9yb21lXFxuICAgIFsxMl06IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9oaW50XFxuICAgIFsxM106IGh0dHA6Ly9icm93c2VyaWZ5c2VhcmNoLm9yZy9cXG4gICAgWzE0XTogaHR0cHM6Ly93d3cubnBtanMub3JnL1xcbiAgICBbMTVdOiBodHRwczovL2dpdGh1Yi5jb20veXl4OTkwODAzL3Z1ZVxcblwiKTtcbn1cbn0iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJqYWR1bS9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXR0aW5nU3RhcnRlZChsb2NhbHMpIHtcbnZhciBqYWRlX2RlYnVnID0gW3sgbGluZW5vOiAxLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2dldHRpbmctc3RhcnRlZC5qYWRlXCIgfV07XG50cnkge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vZ2V0dGluZy1zdGFydGVkLmphZGVcIiB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMSwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8c2VjdGlvbiBjbGFzcz1cXFwibHktc2VjdGlvbiBtZC1tYXJrZG93blxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL2dldHRpbmctc3RhcnRlZC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMSBpZD1cXFwiZ2V0dGluZy1zdGFydGVkXFxcIj5HZXR0aW5nIFN0YXJ0ZWQ8L2gxPlxcbjxwPlRhdW51cyBpcyBhIHNoYXJlZC1yZW5kZXJpbmcgTVZDIGVuZ2luZSBmb3IgTm9kZS5qcywgYW5kIGl0JiMzOTtzIDxlbT51cCB0byB5b3UgaG93IHRvIHVzZSBpdDwvZW0+LiBJbiBmYWN0LCBpdCBtaWdodCBiZSBhIGdvb2QgaWRlYSBmb3IgeW91IHRvIDxzdHJvbmc+c2V0IHVwIGp1c3QgdGhlIHNlcnZlci1zaWRlIGFzcGVjdCBmaXJzdDwvc3Ryb25nPiwgYXMgdGhhdCYjMzk7bGwgdGVhY2ggeW91IGhvdyBpdCB3b3JrcyBldmVuIHdoZW4gSmF2YVNjcmlwdCBuZXZlciBnZXRzIHRvIHRoZSBjbGllbnQuPC9wPlxcbjxoMSBpZD1cXFwidGFibGUtb2YtY29udGVudHNcXFwiPlRhYmxlIG9mIENvbnRlbnRzPC9oMT5cXG48dWw+XFxuPGxpPjxhIGhyZWY9XFxcIiNob3ctaXQtd29ya3NcXFwiPkhvdyBpdCB3b3JrczwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjaW5zdGFsbGluZy10YXVudXNcXFwiPkluc3RhbGxpbmcgVGF1bnVzPC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiNzZXR0aW5nLXVwLXRoZS1zZXJ2ZXItc2lkZVxcXCI+U2V0dGluZyB1cCB0aGUgc2VydmVyLXNpZGU8L2E+PHVsPlxcbjxsaT48YSBocmVmPVxcXCIjeW91ci1maXJzdC1yb3V0ZVxcXCI+WW91ciBmaXJzdCByb3V0ZTwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjY3JlYXRpbmctYS1sYXlvdXRcXFwiPkNyZWF0aW5nIGEgbGF5b3V0PC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiN1c2luZy1qYWRlLWFzLXlvdXItdmlldy1lbmdpbmVcXFwiPlVzaW5nIEphZGUgYXMgeW91ciB2aWV3IGVuZ2luZTwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjdGhyb3dpbmctaW4tYS1jb250cm9sbGVyXFxcIj5UaHJvd2luZyBpbiBhIGNvbnRyb2xsZXI8L2E+PC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiN0YXVudXMtaW4tdGhlLWNsaWVudFxcXCI+VGF1bnVzIGluIHRoZSBjbGllbnQ8L2E+PHVsPlxcbjxsaT48YSBocmVmPVxcXCIjdXNpbmctdGhlLXRhdW51cy1jbGlcXFwiPlVzaW5nIHRoZSBUYXVudXMgQ0xJPC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiNib290aW5nLXVwLXRoZS1jbGllbnQtc2lkZS1yb3V0ZXJcXFwiPkJvb3RpbmcgdXAgdGhlIGNsaWVudC1zaWRlIHJvdXRlcjwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjYWRkaW5nLWZ1bmN0aW9uYWxpdHktaW4tYS1jbGllbnQtc2lkZS1jb250cm9sbGVyXFxcIj5BZGRpbmcgZnVuY3Rpb25hbGl0eSBpbiBhIGNsaWVudC1zaWRlIGNvbnRyb2xsZXI8L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI2NvbXBpbGluZy15b3VyLWNsaWVudC1zaWRlLWphdmFzY3JpcHRcXFwiPkNvbXBpbGluZyB5b3VyIGNsaWVudC1zaWRlIEphdmFTY3JpcHQ8L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI3VzaW5nLXRoZS1jbGllbnQtc2lkZS10YXVudXMtYXBpXFxcIj5Vc2luZyB0aGUgY2xpZW50LXNpZGUgVGF1bnVzIEFQSTwvYT48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjY2FjaGluZy1hbmQtcHJlZmV0Y2hpbmdcXFwiPkNhY2hpbmcgYW5kIFByZWZldGNoaW5nPC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcIiN2ZXJzaW9uaW5nXFxcIj5WZXJzaW9uaW5nPC9hPjwvbGk+XFxuPC91bD5cXG48L2xpPlxcbjxsaT48YSBocmVmPVxcXCIjdGhlLXNreS1pcy10aGUtbGltaXQtXFxcIj5UaGUgc2t5IGlzIHRoZSBsaW1pdCE8L2E+PC9saT5cXG48L3VsPlxcbjxoMSBpZD1cXFwiaG93LWl0LXdvcmtzXFxcIj5Ib3cgaXQgd29ya3M8L2gxPlxcbjxwPlRhdW51cyBmb2xsb3dzIGEgc2ltcGxlIGJ1dCA8c3Ryb25nPnByb3Zlbjwvc3Ryb25nPiBzZXQgb2YgcnVsZXMuPC9wPlxcbjx1bD5cXG48bGk+RGVmaW5lIGEgPGNvZGU+ZnVuY3Rpb24obW9kZWwpPC9jb2RlPiBmb3IgZWFjaCB5b3VyIHZpZXdzPC9saT5cXG48bGk+UHV0IHRoZXNlIHZpZXdzIGluIGJvdGggdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudDwvbGk+XFxuPGxpPkRlZmluZSByb3V0ZXMgZm9yIHlvdXIgYXBwbGljYXRpb248L2xpPlxcbjxsaT5QdXQgdGhvc2Ugcm91dGVzIGluIGJvdGggdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudDwvbGk+XFxuPGxpPkVuc3VyZSByb3V0ZSBtYXRjaGVzIHdvcmsgdGhlIHNhbWUgd2F5IG9uIGJvdGggZW5kczwvbGk+XFxuPGxpPkNyZWF0ZSBzZXJ2ZXItc2lkZSBjb250cm9sbGVycyB0aGF0IHlpZWxkIHRoZSBtb2RlbCBmb3IgeW91ciB2aWV3czwvbGk+XFxuPGxpPkNyZWF0ZSBjbGllbnQtc2lkZSBjb250cm9sbGVycyBpZiB5b3UgbmVlZCB0byBhZGQgY2xpZW50LXNpZGUgZnVuY3Rpb25hbGl0eSB0byBhIHBhcnRpY3VsYXIgdmlldzwvbGk+XFxuPGxpPkZvciB0aGUgZmlyc3QgcmVxdWVzdCwgYWx3YXlzIHJlbmRlciB2aWV3cyBvbiB0aGUgc2VydmVyLXNpZGU8L2xpPlxcbjxsaT5XaGVuIHJlbmRlcmluZyBhIHZpZXcgb24gdGhlIHNlcnZlci1zaWRlLCBpbmNsdWRlIHRoZSBmdWxsIGxheW91dCBhcyB3ZWxsITwvbGk+XFxuPGxpPk9uY2UgdGhlIGNsaWVudC1zaWRlIGNvZGUga2lja3MgaW4sIDxzdHJvbmc+aGlqYWNrIGxpbmsgY2xpY2tzPC9zdHJvbmc+IGFuZCBtYWtlIEFKQVggcmVxdWVzdHMgaW5zdGVhZDwvbGk+XFxuPGxpPldoZW4geW91IGdldCB0aGUgSlNPTiBtb2RlbCBiYWNrLCByZW5kZXIgdmlld3Mgb24gdGhlIGNsaWVudC1zaWRlPC9saT5cXG48bGk+SWYgdGhlIDxjb2RlPmhpc3Rvcnk8L2NvZGU+IEFQSSBpcyB1bmF2YWlsYWJsZSwgZmFsbCBiYWNrIHRvIGdvb2Qgb2xkIHJlcXVlc3QtcmVzcG9uc2UuIDxzdHJvbmc+RG9uJiMzOTt0IGNvbmZ1c2UgeW91ciBodW1hbnMgd2l0aCBvYnNjdXJlIGhhc2ggcm91dGVycyE8L3N0cm9uZz48L2xpPlxcbjwvdWw+XFxuPHA+SSYjMzk7bGwgc3RlcCB5b3UgdGhyb3VnaCB0aGVzZSwgYnV0IHJhdGhlciB0aGFuIGxvb2tpbmcgYXQgaW1wbGVtZW50YXRpb24gZGV0YWlscywgSSYjMzk7bGwgd2FsayB5b3UgdGhyb3VnaCB0aGUgc3RlcHMgeW91IG5lZWQgdG8gdGFrZSBpbiBvcmRlciB0byBtYWtlIHRoaXMgZmxvdyBoYXBwZW4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMSBpZD1cXFwiaW5zdGFsbGluZy10YXVudXNcXFwiPkluc3RhbGxpbmcgVGF1bnVzPC9oMT5cXG48cD5GaXJzdCBvZmYsIHlvdSYjMzk7bGwgbmVlZCB0byBjaG9vc2UgYSBIVFRQIHNlcnZlciBmcmFtZXdvcmsgZm9yIHlvdXIgYXBwbGljYXRpb24uIEF0IHRoZSBtb21lbnQgVGF1bnVzIHN1cHBvcnRzIG9ubHkgYSBjb3VwbGUgb2YgSFRUUCBmcmFtZXdvcmtzLCBidXQgbW9yZSBtYXkgYmUgYWRkZWQgaWYgdGhleSBhcmUgcG9wdWxhciBlbm91Z2guPC9wPlxcbjx1bD5cXG48bGk+PGEgaHJlZj1cXFwiaHR0cDovL2V4cHJlc3Nqcy5jb21cXFwiPkV4cHJlc3M8L2E+LCB0aHJvdWdoIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS90YXVudXMvdGF1bnVzLWV4cHJlc3NcXFwiPnRhdW51cy1leHByZXNzPC9hPjwvbGk+XFxuPGxpPjxhIGhyZWY9XFxcImh0dHA6Ly9oYXBpanMuY29tXFxcIj5IYXBpPC9hPiwgdGhyb3VnaCA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy1oYXBpXFxcIj50YXVudXMtaGFwaTwvYT4gYW5kIHRoZSA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL2hhcGlpZnlcXFwiPmhhcGlpZnk8L2E+IHRyYW5zZm9ybTwvbGk+XFxuPC91bD5cXG48YmxvY2txdW90ZT5cXG48cD5JZiB5b3UmIzM5O3JlIG1vcmUgb2YgYSA8ZW0+JnF1b3Q7cnVtbWFnZSB0aHJvdWdoIHNvbWVvbmUgZWxzZSYjMzk7cyBjb2RlJnF1b3Q7PC9lbT4gdHlwZSBvZiBkZXZlbG9wZXIsIHlvdSBtYXkgZmVlbCBjb21mb3J0YWJsZSA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy5iZXZhY3F1YS5pb1xcXCI+Z29pbmcgdGhyb3VnaCB0aGlzIHdlYnNpdGUmIzM5O3Mgc291cmNlIGNvZGU8L2E+LCB3aGljaCB1c2VzIHRoZSA8YSBocmVmPVxcXCJodHRwOi8vaGFwaWpzLmNvbVxcXCI+SGFwaTwvYT4gZmxhdm9yIG9mIFRhdW51cy4gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIGxvb2sgYXQgdGhlIHNvdXJjZSBjb2RlIGZvciA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vcG9ueWZvby9wb255Zm9vXFxcIj5wb255Zm9vLmNvbTwvYT4sIHdoaWNoIGlzIDxzdHJvbmc+YSBtb3JlIGFkdmFuY2VkIHVzZS1jYXNlPC9zdHJvbmc+IHVuZGVyIHRoZSA8YSBocmVmPVxcXCJodHRwOi8vZXhwcmVzc2pzLmNvbVxcXCI+RXhwcmVzczwvYT4gZmxhdm9yLiBPciwgeW91IGNvdWxkIGp1c3Qga2VlcCBvbiByZWFkaW5nIHRoaXMgcGFnZSwgdGhhdCYjMzk7cyBva2F5IHRvby48L3A+XFxuPHA+VGhlcmUmIzM5O3MgYWxzbyA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL2dlbmVyYXRvci10YXVudXNcXFwiPmEgWWVvbWFuIGdlbmVyYXRvciBuYW1lZCA8Y29kZT5nZW5lcmF0b3ItdGF1bnVzPC9jb2RlPjwvYT4geW91IGNvdWxkIHVzZSB0byBnZXQgc3RhcnRlZCwgaW5zdGVhZC48L3A+XFxuPC9ibG9ja3F1b3RlPlxcbjxwPk9uY2UgeW91JiMzOTt2ZSBzZXR0bGVkIGZvciBlaXRoZXIgPGEgaHJlZj1cXFwiaHR0cDovL2V4cHJlc3Nqcy5jb21cXFwiPkV4cHJlc3M8L2E+IG9yIDxhIGhyZWY9XFxcImh0dHA6Ly9oYXBpanMuY29tXFxcIj5IYXBpPC9hPiB5b3UmIzM5O2xsIGJlIGFibGUgdG8gcHJvY2VlZC4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGd1aWRlLCB3ZSYjMzk7bGwgdXNlIDxhIGhyZWY9XFxcImh0dHA6Ly9leHByZXNzanMuY29tXFxcIj5FeHByZXNzPC9hPi4gU3dpdGNoaW5nIGJldHdlZW4gb25lIG9mIHRoZSBkaWZmZXJlbnQgSFRUUCBmbGF2b3JzIGlzIHN0cmlraW5nbHkgZWFzeSwgdGhvdWdoLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcInNldHRpbmctdXAtdGhlLXNlcnZlci1zaWRlXFxcIj5TZXR0aW5nIHVwIHRoZSBzZXJ2ZXItc2lkZTwvaDQ+XFxuPHA+TmF0dXJhbGx5LCB5b3UmIzM5O2xsIG5lZWQgdG8gaW5zdGFsbCBhbGwgb2YgdGhlIGZvbGxvd2luZyBtb2R1bGVzIGZyb20gPGNvZGU+bnBtPC9jb2RlPiB0byBnZXQgc3RhcnRlZC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bWtkaXIgZ2V0dGluZy1zdGFydGVkXFxuY2QgZ2V0dGluZy1zdGFydGVkXFxubnBtIGluaXRcXG5ucG0gaW5zdGFsbCAtLXNhdmUgdGF1bnVzIHRhdW51cy1leHByZXNzIGV4cHJlc3NcXG48L2NvZGU+PC9wcmU+XFxuPHA+PGltZyBzcmM9XFxcImh0dHA6Ly9pLmltZ3VyLmNvbS80UDh2TmU5LnBuZ1xcXCIgYWx0PVxcXCJTY3JlZW5zaG90IHdpdGggYG5wbSBpbml0YCBvdXRwdXRcXFwiPjwvcD5cXG48cD5MZXQmIzM5O3MgYnVpbGQgb3VyIGFwcGxpY2F0aW9uIHN0ZXAtYnktc3RlcCwgYW5kIEkmIzM5O2xsIHdhbGsgeW91IHRocm91Z2ggdGhlbSBhcyB3ZSBnbyBhbG9uZy4gRmlyc3Qgb2YgYWxsLCB5b3UmIzM5O2xsIG5lZWQgdGhlIGZhbW91cyA8Y29kZT5hcHAuanM8L2NvZGU+IGZpbGUuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPnRvdWNoIGFwcC5qc1xcbjwvY29kZT48L3ByZT5cXG48cD5JdCYjMzk7cyBwcm9iYWJseSBhIGdvb2QgaWRlYSB0byBwdXQgc29tZXRoaW5nIGluIHlvdXIgPGNvZGU+YXBwLmpzPC9jb2RlPiBmaWxlLCBsZXQmIzM5O3MgZG8gdGhhdCBub3cuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbnZhciB0YXVudXMgPSByZXF1aXJlKCYjMzk7dGF1bnVzJiMzOTspO1xcbnZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgmIzM5O3RhdW51cy1leHByZXNzJiMzOTspO1xcbnZhciBleHByZXNzID0gcmVxdWlyZSgmIzM5O2V4cHJlc3MmIzM5Oyk7XFxudmFyIGFwcCA9IGV4cHJlc3MoKTtcXG52YXIgb3B0aW9ucyA9IHt9O1xcblxcbnRhdW51c0V4cHJlc3ModGF1bnVzLCBhcHAsIG9wdGlvbnMpO1xcbmFwcC5saXN0ZW4oMzAwMCk7XFxuPC9jb2RlPjwvcHJlPlxcbjxwPkFsbCA8Y29kZT50YXVudXMtZXhwcmVzczwvY29kZT4gcmVhbGx5IGRvZXMgaXMgYWRkIGEgYnVuY2ggb2Ygcm91dGVzIHRvIHlvdXIgRXhwcmVzcyA8Y29kZT5hcHA8L2NvZGU+LiBZb3Ugc2hvdWxkIG5vdGUgdGhhdCBhbnkgbWlkZGxld2FyZSBhbmQgQVBJIHJvdXRlcyBzaG91bGQgcHJvYmFibHkgY29tZSBiZWZvcmUgdGhlIDxjb2RlPnRhdW51c0V4cHJlc3M8L2NvZGU+IGludm9jYXRpb24uIFlvdSYjMzk7bGwgcHJvYmFibHkgYmUgdXNpbmcgYSBjYXRjaC1hbGwgdmlldyByb3V0ZSB0aGF0IHJlbmRlcnMgYSA8ZW0+JnF1b3Q7Tm90IEZvdW5kJnF1b3Q7PC9lbT4gdmlldywgYmxvY2tpbmcgYW55IHJvdXRpbmcgYmV5b25kIHRoYXQgcm91dGUuPC9wPlxcbjxwPklmIHlvdSB3ZXJlIHRvIHJ1biB0aGUgYXBwbGljYXRpb24gbm93IHlvdSB3b3VsZCBnZXQgYSBmcmllbmRseSByZW1pbmVkIGZyb20gVGF1bnVzIGxldHRpbmcgeW91IGtub3cgdGhhdCB5b3UgZm9yZ290IHRvIGRlY2xhcmUgYW55IHZpZXcgcm91dGVzLiBTaWxseSB5b3UhPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPm5vZGUgYXBwXFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vbjhtSDRtTi5wbmdcXFwiIGFsdD1cXFwiU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgb3V0cHV0XFxcIj48L3A+XFxuPHA+VGhlIDxjb2RlPm9wdGlvbnM8L2NvZGU+IG9iamVjdCBwYXNzZWQgdG8gPGNvZGU+dGF1bnVzRXhwcmVzczwvY29kZT4gbGV0JiMzOTtzIHlvdSBjb25maWd1cmUgVGF1bnVzLiBJbnN0ZWFkIG9mIGRpc2N1c3NpbmcgZXZlcnkgc2luZ2xlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHlvdSBjb3VsZCBzZXQgaGVyZSwgbGV0JiMzOTtzIGRpc2N1c3Mgd2hhdCBtYXR0ZXJzOiB0aGUgPGVtPnJlcXVpcmVkIGNvbmZpZ3VyYXRpb248L2VtPi4gVGhlcmUmIzM5O3MgdHdvIG9wdGlvbnMgdGhhdCB5b3UgbXVzdCBzZXQgaWYgeW91IHdhbnQgeW91ciBUYXVudXMgYXBwbGljYXRpb24gdG8gbWFrZSBhbnkgc2Vuc2UuPC9wPlxcbjx1bD5cXG48bGk+PGNvZGU+cm91dGVzPC9jb2RlPiBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdmlldyByb3V0ZXM8L2xpPlxcbjxsaT48Y29kZT5sYXlvdXQ8L2NvZGU+IHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgPGNvZGU+bW9kZWw8L2NvZGU+IGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGVudGlyZSBIVE1MIGRvY3VtZW50PC9saT5cXG48L3VsPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwieW91ci1maXJzdC1yb3V0ZVxcXCI+WW91ciBmaXJzdCByb3V0ZTwvaDQ+XFxuPHA+Um91dGVzIG5lZWQgdG8gYmUgcGxhY2VkIGluIGl0cyBvd24gZGVkaWNhdGVkIG1vZHVsZSwgc28gdGhhdCB5b3UgY2FuIHJldXNlIGl0IGxhdGVyIG9uIDxzdHJvbmc+d2hlbiBzZXR0aW5nIHVwIGNsaWVudC1zaWRlIHJvdXRpbmc8L3N0cm9uZz4uIExldCYjMzk7cyBjcmVhdGUgdGhhdCBtb2R1bGUgYW5kIGFkZCBhIHJvdXRlIHRvIGl0LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj50b3VjaCByb3V0ZXMuanNcXG48L2NvZGU+PC9wcmU+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBbXFxuICB7IHJvdXRlOiAmIzM5Oy8mIzM5OywgYWN0aW9uOiAmIzM5O2hvbWUvaW5kZXgmIzM5OyB9XFxuXTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+RWFjaCBpdGVtIGluIHRoZSBleHBvcnRlZCBhcnJheSBpcyBhIHJvdXRlLiBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgaGF2ZSB0aGUgPGNvZGU+LzwvY29kZT4gcm91dGUgd2l0aCB0aGUgPGNvZGU+aG9tZS9pbmRleDwvY29kZT4gYWN0aW9uLiBUYXVudXMgZm9sbG93cyB0aGUgd2VsbCBrbm93biA8YSBocmVmPVxcXCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnZlbnRpb25fb3Zlcl9jb25maWd1cmF0aW9uXFxcIj5jb252ZW50aW9uIG92ZXIgY29uZmlndXJhdGlvbiBwYXR0ZXJuPC9hPiwgd2hpY2ggbWFkZSA8YSBocmVmPVxcXCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1Ynlfb25fUmFpbHNcXFwiPlJ1Ynkgb24gUmFpbHM8L2E+IGZhbW91cy4gPGVtPk1heWJlIG9uZSBkYXkgVGF1bnVzIHdpbGwgYmUgZmFtb3VzIHRvbyE8L2VtPiBCeSBjb252ZW50aW9uLCBUYXVudXMgd2lsbCBhc3N1bWUgdGhhdCB0aGUgPGNvZGU+aG9tZS9pbmRleDwvY29kZT4gYWN0aW9uIHVzZXMgdGhlIDxjb2RlPmhvbWUvaW5kZXg8L2NvZGU+IGNvbnRyb2xsZXIgYW5kIHJlbmRlcnMgdGhlIDxjb2RlPmhvbWUvaW5kZXg8L2NvZGU+IHZpZXcuIE9mIGNvdXJzZSwgPGVtPmFsbCBvZiB0aGF0IGNhbiBiZSBjaGFuZ2VkIHVzaW5nIGNvbmZpZ3VyYXRpb248L2VtPi48L3A+XFxuPHA+VGltZSB0byBnbyBiYWNrIHRvIDxjb2RlPmFwcC5qczwvY29kZT4gYW5kIHVwZGF0ZSB0aGUgPGNvZGU+b3B0aW9uczwvY29kZT4gb2JqZWN0LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWpzXFxcIj4mIzM5O3VzZSBzdHJpY3QmIzM5OztcXG5cXG52YXIgdGF1bnVzID0gcmVxdWlyZSgmIzM5O3RhdW51cyYjMzk7KTtcXG52YXIgdGF1bnVzRXhwcmVzcyA9IHJlcXVpcmUoJiMzOTt0YXVudXMtZXhwcmVzcyYjMzk7KTtcXG52YXIgZXhwcmVzcyA9IHJlcXVpcmUoJiMzOTtleHByZXNzJiMzOTspO1xcbnZhciBhcHAgPSBleHByZXNzKCk7XFxudmFyIG9wdGlvbnMgPSB7XFxuICByb3V0ZXM6IHJlcXVpcmUoJiMzOTsuL3JvdXRlcyYjMzk7KVxcbn07XFxuXFxudGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuYXBwLmxpc3RlbigzMDAwKTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+SXQmIzM5O3MgaW1wb3J0YW50IHRvIGtub3cgdGhhdCBpZiB5b3Ugb21pdCB0aGUgY3JlYXRpb24gb2YgYSBjb250cm9sbGVyIHRoZW4gVGF1bnVzIHdpbGwgc2tpcCB0aGF0IHN0ZXAsIGFuZCByZW5kZXIgdGhlIHZpZXcgcGFzc2luZyBpdCB3aGF0ZXZlciB0aGUgZGVmYXVsdCBtb2RlbCBpcyA8ZW0+KG1vcmUgb24gdGhhdCA8YSBocmVmPVxcXCIvYXBpXFxcIj5pbiB0aGUgQVBJIGRvY3VtZW50YXRpb248L2E+LCBidXQgaXQgZGVmYXVsdHMgdG8gPGNvZGU+e308L2NvZGU+KTwvZW0+LjwvcD5cXG48cD5IZXJlJiMzOTtzIHdoYXQgeW91JiMzOTtkIGdldCBpZiB5b3UgYXR0ZW1wdGVkIHRvIHJ1biB0aGUgYXBwbGljYXRpb24gYXQgdGhpcyBwb2ludC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bm9kZSBhcHAgJmFtcDtcXG5jdXJsIGxvY2FsaG9zdDozMDAwXFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vMDhsbkNlYy5wbmdcXFwiIGFsdD1cXFwiU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgcmVzdWx0c1xcXCI+PC9wPlxcbjxwPlR1cm5zIG91dCB5b3UmIzM5O3JlIG1pc3NpbmcgYSBsb3Qgb2YgdGhpbmdzISBUYXVudXMgaXMgcXVpdGUgbGVuaWVudCBhbmQgaXQmIzM5O2xsIHRyeSBpdHMgYmVzdCB0byBsZXQgeW91IGtub3cgd2hhdCB5b3UgbWlnaHQgYmUgbWlzc2luZywgdGhvdWdoLiBBcHBhcmVudGx5IHlvdSBkb24mIzM5O3QgaGF2ZSBhIGxheW91dCwgYSBzZXJ2ZXItc2lkZSBjb250cm9sbGVyLCBvciBldmVuIGEgdmlldyEgPGVtPlRoYXQmIzM5O3Mgcm91Z2guPC9lbT48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg0IGlkPVxcXCJjcmVhdGluZy1hLWxheW91dFxcXCI+Q3JlYXRpbmcgYSBsYXlvdXQ8L2g0PlxcbjxwPkxldCYjMzk7cyBhbHNvIGNyZWF0ZSBhIGxheW91dC4gRm9yIHRoZSBwdXJwb3NlcyBvZiBtYWtpbmcgb3VyIHdheSB0aHJvdWdoIHRoaXMgZ3VpZGUsIGl0JiMzOTtsbCBqdXN0IGJlIGEgcGxhaW4gSmF2YVNjcmlwdCBmdW5jdGlvbi48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+dG91Y2ggbGF5b3V0LmpzXFxuPC9jb2RlPjwvcHJlPlxcbjxwPk5vdGUgdGhhdCB0aGUgPGNvZGU+cGFydGlhbDwvY29kZT4gcHJvcGVydHkgaW4gdGhlIDxjb2RlPm1vZGVsPC9jb2RlPiA8ZW0+KGFzIHNlZW4gYmVsb3cpPC9lbT4gaXMgY3JlYXRlZCBvbiB0aGUgZmx5IGFmdGVyIHJlbmRlcmluZyBwYXJ0aWFsIHZpZXdzLiBUaGUgbGF5b3V0IGZ1bmN0aW9uIHdlJiMzOTtsbCBiZSB1c2luZyBoZXJlIGVmZmVjdGl2ZWx5IG1lYW5zIDxlbT4mcXVvdDt1c2UgdGhlIGZvbGxvd2luZyBjb21iaW5hdGlvbiBvZiBwbGFpbiB0ZXh0IGFuZCB0aGUgPHN0cm9uZz4obWF5YmUgSFRNTCk8L3N0cm9uZz4gcGFydGlhbCB2aWV3JnF1b3Q7PC9lbT4uPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZGVsKSB7XFxuICByZXR1cm4gJiMzOTtUaGlzIGlzIHRoZSBwYXJ0aWFsOiAmcXVvdDsmIzM5OyArIG1vZGVsLnBhcnRpYWwgKyAmIzM5OyZxdW90OyYjMzk7O1xcbn07XFxuPC9jb2RlPjwvcHJlPlxcbjxwPk9mIGNvdXJzZSwgaWYgeW91IHdlcmUgZGV2ZWxvcGluZyBhIHJlYWwgYXBwbGljYXRpb24sIHRoZW4geW91IHByb2JhYmx5IHdvdWxkbiYjMzk7dCB3YW50IHRvIHdyaXRlIHZpZXdzIGFzIEphdmFTY3JpcHQgZnVuY3Rpb25zIGFzIHRoYXQmIzM5O3MgdW5wcm9kdWN0aXZlLCBjb25mdXNpbmcsIGFuZCBoYXJkIHRvIG1haW50YWluLiBXaGF0IHlvdSBjb3VsZCBkbyBpbnN0ZWFkLCBpcyB1c2UgYSB2aWV3LXJlbmRlcmluZyBlbmdpbmUgdGhhdCBhbGxvd3MgeW91IHRvIGNvbXBpbGUgeW91ciB2aWV3IHRlbXBsYXRlcyBpbnRvIEphdmFTY3JpcHQgZnVuY3Rpb25zLjwvcD5cXG48dWw+XFxuPGxpPjxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXFxcIj5NdXN0YWNoZTwvYT4gaXMgYSB0ZW1wbGF0aW5nIGVuZ2luZSB0aGF0IGNhbiBjb21waWxlIHlvdXIgdmlld3MgaW50byBwbGFpbiBmdW5jdGlvbnMsIHVzaW5nIGEgc3ludGF4IHRoYXQmIzM5O3MgbWluaW1hbGx5IGRpZmZlcmVudCBmcm9tIEhUTUw8L2xpPlxcbjxsaT48YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vamFkZWpzL2phZGVcXFwiPkphZGU8L2E+IGlzIGFub3RoZXIgb3B0aW9uLCBhbmQgaXQgaGFzIGEgdGVyc2Ugc3ludGF4IHdoZXJlIHNwYWNpbmcgbWF0dGVycyBidXQgdGhlcmUmIzM5O3Mgbm8gY2xvc2luZyB0YWdzPC9saT5cXG48bGk+VGhlcmUmIzM5O3MgbWFueSBtb3JlIGFsdGVybmF0aXZlcyBsaWtlIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ppbGxhLmdpdGh1Yi5pby9udW5qdWNrcy9cXFwiPk1vemlsbGEmIzM5O3MgTnVuanVja3M8L2E+LCA8YSBocmVmPVxcXCJodHRwOi8vaGFuZGxlYmFyc2pzLmNvbS9cXFwiPkhhbmRsZWJhcnM8L2E+LCBhbmQgPGEgaHJlZj1cXFwiaHR0cDovL3d3dy5lbWJlZGRlZGpzLmNvbS9cXFwiPkVKUzwvYT4uPC9saT5cXG48L3VsPlxcbjxwPlJlbWVtYmVyIHRvIGFkZCB0aGUgPGNvZGU+bGF5b3V0PC9jb2RlPiB1bmRlciB0aGUgPGNvZGU+b3B0aW9uczwvY29kZT4gb2JqZWN0IHBhc3NlZCB0byA8Y29kZT50YXVudXNFeHByZXNzPC9jb2RlPiE8L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxudmFyIHRhdW51cyA9IHJlcXVpcmUoJiMzOTt0YXVudXMmIzM5Oyk7XFxudmFyIHRhdW51c0V4cHJlc3MgPSByZXF1aXJlKCYjMzk7dGF1bnVzLWV4cHJlc3MmIzM5Oyk7XFxudmFyIGV4cHJlc3MgPSByZXF1aXJlKCYjMzk7ZXhwcmVzcyYjMzk7KTtcXG52YXIgYXBwID0gZXhwcmVzcygpO1xcbnZhciBvcHRpb25zID0ge1xcbiAgcm91dGVzOiByZXF1aXJlKCYjMzk7Li9yb3V0ZXMmIzM5OyksXFxuICBsYXlvdXQ6IHJlcXVpcmUoJiMzOTsuL2xheW91dCYjMzk7KVxcbn07XFxuXFxudGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuYXBwLmxpc3RlbigzMDAwKTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+SGVyZSYjMzk7cyB3aGF0IHlvdSYjMzk7ZCBnZXQgaWYgeW91IHJhbiB0aGUgYXBwbGljYXRpb24gYXQgdGhpcyBwb2ludC48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bm9kZSBhcHAgJmFtcDtcXG5jdXJsIGxvY2FsaG9zdDozMDAwXFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vd1VibkN5ay5wbmdcXFwiIGFsdD1cXFwiU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgb3V0cHV0XFxcIj48L3A+XFxuPHA+QXQgdGhpcyBwb2ludCB3ZSBoYXZlIGEgbGF5b3V0LCBidXQgd2UmIzM5O3JlIHN0aWxsIG1pc3NpbmcgdGhlIHBhcnRpYWwgdmlldyBhbmQgdGhlIHNlcnZlci1zaWRlIGNvbnRyb2xsZXIuIFdlIGNhbiBkbyB3aXRob3V0IHRoZSBjb250cm9sbGVyLCBidXQgaGF2aW5nIG5vIHZpZXdzIGlzIGtpbmQgb2YgcG9pbnRsZXNzIHdoZW4geW91JiMzOTtyZSB0cnlpbmcgdG8gZ2V0IGFuIE1WQyBlbmdpbmUgdXAgYW5kIHJ1bm5pbmcsIHJpZ2h0PzwvcD5cXG48cD5Zb3UmIzM5O2xsIGZpbmQgdG9vbHMgcmVsYXRlZCB0byB2aWV3IHRlbXBsYXRpbmcgaW4gdGhlIDxhIGhyZWY9XFxcIi9jb21wbGVtZW50c1xcXCI+Y29tcGxlbWVudGFyeSBtb2R1bGVzIHNlY3Rpb248L2E+LiBJZiB5b3UgZG9uJiMzOTt0IHByb3ZpZGUgYSA8Y29kZT5sYXlvdXQ8L2NvZGU+IHByb3BlcnR5IGF0IGFsbCwgVGF1bnVzIHdpbGwgcmVuZGVyIHlvdXIgbW9kZWwgaW4gYSByZXNwb25zZSBieSB3cmFwcGluZyBpdCBpbiA8Y29kZT4mbHQ7cHJlJmd0OzwvY29kZT4gYW5kIDxjb2RlPiZsdDtjb2RlJmd0OzwvY29kZT4gdGFncywgd2hpY2ggbWF5IGFpZCB5b3Ugd2hlbiBnZXR0aW5nIHN0YXJ0ZWQuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwidXNpbmctamFkZS1hcy15b3VyLXZpZXctZW5naW5lXFxcIj5Vc2luZyBKYWRlIGFzIHlvdXIgdmlldyBlbmdpbmU8L2g0PlxcbjxwPkxldCYjMzk7cyBnbyBhaGVhZCBhbmQgdXNlIEphZGUgYXMgdGhlIHZpZXctcmVuZGVyaW5nIGVuZ2luZSBvZiBjaG9pY2UgZm9yIG91ciB2aWV3cy48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bWtkaXIgLXAgdmlld3MvaG9tZVxcbnRvdWNoIHZpZXdzL2hvbWUvaW5kZXguamFkZVxcbjwvY29kZT48L3ByZT5cXG48cD5TaW5jZSB3ZSYjMzk7cmUganVzdCBnZXR0aW5nIHN0YXJ0ZWQsIHRoZSB2aWV3IHdpbGwganVzdCBoYXZlIHNvbWUgYmFzaWMgc3RhdGljIGNvbnRlbnQsIGFuZCB0aGF0JiMzOTtzIGl0LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWphZGVcXFwiPnAgSGVsbG8gVGF1bnVzIVxcbjwvY29kZT48L3ByZT5cXG48cD5OZXh0IHlvdSYjMzk7bGwgd2FudCB0byBjb21waWxlIHRoZSB2aWV3IGludG8gYSBmdW5jdGlvbi4gVG8gZG8gdGhhdCB5b3UgY2FuIHVzZSA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvamFkdW1cXFwiPmphZHVtPC9hPiwgYSBzcGVjaWFsaXplZCBKYWRlIGNvbXBpbGVyIHRoYXQgcGxheXMgd2VsbCB3aXRoIFRhdW51cyBieSBiZWluZyBhd2FyZSBvZiA8Y29kZT5yZXF1aXJlPC9jb2RlPiBzdGF0ZW1lbnRzLCBhbmQgdGh1cyBzYXZpbmcgYnl0ZXMgd2hlbiBpdCBjb21lcyB0byBjbGllbnQtc2lkZSByZW5kZXJpbmcuIExldCYjMzk7cyBpbnN0YWxsIGl0IGdsb2JhbGx5LCBmb3IgdGhlIHNha2Ugb2YgdGhpcyBleGVyY2lzZSA8ZW0+KHlvdSBzaG91bGQgaW5zdGFsbCBpdCBsb2NhbGx5IHdoZW4geW91JiMzOTtyZSBkZXZlbG9waW5nIGEgcmVhbCBhcHBsaWNhdGlvbik8L2VtPi48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bnBtIGluc3RhbGwgLS1nbG9iYWwgamFkdW1cXG48L2NvZGU+PC9wcmU+XFxuPHA+VG8gY29tcGlsZSBldmVyeSB2aWV3IGluIHRoZSA8Y29kZT52aWV3czwvY29kZT4gZGlyZWN0b3J5IGludG8gZnVuY3Rpb25zIHRoYXQgd29yayB3ZWxsIHdpdGggVGF1bnVzLCB5b3UgY2FuIHVzZSB0aGUgY29tbWFuZCBiZWxvdy4gVGhlIDxjb2RlPi0tb3V0cHV0PC9jb2RlPiBmbGFnIGluZGljYXRlcyB3aGVyZSB5b3Ugd2FudCB0aGUgdmlld3MgdG8gYmUgcGxhY2VkLiBXZSBjaG9zZSB0byB1c2UgPGNvZGU+LmJpbjwvY29kZT4gYmVjYXVzZSB0aGF0JiMzOTtzIHdoZXJlIFRhdW51cyBleHBlY3RzIHlvdXIgY29tcGlsZWQgdmlld3MgdG8gYmUgYnkgZGVmYXVsdC4gQnV0IHNpbmNlIFRhdW51cyBmb2xsb3dzIHRoZSA8YSBocmVmPVxcXCJodHRwOi8vcG9ueWZvby5jb20vc3RvcC1icmVha2luZy10aGUtd2ViXFxcIj5jb252ZW50aW9uIG92ZXIgY29uZmlndXJhdGlvbjwvYT4gYXBwcm9hY2gsIHlvdSBjb3VsZCBjaGFuZ2UgdGhhdCBpZiB5b3Ugd2FudGVkIHRvLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5qYWR1bSB2aWV3cy8qKiAtLW91dHB1dCAuYmluXFxuPC9jb2RlPjwvcHJlPlxcbjxwPkNvbmdyYXR1bGF0aW9ucyEgWW91ciBmaXJzdCB2aWV3IGlzIG5vdyBvcGVyYXRpb25hbCBhbmQgYnVpbHQgdXNpbmcgYSBmdWxsLWZsZWRnZWQgdGVtcGxhdGluZyBlbmdpbmUhIEFsbCB0aGF0JiMzOTtzIGxlZnQgaXMgZm9yIHlvdSB0byBydW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB2aXNpdCBpdCBvbiBwb3J0IDxjb2RlPjMwMDA8L2NvZGU+LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ub2RlIGFwcCAmYW1wO1xcbm9wZW4gaHR0cDovL2xvY2FsaG9zdDozMDAwXFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vemphSllDcS5wbmdcXFwiIGFsdD1cXFwiU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgb3V0cHV0XFxcIj48L3A+XFxuPHA+R3JhbnRlZCwgeW91IHNob3VsZCA8ZW0+cHJvYmFibHk8L2VtPiBtb3ZlIHRoZSBsYXlvdXQgaW50byBhIEphZGUgPGVtPihhbnkgdmlldyBlbmdpbmUgd2lsbCBkbyk8L2VtPiB0ZW1wbGF0ZSBhcyB3ZWxsLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcInRocm93aW5nLWluLWEtY29udHJvbGxlclxcXCI+VGhyb3dpbmcgaW4gYSBjb250cm9sbGVyPC9oND5cXG48cD5Db250cm9sbGVycyBhcmUgaW5kZWVkIG9wdGlvbmFsLCBidXQgYW4gYXBwbGljYXRpb24gdGhhdCByZW5kZXJzIGV2ZXJ5IHZpZXcgdXNpbmcgdGhlIHNhbWUgbW9kZWwgd29uJiMzOTt0IGdldCB5b3UgdmVyeSBmYXIuIENvbnRyb2xsZXJzIGFsbG93IHlvdSB0byBoYW5kbGUgdGhlIHJlcXVlc3QgYW5kIHB1dCB0b2dldGhlciB0aGUgbW9kZWwgdG8gYmUgdXNlZCB3aGVuIHNlbmRpbmcgYSByZXNwb25zZS4gQ29udHJhcnkgdG8gd2hhdCBtb3N0IGZyYW1ld29ya3MgcHJvcG9zZSwgVGF1bnVzIGV4cGVjdHMgZXZlcnkgYWN0aW9uIHRvIGhhdmUgaXRzIG93biBpbmRpdmlkdWFsIGNvbnRyb2xsZXIuIFNpbmNlIE5vZGUuanMgbWFrZXMgaXQgZWFzeSB0byBpbXBvcnQgY29tcG9uZW50cywgdGhpcyBzZXR1cCBoZWxwcyB5b3Uga2VlcCB5b3VyIGNvZGUgbW9kdWxhciB3aGlsZSBzdGlsbCBiZWluZyBhYmxlIHRvIHJldXNlIGxvZ2ljIGJ5IHNoYXJpbmcgbW9kdWxlcyBhY3Jvc3MgZGlmZmVyZW50IGNvbnRyb2xsZXJzLiBMZXQmIzM5O3MgY3JlYXRlIGEgY29udHJvbGxlciBmb3IgdGhlIDxjb2RlPmhvbWUvdmlldzwvY29kZT4gYWN0aW9uLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ta2RpciAtcCBjb250cm9sbGVycy9ob21lXFxudG91Y2ggY29udHJvbGxlcnMvaG9tZS9pbmRleC5qc1xcbjwvY29kZT48L3ByZT5cXG48cD5UaGUgY29udHJvbGxlciBtb2R1bGUgc2hvdWxkIG1lcmVseSBleHBvcnQgYSBmdW5jdGlvbi4gPGVtPlN0YXJ0ZWQgbm90aWNpbmcgdGhlIHBhdHRlcm4/PC9lbT4gVGhlIHNpZ25hdHVyZSBmb3IgdGhlIGNvbnRyb2xsZXIgaXMgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoYXQgb2YgYW55IG90aGVyIG1pZGRsZXdhcmUgcGFzc2VkIHRvIDxhIGhyZWY9XFxcImh0dHA6Ly9leHByZXNzanMuY29tXFxcIj5FeHByZXNzPC9hPiA8ZW0+KG9yIGFueSByb3V0ZSBoYW5kbGVyIHBhc3NlZCB0byA8YSBocmVmPVxcXCJodHRwOi8vaGFwaWpzLmNvbVxcXCI+SGFwaTwvYT4gaW4gdGhlIGNhc2Ugb2YgPGNvZGU+dGF1bnVzLWhhcGk8L2NvZGU+KTwvZW0+LjwvcD5cXG48cD5BcyB5b3UgbWF5IGhhdmUgbm90aWNlZCBpbiB0aGUgZXhhbXBsZXMgc28gZmFyLCB5b3UgaGF2ZW4mIzM5O3QgZXZlbiBzZXQgYSBkb2N1bWVudCB0aXRsZSBmb3IgeW91ciBIVE1MIHBhZ2VzISBUdXJucyBvdXQsIHRoZXJlJiMzOTtzIGEgZmV3IG1vZGVsIHByb3BlcnRpZXMgPGVtPih2ZXJ5IGZldyk8L2VtPiB0aGF0IFRhdW51cyBpcyBhd2FyZSBvZi4gT25lIG9mIHRob3NlIGlzIHRoZSA8Y29kZT50aXRsZTwvY29kZT4gcHJvcGVydHksIGFuZCBpdCYjMzk7bGwgYmUgdXNlZCB0byBjaGFuZ2UgdGhlIDxjb2RlPmRvY3VtZW50LnRpdGxlPC9jb2RlPiBpbiB5b3VyIHBhZ2VzIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIHRoZSBjbGllbnQtc2lkZS4gS2VlcCBpbiBtaW5kIHRoYXQgYW55dGhpbmcgdGhhdCYjMzk7cyBub3QgaW4gdGhlIDxjb2RlPm1vZGVsPC9jb2RlPiBwcm9wZXJ0eSB3b24mIzM5O3QgYmUgdHJhc21pdHRlZCB0byB0aGUgY2xpZW50LCBhbmQgd2lsbCBqdXN0IGJlIGFjY2Vzc2libGUgdG8gdGhlIGxheW91dC48L3A+XFxuPHA+SGVyZSBpcyBvdXIgbmV3ZmFuZ2xlZCA8Y29kZT5ob21lL2luZGV4PC9jb2RlPiBjb250cm9sbGVyLiBBcyB5b3UmIzM5O2xsIG5vdGljZSwgaXQgZG9lc24mIzM5O3QgZGlzcnVwdCBhbnkgb2YgdGhlIHR5cGljYWwgRXhwcmVzcyBleHBlcmllbmNlLCBidXQgbWVyZWx5IGJ1aWxkcyB1cG9uIGl0LiBXaGVuIDxjb2RlPm5leHQ8L2NvZGU+IGlzIGNhbGxlZCwgdGhlIFRhdW51cyB2aWV3LXJlbmRlcmluZyBoYW5kbGVyIHdpbGwga2ljayBpbiwgYW5kIHJlbmRlciB0aGUgdmlldyB1c2luZyB0aGUgaW5mb3JtYXRpb24gdGhhdCB3YXMgYXNzaWduZWQgdG8gPGNvZGU+cmVzLnZpZXdNb2RlbDwvY29kZT4uPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7XFxuICByZXMudmlld01vZGVsID0ge1xcbiAgICBtb2RlbDoge1xcbiAgICAgIHRpdGxlOiAmIzM5O1dlbGNvbWUgSG9tZSwgVGF1bnVzISYjMzk7XFxuICAgIH1cXG4gIH07XFxuICBuZXh0KCk7XFxufTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+T2YgY291cnNlLCByZWx5aW5nIG9uIHRoZSBjbGllbnQtc2lkZSBjaGFuZ2VzIHRvIHlvdXIgcGFnZSBpbiBvcmRlciB0byBzZXQgdGhlIHZpZXcgdGl0bGUgPGVtPndvdWxkbiYjMzk7dCBiZSBwcm9ncmVzc2l2ZTwvZW0+LCBhbmQgdGh1cyA8YSBocmVmPVxcXCJodHRwOi8vcG9ueWZvby5jb20vc3RvcC1icmVha2luZy10aGUtd2ViXFxcIj5pdCB3b3VsZCBiZSByZWFsbHksIDxlbT5yZWFsbHk8L2VtPiBiYWQ8L2E+LiBXZSBzaG91bGQgdXBkYXRlIHRoZSBsYXlvdXQgdG8gdXNlIHdoYXRldmVyIDxjb2RlPnRpdGxlPC9jb2RlPiBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIG1vZGVsLiBJbiBmYWN0LCBsZXQmIzM5O3MgZ28gYmFjayB0byB0aGUgZHJhd2luZyBib2FyZCBhbmQgbWFrZSB0aGUgbGF5b3V0IGludG8gYSBKYWRlIHRlbXBsYXRlITwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ybSBsYXlvdXQuanNcXG50b3VjaCB2aWV3cy9sYXlvdXQuamFkZVxcbmphZHVtIHZpZXdzLyoqIC0tb3V0cHV0IC5iaW5cXG48L2NvZGU+PC9wcmU+XFxuPHA+WW91IHNob3VsZCBhbHNvIHJlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgPGNvZGU+YXBwLmpzPC9jb2RlPiBtb2R1bGUgb25jZSBhZ2FpbiE8L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxudmFyIHRhdW51cyA9IHJlcXVpcmUoJiMzOTt0YXVudXMmIzM5Oyk7XFxudmFyIHRhdW51c0V4cHJlc3MgPSByZXF1aXJlKCYjMzk7dGF1bnVzLWV4cHJlc3MmIzM5Oyk7XFxudmFyIGV4cHJlc3MgPSByZXF1aXJlKCYjMzk7ZXhwcmVzcyYjMzk7KTtcXG52YXIgYXBwID0gZXhwcmVzcygpO1xcbnZhciBvcHRpb25zID0ge1xcbiAgcm91dGVzOiByZXF1aXJlKCYjMzk7Li9yb3V0ZXMmIzM5OyksXFxuICBsYXlvdXQ6IHJlcXVpcmUoJiMzOTsuLy5iaW4vdmlld3MvbGF5b3V0JiMzOTspXFxufTtcXG5cXG50YXVudXNFeHByZXNzKHRhdW51cywgYXBwLCBvcHRpb25zKTtcXG5hcHAubGlzdGVuKDMwMDApO1xcbjwvY29kZT48L3ByZT5cXG48cD5UaGUgPGNvZGU+IT08L2NvZGU+IHN5bnRheCBiZWxvdyBtZWFucyB0aGF0IHdoYXRldmVyIGlzIGluIHRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgZWxlbWVudCB3b24mIzM5O3QgYmUgZXNjYXBlZC4gVGhhdCYjMzk7cyBva2F5IGJlY2F1c2UgPGNvZGU+cGFydGlhbDwvY29kZT4gaXMgYSB2aWV3IHdoZXJlIEphZGUgZXNjYXBlZCBhbnl0aGluZyB0aGF0IG5lZWRlZCBlc2NhcGluZywgYnV0IHdlIHdvdWxkbiYjMzk7dCB3YW50IEhUTUwgdGFncyB0byBiZSBlc2NhcGVkITwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWphZGVcXFwiPnRpdGxlPW1vZGVsLnRpdGxlXFxubWFpbiE9cGFydGlhbFxcbjwvY29kZT48L3ByZT5cXG48cD5CeSB0aGUgd2F5LCBkaWQgeW91IGtub3cgdGhhdCA8Y29kZT4mbHQ7aHRtbCZndDs8L2NvZGU+LCA8Y29kZT4mbHQ7aGVhZCZndDs8L2NvZGU+LCBhbmQgPGNvZGU+Jmx0O2JvZHkmZ3Q7PC9jb2RlPiBhcmUgYWxsIG9wdGlvbmFsIGluIEhUTUwgNSwgYW5kIHRoYXQgeW91IGNhbiBzYWZlbHkgb21pdCB0aGVtIGluIHlvdXIgSFRNTD8gT2YgY291cnNlLCByZW5kZXJpbmcgZW5naW5lcyB3aWxsIHN0aWxsIGluc2VydCB0aG9zZSBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IGludG8gdGhlIERPTSBmb3IgeW91ISA8ZW0+SG93IGNvb2wgaXMgdGhhdD88L2VtPjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ub2RlIGFwcFxcbjwvY29kZT48L3ByZT5cXG48cD48aW1nIHNyYz1cXFwiaHR0cDovL2kuaW1ndXIuY29tL052RVd4OXoucG5nXFxcIiBhbHQ9XFxcIlNjcmVlbnNob3Qgd2l0aCBgbm9kZSBhcHBgIG91dHB1dFxcXCI+PC9wPlxcbjxwPllvdSBjYW4gbm93IHZpc2l0IDxjb2RlPmxvY2FsaG9zdDozMDAwPC9jb2RlPiB3aXRoIHlvdXIgZmF2b3JpdGUgd2ViIGJyb3dzZXIgYW5kIHlvdSYjMzk7bGwgbm90aWNlIHRoYXQgdGhlIHZpZXcgcmVuZGVycyBhcyB5b3UmIzM5O2QgZXhwZWN0LiBUaGUgdGl0bGUgd2lsbCBiZSBwcm9wZXJseSBzZXQsIGFuZCBhIDxjb2RlPiZsdDttYWluJmd0OzwvY29kZT4gZWxlbWVudCB3aWxsIGhhdmUgdGhlIGNvbnRlbnRzIG9mIHlvdXIgdmlldy48L3A+XFxuPHA+PGltZyBzcmM9XFxcImh0dHA6Ly9pLmltZ3VyLmNvbS9MZ1pSRm41LnBuZ1xcXCIgYWx0PVxcXCJTY3JlZW5zaG90IHdpdGggYXBwbGljYXRpb24gcnVubmluZyBvbiBHb29nbGUgQ2hyb21lXFxcIj48L3A+XFxuPHA+VGhhdCYjMzk7cyBpdCwgbm93IHlvdXIgdmlldyBoYXMgYSB0aXRsZS4gT2YgY291cnNlLCB0aGVyZSYjMzk7cyBub3RoaW5nIHN0b3BwaW5nIHlvdSBmcm9tIGFkZGluZyBkYXRhYmFzZSBjYWxscyB0byBmZXRjaCBiaXRzIGFuZCBwaWVjZXMgb2YgdGhlIG1vZGVsIGJlZm9yZSBpbnZva2luZyA8Y29kZT5uZXh0PC9jb2RlPiB0byByZW5kZXIgdGhlIHZpZXcuPC9wPlxcbjxwPlRoZW4gdGhlcmUmIzM5O3MgYWxzbyB0aGUgY2xpZW50LXNpZGUgYXNwZWN0IG9mIHNldHRpbmcgdXAgVGF1bnVzLiBMZXQmIzM5O3Mgc2V0IGl0IHVwIGFuZCBzZWUgaG93IGl0IG9wZW5zIHVwIG91ciBwb3NzaWJpbGl0aWVzLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDEgaWQ9XFxcInRhdW51cy1pbi10aGUtY2xpZW50XFxcIj5UYXVudXMgaW4gdGhlIGNsaWVudDwvaDE+XFxuPHA+WW91IGFscmVhZHkga25vdyBob3cgdG8gc2V0IHVwIHRoZSBiYXNpY3MgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZywgYW5kIHlvdSBrbm93IHRoYXQgeW91IHNob3VsZCA8YSBocmVmPVxcXCIvYXBpXFxcIj5jaGVjayBvdXQgdGhlIEFQSSBkb2N1bWVudGF0aW9uPC9hPiB0byBnZXQgYSBtb3JlIHRob3JvdWdoIHVuZGVyc3RhbmRpbmcgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb24gVGF1bnVzLCBhbmQgd2hhdCBpdCBlbmFibGVzIHlvdSB0byBkby48L3A+XFxuPHA+VGhlIHdheSBUYXVudXMgd29ya3Mgb24gdGhlIGNsaWVudC1zaWRlIGlzIHNvIHRoYXQgb25jZSB5b3Ugc2V0IGl0IHVwLCBpdCB3aWxsIGhpamFjayBsaW5rIGNsaWNrcyBhbmQgdXNlIEFKQVggdG8gZmV0Y2ggbW9kZWxzIGFuZCByZW5kZXIgdGhvc2Ugdmlld3MgaW4gdGhlIGNsaWVudC4gSWYgdGhlIEphdmFTY3JpcHQgY29kZSBmYWlscyB0byBsb2FkLCA8ZW0+b3IgaWYgaXQgaGFzbiYjMzk7dCBsb2FkZWQgeWV0IGR1ZSB0byBhIHNsb3cgY29ubmVjdGlvbiBzdWNoIGFzIHRob3NlIGluIHVuc3RhYmxlIG1vYmlsZSBuZXR3b3JrczwvZW0+LCB0aGUgcmVndWxhciBsaW5rIHdvdWxkIGJlIGZvbGxvd2VkIGluc3RlYWQgYW5kIG5vIGhhcm0gd291bGQgYmUgdW5sZWFzaGVkIHVwb24gdGhlIGh1bWFuLCBleGNlcHQgdGhleSB3b3VsZCBnZXQgYSBzbGlnaHRseSBsZXNzIGZhbmN5IGV4cGVyaWVuY2UuPC9wPlxcbjxwPlNldHRpbmcgdXAgdGhlIGNsaWVudC1zaWRlIGludm9sdmVzIGEgZmV3IGRpZmZlcmVudCBzdGVwcy4gRmlyc3RseSwgd2UmIzM5O2xsIGhhdmUgdG8gY29tcGlsZSB0aGUgYXBwbGljYXRpb24mIzM5O3Mgd2lyaW5nIDxlbT4odGhlIHJvdXRlcyBhbmQgSmF2YVNjcmlwdCB2aWV3IGZ1bmN0aW9ucyk8L2VtPiBpbnRvIHNvbWV0aGluZyB0aGUgYnJvd3NlciB1bmRlcnN0YW5kcy4gVGhlbiwgeW91JiMzOTtsbCBoYXZlIHRvIG1vdW50IFRhdW51cyBvbiB0aGUgY2xpZW50LXNpZGUsIHBhc3NpbmcgdGhlIHdpcmluZyBzbyB0aGF0IGl0IGtub3dzIHdoaWNoIHJvdXRlcyBpdCBzaG91bGQgcmVzcG9uZCB0bywgYW5kIHdoaWNoIG90aGVycyBpdCBzaG91bGQgbWVyZWx5IGlnbm9yZS4gT25jZSB0aGF0JiMzOTtzIG91dCBvZiB0aGUgd2F5LCBjbGllbnQtc2lkZSByb3V0aW5nIHdvdWxkIGJlIHNldCB1cC48L3A+XFxuPHA+QXMgc3VnYXIgY29hdGluZyBvbiB0b3Agb2YgdGhhdCwgeW91IG1heSBhZGQgY2xpZW50LXNpZGUgZnVuY3Rpb25hbGl0eSB1c2luZyBjb250cm9sbGVycy4gVGhlc2UgY29udHJvbGxlcnMgd291bGQgYmUgZXhlY3V0ZWQgZXZlbiBpZiB0aGUgdmlldyB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci1zaWRlLiBUaGV5IGNhbiBhY2Nlc3MgdGhlIFRhdW51cyBBUEkgZGlyZWN0bHksIGluIGNhc2UgeW91IG5lZWQgdG8gbmF2aWdhdGUgdG8gYW5vdGhlciB2aWV3IGluIHNvbWUgd2F5IG90aGVyIHRoYW4gYnkgaGF2aW5nIGh1bWFucyBjbGljayBvbiBhbmNob3IgdGFncy4gVGhlIEFQSSwgYXMgeW91JiMzOTtsbCBsZWFybiwgd2lsbCBhbHNvIGxldCB5b3UgcmVuZGVyIHBhcnRpYWwgdmlld3MgdXNpbmcgdGhlIHBvd2VyZnVsIFRhdW51cyBlbmdpbmUsIGxpc3RlbiBmb3IgZXZlbnRzIHRoYXQgbWF5IG9jY3VyIGF0IGtleSBzdGFnZXMgb2YgdGhlIHZpZXctcmVuZGVyaW5nIHByb2Nlc3MsIGFuZCBldmVuIGludGVyY2VwdCBBSkFYIHJlcXVlc3RzIGJsb2NraW5nIHRoZW0gYmVmb3JlIHRoZXkgZXZlciBoYXBwZW4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwidXNpbmctdGhlLXRhdW51cy1jbGlcXFwiPlVzaW5nIHRoZSBUYXVudXMgQ0xJPC9oND5cXG48cD5UYXVudXMgY29tZXMgd2l0aCBhIENMSSB0aGF0IGNhbiBiZSB1c2VkIHRvIHdpcmUgeW91ciBOb2RlLmpzIHJvdXRlcyBhbmQgdmlld3MgaW50byB0aGUgY2xpZW50LXNpZGUuIFRoZSBzYW1lIENMSSBjYW4gYmUgdXNlZCB0byB3aXJlIHVwIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVycyBhcyB3ZWxsLiBUaGUgbWFpbiByZWFzb24gd2h5IHRoZSBUYXVudXMgQ0xJIGV4aXN0cyBpcyBzbyB0aGF0IHlvdSBkb24mIzM5O3QgaGF2ZSB0byA8Y29kZT5yZXF1aXJlPC9jb2RlPiBldmVyeSBzaW5nbGUgdmlldyBhbmQgY29udHJvbGxlciwgdW5kb2luZyBhIGxvdCBvZiB0aGUgd29yayB0aGF0IHdhcyBwdXQgaW50byBjb2RlIHJldXNlLiBKdXN0IGxpa2Ugd2UgZGlkIHdpdGggPGNvZGU+amFkdW08L2NvZGU+IGVhcmxpZXIsIHdlJiMzOTtsbCBpbnN0YWxsIHRoZSA8Y29kZT50YXVudXM8L2NvZGU+IENMSSBnbG9iYWxseSBmb3IgdGhlIHNha2Ugb2YgZXhlcmNpc2luZywgYnV0IHdlIHVuZGVyc3RhbmQgdGhhdCByZWx5aW5nIG9uIGdsb2JhbGx5IGluc3RhbGxlZCBtb2R1bGVzIGlzIGluc3VmZmljaWVudCBmb3IgcHJvZHVjdGlvbi1ncmFkZSBhcHBsaWNhdGlvbnMuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPm5wbSBpbnN0YWxsIC0tZ2xvYmFsIHRhdW51c1xcbjwvY29kZT48L3ByZT5cXG48cD5CZWZvcmUgeW91IGNhbiB1c2UgdGhlIENMSSwgeW91IHNob3VsZCBtb3ZlIHRoZSByb3V0ZSBkZWZpbml0aW9ucyB0byA8Y29kZT5jb250cm9sbGVycy9yb3V0ZXMuanM8L2NvZGU+LiBUaGF0JiMzOTtzIHdoZXJlIFRhdW51cyBleHBlY3RzIHRoZW0gdG8gYmUuIElmIHlvdSB3YW50IHRvIHBsYWNlIHRoZW0gc29tZXRoaW5nIGVsc2UsIDxhIGhyZWY9XFxcIi9hcGlcXFwiPnRoZSBBUEkgZG9jdW1lbnRhdGlvbiBjYW4gaGVscCB5b3U8L2E+LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5tdiByb3V0ZXMuanMgY29udHJvbGxlcnMvcm91dGVzLmpzXFxuPC9jb2RlPjwvcHJlPlxcbjxwPlNpbmNlIHlvdSBtb3ZlZCB0aGUgcm91dGVzIHlvdSBzaG91bGQgYWxzbyB1cGRhdGUgdGhlIDxjb2RlPnJlcXVpcmU8L2NvZGU+IHN0YXRlbWVudCBpbiB0aGUgPGNvZGU+YXBwLmpzPC9jb2RlPiBtb2R1bGUuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbnZhciB0YXVudXMgPSByZXF1aXJlKCYjMzk7dGF1bnVzJiMzOTspO1xcbnZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgmIzM5O3RhdW51cy1leHByZXNzJiMzOTspO1xcbnZhciBleHByZXNzID0gcmVxdWlyZSgmIzM5O2V4cHJlc3MmIzM5Oyk7XFxudmFyIGFwcCA9IGV4cHJlc3MoKTtcXG52YXIgb3B0aW9ucyA9IHtcXG4gIHJvdXRlczogcmVxdWlyZSgmIzM5Oy4vY29udHJvbGxlcnMvcm91dGVzJiMzOTspLFxcbiAgbGF5b3V0OiByZXF1aXJlKCYjMzk7Li8uYmluL3ZpZXdzL2xheW91dCYjMzk7KVxcbn07XFxuXFxudGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuYXBwLmxpc3RlbigzMDAwKTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+VGhlIENMSSBpcyB0ZXJzZSBpbiBib3RoIGl0cyBpbnB1dHMgYW5kIGl0cyBvdXRwdXRzLiBJZiB5b3UgcnVuIGl0IHdpdGhvdXQgYW55IGFyZ3VtZW50cyBpdCYjMzk7bGwgcHJpbnQgb3V0IHRoZSB3aXJpbmcgbW9kdWxlLCBhbmQgaWYgeW91IHdhbnQgdG8gcGVyc2lzdCBpdCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIDxjb2RlPi0tb3V0cHV0PC9jb2RlPiBmbGFnLiBJbiB0eXBpY2FsIDxhIGhyZWY9XFxcImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmVudGlvbl9vdmVyX2NvbmZpZ3VyYXRpb25cXFwiPmNvbnZlbnRpb24tb3Zlci1jb25maWd1cmF0aW9uPC9hPiBmYXNoaW9uLCB0aGUgQ0xJIHdpbGwgZGVmYXVsdCB0byBpbmZlcnJpbmcgeW91ciB2aWV3cyBhcmUgbG9jYXRlZCBpbiA8Y29kZT4uYmluL3ZpZXdzPC9jb2RlPiBhbmQgdGhhdCB5b3Ugd2FudCB0aGUgd2lyaW5nIG1vZHVsZSB0byBiZSBwbGFjZWQgaW4gPGNvZGU+LmJpbi93aXJpbmcuanM8L2NvZGU+LCBidXQgeW91JiMzOTtsbCBiZSBhYmxlIHRvIGNoYW5nZSB0aGF0IGlmIGl0IGRvZXNuJiMzOTt0IG1lZXQgeW91ciBuZWVkcy48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+dGF1bnVzIC0tb3V0cHV0XFxuPC9jb2RlPjwvcHJlPlxcbjxwPkF0IHRoaXMgcG9pbnQgaW4gb3VyIGV4YW1wbGUsIHRoZSBDTEkgc2hvdWxkIGNyZWF0ZSBhIDxjb2RlPi5iaW4vd2lyaW5nLmpzPC9jb2RlPiBmaWxlIHdpdGggdGhlIGNvbnRlbnRzIGRldGFpbGVkIGJlbG93LiBBcyB5b3UgY2FuIHNlZSwgZXZlbiBpZiA8Y29kZT50YXVudXM8L2NvZGU+IGlzIGFuIGF1dG9tYXRlZCBjb2RlLWdlbmVyYXRpb24gdG9vbCwgaXQmIzM5O3Mgb3V0cHV0IGlzIGFzIGh1bWFuIHJlYWRhYmxlIGFzIGFueSBvdGhlciBtb2R1bGUuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctanNcXFwiPiYjMzk7dXNlIHN0cmljdCYjMzk7O1xcblxcbnZhciB0ZW1wbGF0ZXMgPSB7XFxuICAmIzM5O2hvbWUvaW5kZXgmIzM5OzogcmVxdWlyZSgmIzM5Oy4vdmlld3MvaG9tZS9pbmRleC5qcyYjMzk7KSxcXG4gICYjMzk7bGF5b3V0JiMzOTs6IHJlcXVpcmUoJiMzOTsuL3ZpZXdzL2xheW91dC5qcyYjMzk7KVxcbn07XFxuXFxudmFyIGNvbnRyb2xsZXJzID0ge1xcbn07XFxuXFxudmFyIHJvdXRlcyA9IFtcXG4gIHtcXG4gICAgcm91dGU6ICYjMzk7LyYjMzk7LFxcbiAgICBhY3Rpb246ICYjMzk7aG9tZS9pbmRleCYjMzk7XFxuICB9XFxuXTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIHRlbXBsYXRlczogdGVtcGxhdGVzLFxcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxcbiAgcm91dGVzOiByb3V0ZXNcXG59O1xcbjwvY29kZT48L3ByZT5cXG48cD48aW1nIHNyYz1cXFwiaHR0cDovL2kuaW1ndXIuY29tL2ZJRWU1VG0ucG5nXFxcIiBhbHQ9XFxcIlNjcmVlbnNob3Qgd2l0aCBgdGF1bnVzYCBvdXRwdXRcXFwiPjwvcD5cXG48cD5Ob3RlIHRoYXQgdGhlIDxjb2RlPmNvbnRyb2xsZXJzPC9jb2RlPiBvYmplY3QgaXMgZW1wdHkgYmVjYXVzZSB5b3UgaGF2ZW4mIzM5O3QgY3JlYXRlZCBhbnkgPGVtPmNsaWVudC1zaWRlIGNvbnRyb2xsZXJzPC9lbT4geWV0LiBXZSBjcmVhdGVkIHNlcnZlci1zaWRlIGNvbnRyb2xsZXJzIGJ1dCB0aG9zZSBkb24mIzM5O3QgaGF2ZSBhbnkgZWZmZWN0IGluIHRoZSBjbGllbnQtc2lkZSwgYmVzaWRlcyBkZXRlcm1pbmluZyB3aGF0IGdldHMgc2VudCB0byB0aGUgY2xpZW50LjwvcD5cXG48YmxvY2txdW90ZT5cXG48cD48c3Ryb25nPlRoZSBDTEkgY2FuIGJlIGVudGlyZWx5IGlnbm9yZWQ8L3N0cm9uZz4uIFlvdSBjb3VsZCB3cml0ZSB0aGVzZSBkZWZpbml0aW9ucyBieSB5b3Vyc2VsZiwgYnV0IHlvdSB3b3VsZCBoYXZlIHRvIHJlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgd2lyaW5nIG1vZHVsZSB3aGVuZXZlciB5b3UgYWRkLCBjaGFuZ2UsIG9yIHJlbW92ZSBhIHZpZXcsIGEgY2xpZW50LXNpZGUgY29udHJvbGxlciwgb3IgYSByb3V0ZS4gRG9pbmcgdGhhdCB3b3VsZCBiZSBjdW1iZXJzb21lLCBhbmQgdGhlIENMSSBzb2x2ZXMgdGhhdCBwcm9ibGVtIGZvciB1cyBhdCB0aGUgZXhwZW5zZSBvZiBvbmUgYWRkaXRpb25hbCBidWlsZCBzdGVwLjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+RHVyaW5nIGRldmVsb3BtZW50LCB5b3UgY2FuIGFsc28gYWRkIHRoZSA8Y29kZT4tLXdhdGNoPC9jb2RlPiBmbGFnLCB3aGljaCB3aWxsIHJlYnVpbGQgdGhlIHdpcmluZyBtb2R1bGUgaWYgYSByZWxldmFudCBmaWxlIGNoYW5nZXMuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPnRhdW51cyAtLW91dHB1dCAtLXdhdGNoXFxuPC9jb2RlPjwvcHJlPlxcbjxwPklmIHlvdSYjMzk7cmUgdXNpbmcgSGFwaSBpbnN0ZWFkIG9mIEV4cHJlc3MsIHlvdSYjMzk7bGwgYWxzbyBuZWVkIHRvIHBhc3MgaW4gdGhlIDxjb2RlPmhhcGlpZnk8L2NvZGU+IHRyYW5zZm9ybSBzbyB0aGF0IHJvdXRlcyBnZXQgY29udmVydGVkIGludG8gc29tZXRoaW5nIHRoZSBjbGllbnQtc2lkZSByb3V0aW5nIG1vZHVsZSB1bmRlcnN0YW5kLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj50YXVudXMgLS1vdXRwdXQgLS10cmFuc2Zvcm0gaGFwaWlmeVxcbjwvY29kZT48L3ByZT5cXG48cD5Ob3cgdGhhdCB5b3UgdW5kZXJzdGFuZCBob3cgdG8gdXNlIHRoZSBDTEkgb3IgYnVpbGQgdGhlIHdpcmluZyBtb2R1bGUgb24geW91ciBvd24sIGJvb3RpbmcgdXAgVGF1bnVzIG9uIHRoZSBjbGllbnQtc2lkZSB3aWxsIGJlIGFuIGVhc3kgdGhpbmcgdG8gZG8hPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwiYm9vdGluZy11cC10aGUtY2xpZW50LXNpZGUtcm91dGVyXFxcIj5Cb290aW5nIHVwIHRoZSBjbGllbnQtc2lkZSByb3V0ZXI8L2g0PlxcbjxwPk9uY2Ugd2UgaGF2ZSB0aGUgd2lyaW5nIG1vZHVsZSwgYm9vdGluZyB1cCB0aGUgY2xpZW50LXNpZGUgZW5naW5lIGlzIHByZXR0eSBlYXN5LiBUYXVudXMgc3VnZ2VzdHMgeW91IHVzZSA8Y29kZT5jbGllbnQvanM8L2NvZGU+IHRvIGtlZXAgYWxsIG9mIHlvdXIgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCBsb2dpYywgYnV0IHRoYXQgaXMgdXAgdG8geW91IHRvby4gRm9yIHRoZSBzYWtlIG9mIHRoaXMgZ3VpZGUsIGxldCYjMzk7cyBzdGljayB0byB0aGUgY29udmVudGlvbnMuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPm1rZGlyIC1wIGNsaWVudC9qc1xcbnRvdWNoIGNsaWVudC9qcy9tYWluLmpzXFxuPC9jb2RlPjwvcHJlPlxcbjxwPlRoZSA8Y29kZT5tYWluPC9jb2RlPiBtb2R1bGUgd2lsbCBiZSB1c2VkIGFzIHRoZSA8ZW0+ZW50cnkgcG9pbnQ8L2VtPiBvZiB5b3VyIGFwcGxpY2F0aW9uIG9uIHRoZSBjbGllbnQtc2lkZS4gSGVyZSB5b3UmIzM5O2xsIG5lZWQgdG8gaW1wb3J0IDxjb2RlPnRhdW51czwvY29kZT4sIHRoZSB3aXJpbmcgbW9kdWxlIHdlJiMzOTt2ZSBqdXN0IGJ1aWx0LCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIERPTSBlbGVtZW50IHdoZXJlIHlvdSBhcmUgcmVuZGVyaW5nIHlvdXIgcGFydGlhbCB2aWV3cy4gT25jZSB5b3UgaGF2ZSBhbGwgdGhhdCwgeW91IGNhbiBpbnZva2UgPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPi48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxudmFyIHRhdW51cyA9IHJlcXVpcmUoJiMzOTt0YXVudXMmIzM5Oyk7XFxudmFyIHdpcmluZyA9IHJlcXVpcmUoJiMzOTsuLi8uLi8uYmluL3dpcmluZyYjMzk7KTtcXG52YXIgbWFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCYjMzk7bWFpbiYjMzk7KVswXTtcXG5cXG50YXVudXMubW91bnQobWFpbiwgd2lyaW5nKTtcXG48L2NvZGU+PC9wcmU+XFxuPHA+VGhlIG1vdW50cG9pbnQgd2lsbCBzZXQgdXAgdGhlIGNsaWVudC1zaWRlIFRhdW51cyByb3V0ZXIgYW5kIGZpcmUgdGhlIGNsaWVudC1zaWRlIHZpZXcgY29udHJvbGxlciBmb3IgdGhlIHZpZXcgdGhhdCBoYXMgYmVlbiByZW5kZXJlZCBpbiB0aGUgc2VydmVyLXNpZGUuIFdoZW5ldmVyIGFuIGFuY2hvciBsaW5rIGlzIGNsaWNrZWQsIFRhdW51cyB3aWxsIGJlIGFibGUgdG8gaGlqYWNrIHRoYXQgY2xpY2sgYW5kIHJlcXVlc3QgdGhlIG1vZGVsIHVzaW5nIEFKQVgsIGJ1dCBvbmx5IGlmIGl0IG1hdGNoZXMgYSB2aWV3IHJvdXRlLiBPdGhlcndpc2UgdGhlIGxpbmsgd2lsbCBiZWhhdmUganVzdCBsaWtlIGFueSBub3JtYWwgbGluayB3b3VsZC48L3A+XFxuPHA+QnkgZGVmYXVsdCwgdGhlIG1vdW50cG9pbnQgd2lsbCBpc3N1ZSBhbiBBSkFYIHJlcXVlc3QgZm9yIHRoZSB2aWV3IG1vZGVsIG9mIHRoZSBzZXJ2ZXItc2lkZSByZW5kZXJlZCB2aWV3LiBUaGlzIGlzIGFraW4gdG8gd2hhdCBkZWRpY2F0ZWQgY2xpZW50LXNpZGUgcmVuZGVyaW5nIGZyYW1ld29ya3Mgc3VjaCBhcyBBbmd1bGFySlMgZG8sIHdoZXJlIHZpZXdzIGFyZSBvbmx5IHJlbmRlcmVkIGFmdGVyIGFsbCB0aGUgSmF2YVNjcmlwdCBoYXMgYmVlbiBkb3dubG9hZGVkLCBwYXJzZWQsIGFuZCBleGVjdXRlZC4gRXhjZXB0IFRhdW51cyBwcm92aWRlcyBodW1hbi1yZWFkYWJsZSBjb250ZW50IGZhc3RlciwgYmVmb3JlIHRoZSBKYXZhU2NyaXB0IGV2ZW4gYmVnaW5zIGRvd25sb2FkaW5nLCBhbHRob3VnaCBpdCB3b24mIzM5O3QgYmUgZnVuY3Rpb25hbCB1bnRpbCB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlciBydW5zLjwvcD5cXG48cD5BbiBhbHRlcm5hdGl2ZSBpcyB0byBpbmxpbmUgdGhlIHZpZXcgbW9kZWwgYWxvbmdzaWRlIHRoZSB2aWV3cyBpbiBhIDxjb2RlPiZsdDtzY3JpcHQgdHlwZT0mIzM5O3RleHQvdGF1bnVzJiMzOTsmZ3Q7PC9jb2RlPiB0YWcsIGJ1dCB0aGlzIHRlbmRzIHRvIHNsb3cgZG93biB0aGUgaW5pdGlhbCByZXNwb25zZSAobW9kZWxzIGFyZSA8ZW0+dHlwaWNhbGx5IGxhcmdlcjwvZW0+IHRoYW4gdGhlIHJlc3VsdGluZyB2aWV3cykuPC9wPlxcbjxwPkEgdGhpcmQgc3RyYXRlZ3kgaXMgdGhhdCB5b3UgcmVxdWVzdCB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgb3V0c2lkZSBvZiBUYXVudXMsIGFsbG93aW5nIHlvdSB0byBmZXRjaCBib3RoIHRoZSB2aWV3IG1vZGVsIGFuZCBUYXVudXMgaXRzZWxmIGNvbmN1cnJlbnRseSwgYnV0IHRoYXQmIzM5O3MgaGFyZGVyIHRvIHNldCB1cC48L3A+XFxuPHA+VGhlIHRocmVlIGJvb3Rpbmcgc3RyYXRlZ2llcyBhcmUgZXhwbGFpbmVkIGluIDxhIGhyZWY9XFxcIi9hcGlcXFwiPnRoZSBBUEkgZG9jdW1lbnRhdGlvbjwvYT4gYW5kIGZ1cnRoZXIgZGlzY3Vzc2VkIGluIDxhIGhyZWY9XFxcIi9wZXJmb3JtYW5jZVxcXCI+dGhlIG9wdGltaXphdGlvbiBndWlkZTwvYT4uIEZvciBub3csIHRoZSBkZWZhdWx0IHN0cmF0ZWd5IDxlbT4oPGNvZGU+JiMzOTthdXRvJiMzOTs8L2NvZGU+KTwvZW0+IHNob3VsZCBzdWZmaWNlLiBJdCBmZXRjaGVzIHRoZSB2aWV3IG1vZGVsIHVzaW5nIGFuIEFKQVggcmVxdWVzdCByaWdodCBhZnRlciBUYXVudXMgbG9hZHMuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwiYWRkaW5nLWZ1bmN0aW9uYWxpdHktaW4tYS1jbGllbnQtc2lkZS1jb250cm9sbGVyXFxcIj5BZGRpbmcgZnVuY3Rpb25hbGl0eSBpbiBhIGNsaWVudC1zaWRlIGNvbnRyb2xsZXI8L2g0PlxcbjxwPkNsaWVudC1zaWRlIGNvbnRyb2xsZXJzIHJ1biB3aGVuZXZlciBhIHZpZXcgaXMgcmVuZGVyZWQsIGV2ZW4gaWYgaXQmIzM5O3MgYSBwYXJ0aWFsLiBUaGUgY29udHJvbGxlciBpcyBwYXNzZWQgdGhlIDxjb2RlPm1vZGVsPC9jb2RlPiwgY29udGFpbmluZyB0aGUgbW9kZWwgdGhhdCB3YXMgdXNlZCB0byByZW5kZXIgdGhlIHZpZXc7IHRoZSA8Y29kZT5yb3V0ZTwvY29kZT4sIGJyb2tlbiBkb3duIGludG8gaXRzIGNvbXBvbmVudHM7IGFuZCB0aGUgPGNvZGU+Y29udGFpbmVyPC9jb2RlPiwgd2hpY2ggaXMgd2hhdGV2ZXIgRE9NIGVsZW1lbnQgdGhlIHZpZXcgd2FzIHJlbmRlcmVkIGludG8uPC9wPlxcbjxwPlRoZXNlIGNvbnRyb2xsZXJzIGFyZSBlbnRpcmVseSBvcHRpb25hbCwgd2hpY2ggbWFrZXMgc2Vuc2Ugc2luY2Ugd2UmIzM5O3JlIHByb2dyZXNzaXZlbHkgZW5oYW5jaW5nIHRoZSBhcHBsaWNhdGlvbjogaXQgbWlnaHQgbm90IGV2ZW4gYmUgbmVjZXNzYXJ5ISBMZXQmIzM5O3MgYWRkIHNvbWUgY2xpZW50LXNpZGUgZnVuY3Rpb25hbGl0eSB0byB0aGUgZXhhbXBsZSB3ZSYjMzk7dmUgYmVlbiBidWlsZGluZy48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bWtkaXIgLXAgY2xpZW50L2pzL2NvbnRyb2xsZXJzL2hvbWVcXG50b3VjaCBjbGllbnQvanMvY29udHJvbGxlcnMvaG9tZS9pbmRleC5qc1xcbjwvY29kZT48L3ByZT5cXG48cD5HdWVzcyB3aGF0PyBUaGUgY29udHJvbGxlciBzaG91bGQgYmUgYSBtb2R1bGUgd2hpY2ggZXhwb3J0cyBhIGZ1bmN0aW9uLiBUaGF0IGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHJlbmRlcmVkLiBGb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eSB3ZSYjMzk7bGwganVzdCBwcmludCB0aGUgYWN0aW9uIGFuZCB0aGUgbW9kZWwgdG8gdGhlIGNvbnNvbGUuIElmIHRoZXJlJiMzOTtzIG9uZSBwbGFjZSB3aGVyZSB5b3UmIzM5O2Qgd2FudCB0byBlbmhhbmNlIHRoZSBleHBlcmllbmNlLCBjbGllbnQtc2lkZSBjb250cm9sbGVycyBhcmUgd2hlcmUgeW91IHdhbnQgdG8gcHV0IHlvdXIgY29kZS48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1qc1xcXCI+JiMzOTt1c2Ugc3RyaWN0JiMzOTs7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRhaW5lciwgcm91dGUpIHtcXG4gIGNvbnNvbGUubG9nKCYjMzk7UmVuZGVyZWQgdmlldyAlcyB1c2luZyBtb2RlbDpcXFxcbiVzJiMzOTssIHJvdXRlLmFjdGlvbiwgSlNPTi5zdHJpbmdpZnkobW9kZWwsIG51bGwsIDIpKTtcXG59O1xcbjwvY29kZT48L3ByZT5cXG48cD5TaW5jZSB3ZSB3ZXJlbiYjMzk7dCB1c2luZyB0aGUgPGNvZGU+LS13YXRjaDwvY29kZT4gZmxhZyBmcm9tIHRoZSBUYXVudXMgQ0xJLCB5b3UmIzM5O2xsIGhhdmUgdG8gcmVjb21waWxlIHRoZSB3aXJpbmcgYXQgdGhpcyBwb2ludCwgc28gdGhhdCB0aGUgY29udHJvbGxlciBnZXRzIGFkZGVkIHRvIHRoYXQgbWFuaWZlc3QuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPnRhdW51cyAtLW91dHB1dFxcbjwvY29kZT48L3ByZT5cXG48cD5PZiBjb3Vyc2UsIHlvdSYjMzk7bGwgbm93IGhhdmUgdG8gd2lyZSB1cCB0aGUgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCB1c2luZyA8YSBocmVmPVxcXCJodHRwOi8vYnJvd3NlcmlmeS5vcmcvXFxcIj5Ccm93c2VyaWZ5PC9hPiE8L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGg0IGlkPVxcXCJjb21waWxpbmcteW91ci1jbGllbnQtc2lkZS1qYXZhc2NyaXB0XFxcIj5Db21waWxpbmcgeW91ciBjbGllbnQtc2lkZSBKYXZhU2NyaXB0PC9oND5cXG48cD5Zb3UmIzM5O2xsIG5lZWQgdG8gY29tcGlsZSB0aGUgPGNvZGU+Y2xpZW50L2pzL21haW4uanM8L2NvZGU+IG1vZHVsZSwgb3VyIGNsaWVudC1zaWRlIGFwcGxpY2F0aW9uJiMzOTtzIGVudHJ5IHBvaW50LCB1c2luZyBCcm93c2VyaWZ5IHNpbmNlIHRoZSBjb2RlIGlzIHdyaXR0ZW4gdXNpbmcgQ29tbW9uSlMuIEluIHRoaXMgZXhhbXBsZSB5b3UmIzM5O2xsIGluc3RhbGwgPGNvZGU+YnJvd3NlcmlmeTwvY29kZT4gZ2xvYmFsbHkgdG8gY29tcGlsZSB0aGUgY29kZSwgYnV0IG5hdHVyYWxseSB5b3UmIzM5O2xsIGluc3RhbGwgaXQgbG9jYWxseSB3aGVuIHdvcmtpbmcgb24gYSByZWFsLXdvcmxkIGFwcGxpY2F0aW9uLjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLXNoZWxsXFxcIj5ucG0gaW5zdGFsbCAtLWdsb2JhbCBicm93c2VyaWZ5XFxuPC9jb2RlPjwvcHJlPlxcbjxwPk9uY2UgeW91IGhhdmUgdGhlIEJyb3dzZXJpZnkgQ0xJLCB5b3UmIzM5O2xsIGJlIGFibGUgdG8gY29tcGlsZSB0aGUgY29kZSByaWdodCBmcm9tIHlvdXIgY29tbWFuZCBsaW5lLiBUaGUgPGNvZGU+LWQ8L2NvZGU+IGZsYWcgdGVsbHMgQnJvd3NlcmlmeSB0byBhZGQgYW4gaW5saW5lIHNvdXJjZSBtYXAgaW50byB0aGUgY29tcGlsZWQgYnVuZGxlLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBmb3IgdXMuIFRoZSA8Y29kZT4tbzwvY29kZT4gZmxhZyByZWRpcmVjdHMgb3V0cHV0IHRvIHRoZSBpbmRpY2F0ZWQgZmlsZSwgd2hlcmVhcyB0aGUgb3V0cHV0IGlzIHByaW50ZWQgdG8gc3RhbmRhcmQgb3V0cHV0IGJ5IGRlZmF1bHQuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPm1rZGlyIC1wIC5iaW4vcHVibGljL2pzXFxuYnJvd3NlcmlmeSBjbGllbnQvanMvbWFpbi5qcyAtZG8gLmJpbi9wdWJsaWMvanMvYWxsLmpzXFxuPC9jb2RlPjwvcHJlPlxcbjxwPldlIGhhdmVuJiMzOTt0IGRvbmUgbXVjaCBvZiBhbnl0aGluZyB3aXRoIHRoZSBFeHByZXNzIGFwcGxpY2F0aW9uLCBzbyB5b3UmIzM5O2xsIG5lZWQgdG8gYWRqdXN0IHRoZSA8Y29kZT5hcHAuanM8L2NvZGU+IG1vZHVsZSB0byBzZXJ2ZSBzdGF0aWMgYXNzZXRzLiBJZiB5b3UmIzM5O3JlIHVzZWQgdG8gRXhwcmVzcywgeW91JiMzOTtsbCBub3RpY2UgdGhlcmUmIzM5O3Mgbm90aGluZyBzcGVjaWFsIGFib3V0IGhvdyB3ZSYjMzk7cmUgdXNpbmcgPGNvZGU+c2VydmUtc3RhdGljPC9jb2RlPi48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+bnBtIGluc3RhbGwgLS1zYXZlIHNlcnZlLXN0YXRpY1xcbjwvY29kZT48L3ByZT5cXG48cD5MZXQmIzM5O3MgY29uZmlndXJlIHRoZSBhcHBsaWNhdGlvbiB0byBzZXJ2ZSBzdGF0aWMgYXNzZXRzIGZyb20gPGNvZGU+LmJpbi9wdWJsaWM8L2NvZGU+LjwvcD5cXG48cHJlPjxjb2RlIGNsYXNzPVxcXCJsYW5nLWpzXFxcIj4mIzM5O3VzZSBzdHJpY3QmIzM5OztcXG5cXG52YXIgdGF1bnVzID0gcmVxdWlyZSgmIzM5O3RhdW51cyYjMzk7KTtcXG52YXIgdGF1bnVzRXhwcmVzcyA9IHJlcXVpcmUoJiMzOTt0YXVudXMtZXhwcmVzcyYjMzk7KTtcXG52YXIgZXhwcmVzcyA9IHJlcXVpcmUoJiMzOTtleHByZXNzJiMzOTspO1xcbnZhciBzZXJ2ZVN0YXRpYyA9IHJlcXVpcmUoJiMzOTtzZXJ2ZS1zdGF0aWMmIzM5Oyk7XFxudmFyIGFwcCA9IGV4cHJlc3MoKTtcXG52YXIgb3B0aW9ucyA9IHtcXG4gIHJvdXRlczogcmVxdWlyZSgmIzM5Oy4vY29udHJvbGxlcnMvcm91dGVzJiMzOTspLFxcbiAgbGF5b3V0OiByZXF1aXJlKCYjMzk7Li8uYmluL3ZpZXdzL2xheW91dCYjMzk7KVxcbn07XFxuXFxuYXBwLnVzZShzZXJ2ZVN0YXRpYygmIzM5Oy5iaW4vcHVibGljJiMzOTspKTtcXG50YXVudXNFeHByZXNzKHRhdW51cywgYXBwLCBvcHRpb25zKTtcXG5hcHAubGlzdGVuKDMwMDApO1xcbjwvY29kZT48L3ByZT5cXG48cD5OZXh0IHVwLCB5b3UmIzM5O2xsIGhhdmUgdG8gZWRpdCB0aGUgbGF5b3V0IHRvIGluY2x1ZGUgdGhlIGNvbXBpbGVkIEphdmFTY3JpcHQgYnVuZGxlIGZpbGUuPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctamFkZVxcXCI+dGl0bGU9bW9kZWwudGl0bGVcXG5tYWluIT1wYXJ0aWFsXFxuc2NyaXB0KHNyYz0mIzM5Oy9qcy9hbGwuanMmIzM5OylcXG48L2NvZGU+PC9wcmU+XFxuPHA+RG9uJiMzOTt0IGZvcmdldCB0byBjb21waWxlIDxjb2RlPmxheW91dC5qYWRlPC9jb2RlPiBhZ2Fpbi48L3A+XFxuPHByZT48Y29kZSBjbGFzcz1cXFwibGFuZy1zaGVsbFxcXCI+amFkdW0gdmlld3MvKiogLS1vdXRwdXQgLmJpblxcbjwvY29kZT48L3ByZT5cXG48cD5MYXN0bHksIHlvdSBjYW4gZXhlY3V0ZSB0aGUgYXBwbGljYXRpb24gYW5kIHNlZSBpdCBpbiBhY3Rpb24hPC9wPlxcbjxwcmU+PGNvZGUgY2xhc3M9XFxcImxhbmctc2hlbGxcXFwiPm5vZGUgYXBwXFxuPC9jb2RlPjwvcHJlPlxcbjxwPjxpbWcgc3JjPVxcXCJodHRwOi8vaS5pbWd1ci5jb20vNjhPODR3WC5wbmdcXFwiIGFsdD1cXFwiU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgb3V0cHV0XFxcIj48L3A+XFxuPHA+SWYgeW91IG9wZW4gdGhlIGFwcGxpY2F0aW9uIG9uIGEgd2ViIGJyb3dzZXIsIHlvdSYjMzk7bGwgbm90aWNlIHRoYXQgdGhlIGFwcHJvcHJpYXRlIGluZm9ybWF0aW9uIHdpbGwgYmUgbG9nZ2VkIGludG8gdGhlIGRldmVsb3BlciA8Y29kZT5jb25zb2xlPC9jb2RlPi48L3A+XFxuPHA+PGltZyBzcmM9XFxcImh0dHA6Ly9pLmltZ3VyLmNvbS9aVUY2TkZsLnBuZ1xcXCIgYWx0PVxcXCJTY3JlZW5zaG90IHdpdGggdGhlIGFwcGxpY2F0aW9uIHJ1bm5pbmcgdW5kZXIgR29vZ2xlIENocm9tZVxcXCI+PC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwidXNpbmctdGhlLWNsaWVudC1zaWRlLXRhdW51cy1hcGlcXFwiPlVzaW5nIHRoZSBjbGllbnQtc2lkZSBUYXVudXMgQVBJPC9oND5cXG48cD5UYXVudXMgZG9lcyBwcm92aWRlIDxhIGhyZWY9XFxcIi9hcGlcXFwiPmEgdGhpbiBBUEk8L2E+IGluIHRoZSBjbGllbnQtc2lkZS4gVXNhZ2Ugb2YgdGhhdCBBUEkgYmVsb25ncyBtb3N0bHkgaW5zaWRlIHRoZSBib2R5IG9mIGNsaWVudC1zaWRlIHZpZXcgY29udHJvbGxlcnMsIGJ1dCB0aGVyZSYjMzk7cyBhIGZldyBtZXRob2RzIHlvdSBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2Ygb24gYSBnbG9iYWwgc2NhbGUgYXMgd2VsbC48L3A+XFxuPHA+VGF1bnVzIGNhbiBub3RpZnkgeW91IHdoZW5ldmVyIGltcG9ydGFudCBldmVudHMgb2NjdXIuPC9wPlxcbjx0YWJsZT5cXG48dGhlYWQ+XFxuPHRyPlxcbjx0aD5FdmVudDwvdGg+XFxuPHRoPkFyZ3VtZW50czwvdGg+XFxuPHRoPkRlc2NyaXB0aW9uPC90aD5cXG48L3RyPlxcbjwvdGhlYWQ+XFxuPHRib2R5Plxcbjx0cj5cXG48dGQ+PGNvZGU+JiMzOTtzdGFydCYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPmNvbnRhaW5lciwgbW9kZWwsIHJvdXRlPC9jb2RlPjwvdGQ+XFxuPHRkPkVtaXR0ZWQgd2hlbiA8Y29kZT50YXVudXMubW91bnQ8L2NvZGU+IGZpbmlzaGVkIHRoZSByb3V0ZSBzZXR1cCBhbmQgaXMgYWJvdXQgdG8gaW52b2tlIHRoZSBjbGllbnQtc2lkZSBjb250cm9sbGVyLiBTdWJzY3JpYmUgdG8gdGhpcyBldmVudCBiZWZvcmUgY2FsbGluZyA8Y29kZT50YXVudXMubW91bnQ8L2NvZGU+LjwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7cmVuZGVyJiMzOTs8L2NvZGU+PC90ZD5cXG48dGQ+PGNvZGU+Y29udGFpbmVyLCBtb2RlbCwgcm91dGU8L2NvZGU+PC90ZD5cXG48dGQ+QSB2aWV3IGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQgYW5kIGl0cyBjbGllbnQtc2lkZSBjb250cm9sbGVyIGlzIGFib3V0IHRvIGJlIGludm9rZWQ8L3RkPlxcbjwvdHI+XFxuPHRyPlxcbjx0ZD48Y29kZT4mIzM5O2NoYW5nZSYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPnJvdXRlLCBtb2RlbDwvY29kZT48L3RkPlxcbjx0ZD5TYW1lIGFzIDxjb2RlPiYjMzk7cmVuZGVyJiMzOTs8L2NvZGU+LCBidXQgb25seSBpZiA8Y29kZT5jb250YWluZXI8L2NvZGU+IGlzIHRoZSBtb3VudHBvaW50IGFuZCB0aGUgcm91dGUgaGFzIGNoYW5nZWQuPC90ZD5cXG48L3RyPlxcbjx0cj5cXG48dGQ+PGNvZGU+JiMzOTtmZXRjaC5zdGFydCYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPnJvdXRlLCBjb250ZXh0PC9jb2RlPjwvdGQ+XFxuPHRkPkVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3Qgc3RhcnRzLjwvdGQ+XFxuPC90cj5cXG48dHI+XFxuPHRkPjxjb2RlPiYjMzk7ZmV0Y2guZG9uZSYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPnJvdXRlLCBjb250ZXh0LCBkYXRhPC9jb2RlPjwvdGQ+XFxuPHRkPkVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3QgZW5kcyBzdWNjZXNzZnVsbHkuPC90ZD5cXG48L3RyPlxcbjx0cj5cXG48dGQ+PGNvZGU+JiMzOTtmZXRjaC5hYm9ydCYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPnJvdXRlLCBjb250ZXh0PC9jb2RlPjwvdGQ+XFxuPHRkPkVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3QgaXMgcHVycG9zZWx5IGFib3J0ZWQuPC90ZD5cXG48L3RyPlxcbjx0cj5cXG48dGQ+PGNvZGU+JiMzOTtmZXRjaC5lcnJvciYjMzk7PC9jb2RlPjwvdGQ+XFxuPHRkPjxjb2RlPnJvdXRlLCBjb250ZXh0LCBlcnI8L2NvZGU+PC90ZD5cXG48dGQ+RW1pdHRlZCB3aGVuZXZlciBhbiBYSFIgcmVxdWVzdCByZXN1bHRzIGluIGFuIEhUVFAgZXJyb3IuPC90ZD5cXG48L3RyPlxcbjwvdGJvZHk+XFxuPC90YWJsZT5cXG48cD5CZXNpZGVzIGV2ZW50cywgdGhlcmUmIzM5O3MgYSBjb3VwbGUgbW9yZSBtZXRob2RzIHlvdSBjYW4gdXNlLiBUaGUgPGNvZGU+dGF1bnVzLm5hdmlnYXRlPC9jb2RlPiBtZXRob2QgYWxsb3dzIHlvdSB0byBuYXZpZ2F0ZSB0byBhIFVSTCB3aXRob3V0IHRoZSBuZWVkIGZvciBhIGh1bWFuIHRvIGNsaWNrIG9uIGFuIGFuY2hvciBsaW5rLiBUaGVuIHRoZXJlJiMzOTtzIDxjb2RlPnRhdW51cy5wYXJ0aWFsPC9jb2RlPiwgYW5kIHRoYXQgYWxsb3dzIHlvdSB0byByZW5kZXIgYW55IHBhcnRpYWwgdmlldyBvbiBhIERPTSBlbGVtZW50IG9mIHlvdXIgY2hvb3NpbmcsIGFuZCBpdCYjMzk7bGwgdGhlbiBpbnZva2UgaXRzIGNvbnRyb2xsZXIuIFlvdSYjMzk7bGwgbmVlZCB0byBjb21lIHVwIHdpdGggdGhlIG1vZGVsIHlvdXJzZWxmLCB0aG91Z2guPC9wPlxcbjxwPkFzdG9uaXNoaW5nbHksIHRoZSBBUEkgaXMgZnVydGhlciBkb2N1bWVudGVkIGluIDxhIGhyZWY9XFxcIi9hcGlcXFwiPnRoZSBBUEkgZG9jdW1lbnRhdGlvbjwvYT4uPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI3RhYmxlLW9mLWNvbnRlbnRzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoNCBpZD1cXFwiY2FjaGluZy1hbmQtcHJlZmV0Y2hpbmdcXFwiPkNhY2hpbmcgYW5kIFByZWZldGNoaW5nPC9oND5cXG48cD48YSBocmVmPVxcXCIvcGVyZm9ybWFuY2VcXFwiPlBlcmZvcm1hbmNlPC9hPiBwbGF5cyBhbiBpbXBvcnRhbnQgcm9sZSBpbiBUYXVudXMuIFRoYXQmIzM5O3Mgd2h5IHRoZSB5b3UgY2FuIHBlcmZvcm0gY2FjaGluZyBhbmQgcHJlZmV0Y2hpbmcgb24gdGhlIGNsaWVudC1zaWRlIGp1c3QgYnkgdHVybmluZyBvbiBhIHBhaXIgb2YgZmxhZ3MuIEJ1dCB3aGF0IGRvIHRoZXNlIGZsYWdzIGRvIGV4YWN0bHk/PC9wPlxcbjxwPldoZW4gdHVybmVkIG9uLCBieSBwYXNzaW5nIDxjb2RlPnsgY2FjaGU6IHRydWUgfTwvY29kZT4gYXMgdGhlIHRoaXJkIHBhcmFtZXRlciBmb3IgPGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPiwgdGhlIGNhY2hpbmcgbGF5ZXIgd2lsbCBtYWtlIHN1cmUgdGhhdCByZXNwb25zZXMgYXJlIGtlcHQgYXJvdW5kIGZvciA8Y29kZT4xNTwvY29kZT4gc2Vjb25kcy4gV2hlbmV2ZXIgYSByb3V0ZSBuZWVkcyBhIG1vZGVsIGluIG9yZGVyIHRvIHJlbmRlciBhIHZpZXcsIGl0JiMzOTtsbCBmaXJzdCBhc2sgdGhlIGNhY2hpbmcgbGF5ZXIgZm9yIGEgZnJlc2ggY29weS4gSWYgdGhlIGNhY2hpbmcgbGF5ZXIgZG9lc24mIzM5O3QgaGF2ZSBhIGNvcHksIG9yIGlmIHRoYXQgY29weSBpcyBzdGFsZSA8ZW0+KGluIHRoaXMgY2FzZSwgb2xkZXIgdGhhbiA8Y29kZT4xNTwvY29kZT4gc2Vjb25kcyk8L2VtPiwgdGhlbiBhbiBBSkFYIHJlcXVlc3Qgd2lsbCBiZSBpc3N1ZWQgdG8gdGhlIHNlcnZlci4gT2YgY291cnNlLCB0aGUgZHVyYXRpb24gaXMgY29uZmlndXJhYmxlLiBJZiB5b3Ugd2FudCB0byB1c2UgYSB2YWx1ZSBvdGhlciB0aGFuIHRoZSBkZWZhdWx0LCB5b3Ugc2hvdWxkIHNldCA8Y29kZT5jYWNoZTwvY29kZT4gdG8gYSBudW1iZXIgaW4gc2Vjb25kcyBpbnN0ZWFkIG9mIGp1c3QgPGNvZGU+dHJ1ZTwvY29kZT4uPC9wPlxcbjxwPlNpbmNlIFRhdW51cyB1bmRlcnN0YW5kcyB0aGF0IG5vdCBldmVyeSB2aWV3IG9wZXJhdGVzIHVuZGVyIHRoZSBzYW1lIGNvbnN0cmFpbnRzLCB5b3UmIzM5O3JlIGFsc28gYWJsZSB0byBzZXQgYSA8Y29kZT5jYWNoZTwvY29kZT4gZnJlc2huZXNzIGR1cmF0aW9uIGRpcmVjdGx5IGluIHlvdXIgcm91dGVzLiBUaGUgPGNvZGU+Y2FjaGU8L2NvZGU+IHByb3BlcnR5IGluIHJvdXRlcyBoYXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IHZhbHVlLjwvcD5cXG48cD5UaGVyZSYjMzk7cyBjdXJyZW50bHkgdHdvIGNhY2hpbmcgc3RvcmVzOiBhIHJhdyBpbi1tZW1vcnkgc3RvcmUsIGFuZCBhbiA8YSBocmVmPVxcXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSVxcXCI+SW5kZXhlZERCPC9hPiBzdG9yZS4gSW5kZXhlZERCIGlzIGFuIGVtYmVkZGVkIGRhdGFiYXNlIHNvbHV0aW9uLCBhbmQgeW91IGNhbiB0aGluayBvZiBpdCBsaWtlIGFuIGFzeW5jaHJvbm91cyB2ZXJzaW9uIG9mIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4uIEl0IGhhcyA8YSBocmVmPVxcXCJodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9aW5kZXhlZGRiXFxcIj5zdXJwcmlzaW5nbHkgYnJvYWQgYnJvd3NlciBzdXBwb3J0PC9hPiwgYW5kIGluIHRoZSBjYXNlcyB3aGVyZSBpdCYjMzk7cyBub3Qgc3VwcG9ydGVkIHRoZW4gY2FjaGluZyBpcyBkb25lIHNvbGVseSBpbi1tZW1vcnkuPC9wPlxcbjxwPlRoZSBwcmVmZXRjaGluZyBtZWNoYW5pc20gaXMgYW4gaW50ZXJlc3Rpbmcgc3Bpbi1vZmYgb2YgY2FjaGluZywgYW5kIGl0IHJlcXVpcmVzIGNhY2hpbmcgdG8gYmUgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrLiBXaGVuZXZlciBodW1hbnMgaG92ZXIgb3ZlciBhIGxpbmssIG9yIHdoZW5ldmVyIHRoZXkgcHV0IHRoZWlyIGZpbmdlciBvbiBvbmUgb2YgdGhlbSA8ZW0+KHRoZSA8Y29kZT50b3VjaHN0YXJ0PC9jb2RlPiBldmVudCk8L2VtPiwgdGhlIHByZWZldGNoZXIgd2lsbCBpc3N1ZSBhbiBBSkFYIHJlcXVlc3QgZm9yIHRoZSB2aWV3IG1vZGVsIGZvciB0aGF0IGxpbmsuPC9wPlxcbjxwPklmIHRoZSByZXF1ZXN0IGVuZHMgc3VjY2Vzc2Z1bGx5IHRoZW4gdGhlIHJlc3BvbnNlIHdpbGwgYmUgY2FjaGVkIGluIHRoZSBzYW1lIHdheSBhbnkgb3RoZXIgdmlldyB3b3VsZCBiZSBjYWNoZWQuIElmIHRoZSBodW1hbiBob3ZlcnMgb3ZlciBhbm90aGVyIGxpbmsgd2hpbGUgdGhlIHByZXZpb3VzIG9uZSBpcyBzdGlsbCBiZWluZyBwcmVmZXRjaGVkLCB0aGVuIHRoZSBvbGQgcmVxdWVzdCBpcyBhYm9ydGVkLCBhcyBub3QgdG8gZHJhaW4gdGhlaXIgPGVtPihwb3NzaWJseSBsaW1pdGVkKTwvZW0+IEludGVybmV0IGNvbm5lY3Rpb24gYmFuZHdpZHRoLjwvcD5cXG48cD5JZiB0aGUgaHVtYW4gY2xpY2tzIG9uIHRoZSBsaW5rIGJlZm9yZSBwcmVmZXRjaGluZyBpcyBjb21wbGV0ZWQsIGhlJiMzOTtsbCBuYXZpZ2F0ZSB0byB0aGUgdmlldyBhcyBzb29uIGFzIHByZWZldGNoaW5nIGVuZHMsIHJhdGhlciB0aGFuIGZpcmluZyBhbm90aGVyIHJlcXVlc3QuIFRoaXMgaGVscHMgVGF1bnVzIHNhdmUgcHJlY2lvdXMgbWlsbGlzZWNvbmRzIHdoZW4gZGVhbGluZyB3aXRoIGxhdGVuY3ktc2Vuc2l0aXZlIG9wZXJhdGlvbnMuPC9wPlxcbjxwPlR1cm5pbmcgcHJlZmV0Y2hpbmcgb24gaXMgc2ltcGx5IGEgbWF0dGVyIG9mIHNldHRpbmcgPGNvZGU+cHJlZmV0Y2g8L2NvZGU+IHRvIDxjb2RlPnRydWU8L2NvZGU+IGluIHRoZSBvcHRpb25zIHBhc3NlZCB0byA8Y29kZT50YXVudXMubW91bnQ8L2NvZGU+LiBGb3IgYWRkaXRpb25hbCBpbnNpZ2h0cyBpbnRvIHRoZSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgVGF1bnVzIGNhbiBvZmZlciwgaGVhZCBvdmVyIHRvIHRoZSA8YSBocmVmPVxcXCIvcGVyZm9ybWFuY2VcXFwiPlBlcmZvcm1hbmNlIE9wdGltaXphdGlvbnM8L2E+IGd1aWRlLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiN0YWJsZS1vZi1jb250ZW50c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG48aDQgaWQ9XFxcInZlcnNpb25pbmdcXFwiPlZlcnNpb25pbmc8L2g0PlxcbjxwPldoZW4geW91IGFsdGVyIHlvdXIgdmlld3MsIGNoYW5nZSBjb250cm9sbGVycywgb3IgbW9kaWZ5IHRoZSBtb2RlbHMsIGNoYW5jZXMgYXJlIHRoZSBjbGllbnQtc2lkZSBpcyBnb2luZyB0byBjb21lIGFjcm9zcyBvbmUgb2YgdGhlIGZvbGxvd2luZyBpc3N1ZXMuPC9wPlxcbjx1bD5cXG48bGk+T3V0ZGF0ZWQgdmlldyB0ZW1wbGF0ZSBmdW5jdGlvbnMgaW4gdGhlIGNsaWVudC1zaWRlLCBjYXVzaW5nIG5ldyBtb2RlbHMgdG8gYnJlYWs8L2xpPlxcbjxsaT5PdXRkYXRlZCBjbGllbnQtc2lkZSBjb250cm9sbGVycywgY2F1c2luZyBuZXcgbW9kZWxzIHRvIGJyZWFrIG9yIG1pc3Mgb3V0IG9uIGZ1bmN0aW9uYWxpdHk8L2xpPlxcbjxsaT5PdXRkYXRlZCBtb2RlbHMgaW4gdGhlIGNhY2hlLCBjYXVzaW5nIG5ldyB2aWV3cyBvciBjb250cm9sbGVycyB0byBicmVhazwvbGk+XFxuPC91bD5cXG48cD5WZXJzaW9uaW5nIGhhbmRsZXMgdGhlc2UgaXNzdWVzIGdyYWNlZnVsbHkgb24geW91ciBiZWhhbGYuIFRoZSB3YXkgaXQgd29ya3MgaXMgdGhhdCB3aGVuZXZlciB5b3UgZ2V0IGEgcmVzcG9uc2UgZnJvbSBUYXVudXMsIGEgPGVtPnZlcnNpb24gc3RyaW5nIChjb25maWd1cmVkIG9uIHRoZSBzZXJ2ZXItc2lkZSk8L2VtPiBpcyBpbmNsdWRlZCB3aXRoIGl0LiBJZiB0aGF0IHZlcnNpb24gc3RyaW5nIGRvZXNuJiMzOTt0IG1hdGNoIHRoZSBvbmUgc3RvcmVkIGluIHRoZSBjbGllbnQsIHRoZW4gdGhlIGNhY2hlIHdpbGwgYmUgZmx1c2hlZCBhbmQgdGhlIGh1bWFuIHdpbGwgYmUgcmVkaXJlY3RlZCwgZm9yY2luZyBhIGZ1bGwgcGFnZSByZWxvYWQuPC9wPlxcbjxibG9ja3F1b3RlPlxcbjxwPlRoZSB2ZXJzaW9uaW5nIEFQSSBpcyB1bmFibGUgdG8gaGFuZGxlIGNoYW5nZXMgdG8gcm91dGVzLCBhbmQgaXQmIzM5O3MgdXAgdG8geW91IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBzdGF5cyBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aGVuIGl0IGNvbWVzIHRvIHJvdXRpbmcuPC9wPlxcbjxwPlZlcnNpb25pbmcgY2FuJiMzOTt0IGludGVydmVuZSB3aGVuIHRoZSBjbGllbnQtc2lkZSBpcyBoZWF2aWx5IHJlbHlpbmcgb24gY2FjaGVkIHZpZXdzIGFuZCBtb2RlbHMsIGFuZCB0aGUgaHVtYW4gaXMgcmVmdXNpbmcgdG8gcmVsb2FkIHRoZWlyIGJyb3dzZXIuIFRoZSBzZXJ2ZXIgaXNuJiMzOTt0IGJlaW5nIGFjY2Vzc2VkIGFuZCB0aHVzIGl0IGNhbiYjMzk7dCBjb21tdW5pY2F0ZSB0aGF0IGV2ZXJ5dGhpbmcgb24gdGhlIGNhY2hlIG1heSBoYXZlIGJlY29tZSBzdGFsZS4gVGhlIGdvb2QgbmV3cyBpcyB0aGF0IHRoZSBodW1hbiB3b24mIzM5O3Qgbm90aWNlIGFueSBvZGRpdGllcywgYXMgdGhlIHNpdGUgd2lsbCBjb250aW51ZSB0byB3b3JrIGFzIGhlIGtub3dzIGl0LiBXaGVuIGhlIGZpbmFsbHkgYXR0ZW1wdHMgdG8gdmlzaXQgc29tZXRoaW5nIHRoYXQgaXNuJiMzOTt0IGNhY2hlZCwgYSByZXF1ZXN0IGlzIG1hZGUsIGFuZCB0aGUgdmVyc2lvbmluZyBlbmdpbmUgcmVzb2x2ZXMgdmVyc2lvbiBkaXNjcmVwYW5jaWVzIGZvciB0aGVtLjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+TWFraW5nIHVzZSBvZiB2ZXJzaW9uaW5nIGludm9sdmVzIHNldHRpbmcgdGhlIDxjb2RlPnZlcnNpb248L2NvZGU+IGZpZWxkIGluIHRoZSBvcHRpb25zLCB3aGVuIGludm9raW5nIDxjb2RlPnRhdW51cy5tb3VudDwvY29kZT4gPHN0cm9uZz5vbiBib3RoIHRoZSBzZXJ2ZXItc2lkZSBhbmQgdGhlIGNsaWVudC1zaWRlLCB1c2luZyB0aGUgc2FtZSB2YWx1ZTwvc3Ryb25nPi4gVGhlIFRhdW51cyB2ZXJzaW9uIHN0cmluZyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBvbmUgeW91IHByb3ZpZGVkLCBzbyB0aGF0IFRhdW51cyB3aWxsIGtub3cgdG8gc3RheSBhbGVydCBmb3IgY2hhbmdlcyB0byBUYXVudXMgaXRzZWxmLCBhcyB3ZWxsLjwvcD5cXG48cD5Zb3UgbWF5IHVzZSB5b3VyIGJ1aWxkIGlkZW50aWZpZXIgb3IgdGhlIDxjb2RlPnZlcnNpb248L2NvZGU+IGZpZWxkIGluIDxjb2RlPnBhY2thZ2UuanNvbjwvY29kZT4sIGJ1dCB1bmRlcnN0YW5kIHRoYXQgaXQgbWF5IGNhdXNlIHRoZSBjbGllbnQtc2lkZSB0byBmbHVzaCB0aGUgY2FjaGUgdG9vIG9mdGVuIDxlbT4obWF5YmUgZXZlbiBvbiBldmVyeSBkZXBsb3ltZW50KTwvZW0+LjwvcD5cXG48cD5UaGUgZGVmYXVsdCB2ZXJzaW9uIHN0cmluZyBpcyBzZXQgdG8gPGNvZGU+MTwvY29kZT4uIFRoZSBUYXVudXMgdmVyc2lvbiB3aWxsIGJlIHByZXBlbmRlZCB0byB5b3VycywgcmVzdWx0aW5nIGluIGEgdmFsdWUgc3VjaCBhcyA8Y29kZT50My4wLjA7djE8L2NvZGU+IHdoZXJlIFRhdW51cyBpcyBydW5uaW5nIHZlcnNpb24gPGNvZGU+My4wLjA8L2NvZGU+IGFuZCB5b3VyIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgdmVyc2lvbiA8Y29kZT4xPC9jb2RlPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJ0aGUtc2t5LWlzLXRoZS1saW1pdC1cXFwiPlRoZSBza3kgaXMgdGhlIGxpbWl0ITwvaDE+XFxuPHA+WW91JiMzOTtyZSBub3cgZmFtaWxpYXIgd2l0aCBob3cgVGF1bnVzIHdvcmtzIG9uIGEgaGlnaC1sZXZlbC4gWW91IGhhdmUgY292ZXJlZCBhIGRlY2VudCBhbW91bnQgb2YgZ3JvdW5kLCBidXQgeW91IHNob3VsZG4mIzM5O3Qgc3RvcCB0aGVyZS48L3A+XFxuPHVsPlxcbjxsaT5MZWFybiBtb3JlIGFib3V0IDxhIGhyZWY9XFxcIi9hcGlcXFwiPnRoZSBBUEkgVGF1bnVzIGhhczwvYT4gdG8gb2ZmZXI8L2xpPlxcbjxsaT5HbyB0aHJvdWdoIHRoZSA8YSBocmVmPVxcXCIvcGVyZm9ybWFuY2VcXFwiPnBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aXBzPC9hPi4gWW91IG1heSBsZWFybiBzb21ldGhpbmcgbmV3ITwvbGk+XFxuPGxpPjxlbT5GYW1pbGlhcml6ZSB5b3Vyc2VsZiB3aXRoIHRoZSB3YXlzIG9mIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50PC9lbT48dWw+XFxuPGxpPkplcmVteSBLZWl0aCBlbnVuY2lhdGVzIDxhIGhyZWY9XFxcImh0dHBzOi8vYWRhY3Rpby5jb20vam91cm5hbC83NzA2XFxcIj4mcXVvdDtCZSBwcm9ncmVzc2l2ZSZxdW90OzwvYT48L2xpPlxcbjxsaT5DaHJpc3RpYW4gSGVpbG1hbm4gYWR2b2NhdGVzIGZvciA8YSBocmVmPVxcXCJodHRwOi8vaWNhbnQuY28udWsvYXJ0aWNsZXMvcHJhZ21hdGljLXByb2dyZXNzaXZlLWVuaGFuY2VtZW50L1xcXCI+JnF1b3Q7UHJhZ21hdGljIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50JnF1b3Q7PC9hPjwvbGk+XFxuPGxpPkpha2UgQXJjaGliYWxkIGV4cGxhaW5zIGhvdyA8YSBocmVmPVxcXCJodHRwOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxMy9wcm9ncmVzc2l2ZS1lbmhhbmNlbWVudC1pcy1mYXN0ZXIvXFxcIj4mcXVvdDtQcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBpcyBmYXN0ZXImcXVvdDs8L2E+PC9saT5cXG48bGk+SSBibG9nZ2VkIGFib3V0IGhvdyB3ZSBzaG91bGQgPGEgaHJlZj1cXFwiaHR0cDovL3Bvbnlmb28uY29tL3N0b3AtYnJlYWtpbmctdGhlLXdlYlxcXCI+JnF1b3Q7U3RvcCBCcmVha2luZyB0aGUgV2ViJnF1b3Q7PC9hPjwvbGk+XFxuPGxpPkd1aWxsZXJtbyBSYXVjaCBhcmd1ZXMgZm9yIDxhIGhyZWY9XFxcImh0dHA6Ly9yYXVjaGcuY29tLzIwMTQvNy1wcmluY2lwbGVzLW9mLXJpY2gtd2ViLWFwcGxpY2F0aW9ucy9cXFwiPiZxdW90OzcgUHJpbmNpcGxlcyBvZiBSaWNoIFdlYiBBcHBsaWNhdGlvbnMmcXVvdDs8L2E+PC9saT5cXG48bGk+QWFyb24gR3VzdGFmc29uIHdyaXRlcyA8YSBocmVmPVxcXCJodHRwOi8vYWxpc3RhcGFydC5jb20vYXJ0aWNsZS91bmRlcnN0YW5kaW5ncHJvZ3Jlc3NpdmVlbmhhbmNlbWVudFxcXCI+JnF1b3Q7VW5kZXJzdGFuZGluZyBQcm9ncmVzc2l2ZSBFbmhhbmNlbWVudCZxdW90OzwvYT48L2xpPlxcbjxsaT5PcmRlIFNhdW5kZXJzIGdpdmVzIGhpcyBwb2ludCBvZiB2aWV3IGluIDxhIGhyZWY9XFxcImh0dHBzOi8vZGVjYWRlY2l0eS5uZXQvYmxvZy8yMDEzLzA5LzE2L3Byb2dyZXNzaXZlLWVuaGFuY2VtZW50LWZvci1mYXVsdC10b2xlcmFuY2VcXFwiPiZxdW90O1Byb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBmYXVsdCB0b2xlcmFuY2UmcXVvdDs8L2E+PC9saT5cXG48L3VsPlxcbjwvbGk+XFxuPGxpPlNpZnQgdGhyb3VnaCB0aGUgPGEgaHJlZj1cXFwiL2NvbXBsZW1lbnRzXFxcIj5jb21wbGVtZW50YXJ5IG1vZHVsZXM8L2E+LiBZb3UgbWF5IGZpbmQgc29tZXRoaW5nIHlvdSBoYWRuJiMzOTt0IHRob3VnaHQgb2YhPC9saT5cXG48L3VsPlxcbjxwPkFsc28sIGdldCBpbnZvbHZlZCE8L3A+XFxuPHVsPlxcbjxsaT5Gb3JrIHRoaXMgcmVwb3NpdG9yeSBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy90YXVudXMuYmV2YWNxdWEuaW8vcHVsbHNcXFwiPnNlbmQgc29tZSBwdWxsIHJlcXVlc3RzPC9hPiB0byBpbXByb3ZlIHRoZXNlIGd1aWRlcyE8L2xpPlxcbjxsaT5TZWUgc29tZXRoaW5nLCBzYXkgc29tZXRoaW5nISBJZiB5b3UgZGV0ZWN0IGEgYnVnLCA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy9pc3N1ZXMvbmV3XFxcIj5wbGVhc2UgY3JlYXRlIGFuIGlzc3VlPC9hPiE8L2xpPlxcbjwvdWw+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjdGFibGUtb2YtY29udGVudHNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGJsb2NrcXVvdGU+XFxuPHA+WW91JiMzOTtsbCBmaW5kIGEgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy9nZXR0aW5nLXN0YXJ0ZWRcXFwiPmZ1bGwgZmxlZGdlZCB2ZXJzaW9uIG9mIHRoZSBHZXR0aW5nIFN0YXJ0ZWQ8L2E+IHR1dG9yaWFsIGFwcGxpY2F0aW9uIG9uIEdpdEh1Yi48L3A+XFxuPC9ibG9ja3F1b3RlPlxcblwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9zZWN0aW9uPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTt9LmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGgudW5kZWZpbmVkOnR5cGVvZiB1bmRlZmluZWQhPT1cInVuZGVmaW5lZFwiP3VuZGVmaW5lZDp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGphZGUucmV0aHJvdyhlcnIsIGphZGVfZGVidWdbMF0uZmlsZW5hbWUsIGphZGVfZGVidWdbMF0ubGluZW5vLCBcInNlY3Rpb24ubHktc2VjdGlvbi5tZC1tYXJrZG93blxcbiAgOm1hcmtkb3duXFxuICAgICMgR2V0dGluZyBTdGFydGVkXFxuXFxuICAgIFRhdW51cyBpcyBhIHNoYXJlZC1yZW5kZXJpbmcgTVZDIGVuZ2luZSBmb3IgTm9kZS5qcywgYW5kIGl0J3MgX3VwIHRvIHlvdSBob3cgdG8gdXNlIGl0Xy4gSW4gZmFjdCwgaXQgbWlnaHQgYmUgYSBnb29kIGlkZWEgZm9yIHlvdSB0byAqKnNldCB1cCBqdXN0IHRoZSBzZXJ2ZXItc2lkZSBhc3BlY3QgZmlyc3QqKiwgYXMgdGhhdCdsbCB0ZWFjaCB5b3UgaG93IGl0IHdvcmtzIGV2ZW4gd2hlbiBKYXZhU2NyaXB0IG5ldmVyIGdldHMgdG8gdGhlIGNsaWVudC5cXG5cXG4gICAgIyBUYWJsZSBvZiBDb250ZW50c1xcblxcbiAgICAtIFtIb3cgaXQgd29ya3NdKCNob3ctaXQtd29ya3MpXFxuICAgIC0gW0luc3RhbGxpbmcgVGF1bnVzXSgjaW5zdGFsbGluZy10YXVudXMpXFxuICAgIC0gW1NldHRpbmcgdXAgdGhlIHNlcnZlci1zaWRlXSgjc2V0dGluZy11cC10aGUtc2VydmVyLXNpZGUpXFxuICAgICAgLSBbWW91ciBmaXJzdCByb3V0ZV0oI3lvdXItZmlyc3Qtcm91dGUpXFxuICAgICAgLSBbQ3JlYXRpbmcgYSBsYXlvdXRdKCNjcmVhdGluZy1hLWxheW91dClcXG4gICAgICAtIFtVc2luZyBKYWRlIGFzIHlvdXIgdmlldyBlbmdpbmVdKCN1c2luZy1qYWRlLWFzLXlvdXItdmlldy1lbmdpbmUpXFxuICAgICAgLSBbVGhyb3dpbmcgaW4gYSBjb250cm9sbGVyXSgjdGhyb3dpbmctaW4tYS1jb250cm9sbGVyKVxcbiAgICAtIFtUYXVudXMgaW4gdGhlIGNsaWVudF0oI3RhdW51cy1pbi10aGUtY2xpZW50KVxcbiAgICAgIC0gW1VzaW5nIHRoZSBUYXVudXMgQ0xJXSgjdXNpbmctdGhlLXRhdW51cy1jbGkpXFxuICAgICAgLSBbQm9vdGluZyB1cCB0aGUgY2xpZW50LXNpZGUgcm91dGVyXSgjYm9vdGluZy11cC10aGUtY2xpZW50LXNpZGUtcm91dGVyKVxcbiAgICAgIC0gW0FkZGluZyBmdW5jdGlvbmFsaXR5IGluIGEgY2xpZW50LXNpZGUgY29udHJvbGxlcl0oI2FkZGluZy1mdW5jdGlvbmFsaXR5LWluLWEtY2xpZW50LXNpZGUtY29udHJvbGxlcilcXG4gICAgICAtIFtDb21waWxpbmcgeW91ciBjbGllbnQtc2lkZSBKYXZhU2NyaXB0XSgjY29tcGlsaW5nLXlvdXItY2xpZW50LXNpZGUtamF2YXNjcmlwdClcXG4gICAgICAtIFtVc2luZyB0aGUgY2xpZW50LXNpZGUgVGF1bnVzIEFQSV0oI3VzaW5nLXRoZS1jbGllbnQtc2lkZS10YXVudXMtYXBpKVxcbiAgICAgIC0gW0NhY2hpbmcgYW5kIFByZWZldGNoaW5nXSgjY2FjaGluZy1hbmQtcHJlZmV0Y2hpbmcpXFxuICAgICAgLSBbVmVyc2lvbmluZ10oI3ZlcnNpb25pbmcpXFxuICAgIC0gW1RoZSBza3kgaXMgdGhlIGxpbWl0IV0oI3RoZS1za3ktaXMtdGhlLWxpbWl0LSlcXG5cXG4gICAgIyBIb3cgaXQgd29ya3NcXG5cXG4gICAgVGF1bnVzIGZvbGxvd3MgYSBzaW1wbGUgYnV0ICoqcHJvdmVuKiogc2V0IG9mIHJ1bGVzLlxcblxcbiAgICAtIERlZmluZSBhIGBmdW5jdGlvbihtb2RlbClgIGZvciBlYWNoIHlvdXIgdmlld3NcXG4gICAgLSBQdXQgdGhlc2Ugdmlld3MgaW4gYm90aCB0aGUgc2VydmVyIGFuZCB0aGUgY2xpZW50XFxuICAgIC0gRGVmaW5lIHJvdXRlcyBmb3IgeW91ciBhcHBsaWNhdGlvblxcbiAgICAtIFB1dCB0aG9zZSByb3V0ZXMgaW4gYm90aCB0aGUgc2VydmVyIGFuZCB0aGUgY2xpZW50XFxuICAgIC0gRW5zdXJlIHJvdXRlIG1hdGNoZXMgd29yayB0aGUgc2FtZSB3YXkgb24gYm90aCBlbmRzXFxuICAgIC0gQ3JlYXRlIHNlcnZlci1zaWRlIGNvbnRyb2xsZXJzIHRoYXQgeWllbGQgdGhlIG1vZGVsIGZvciB5b3VyIHZpZXdzXFxuICAgIC0gQ3JlYXRlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXJzIGlmIHlvdSBuZWVkIHRvIGFkZCBjbGllbnQtc2lkZSBmdW5jdGlvbmFsaXR5IHRvIGEgcGFydGljdWxhciB2aWV3XFxuICAgIC0gRm9yIHRoZSBmaXJzdCByZXF1ZXN0LCBhbHdheXMgcmVuZGVyIHZpZXdzIG9uIHRoZSBzZXJ2ZXItc2lkZVxcbiAgICAtIFdoZW4gcmVuZGVyaW5nIGEgdmlldyBvbiB0aGUgc2VydmVyLXNpZGUsIGluY2x1ZGUgdGhlIGZ1bGwgbGF5b3V0IGFzIHdlbGwhXFxuICAgIC0gT25jZSB0aGUgY2xpZW50LXNpZGUgY29kZSBraWNrcyBpbiwgKipoaWphY2sgbGluayBjbGlja3MqKiBhbmQgbWFrZSBBSkFYIHJlcXVlc3RzIGluc3RlYWRcXG4gICAgLSBXaGVuIHlvdSBnZXQgdGhlIEpTT04gbW9kZWwgYmFjaywgcmVuZGVyIHZpZXdzIG9uIHRoZSBjbGllbnQtc2lkZVxcbiAgICAtIElmIHRoZSBgaGlzdG9yeWAgQVBJIGlzIHVuYXZhaWxhYmxlLCBmYWxsIGJhY2sgdG8gZ29vZCBvbGQgcmVxdWVzdC1yZXNwb25zZS4gKipEb24ndCBjb25mdXNlIHlvdXIgaHVtYW5zIHdpdGggb2JzY3VyZSBoYXNoIHJvdXRlcnMhKipcXG5cXG4gICAgSSdsbCBzdGVwIHlvdSB0aHJvdWdoIHRoZXNlLCBidXQgcmF0aGVyIHRoYW4gbG9va2luZyBhdCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBJJ2xsIHdhbGsgeW91IHRocm91Z2ggdGhlIHN0ZXBzIHlvdSBuZWVkIHRvIHRha2UgaW4gb3JkZXIgdG8gbWFrZSB0aGlzIGZsb3cgaGFwcGVuLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIEluc3RhbGxpbmcgVGF1bnVzXFxuXFxuICAgIEZpcnN0IG9mZiwgeW91J2xsIG5lZWQgdG8gY2hvb3NlIGEgSFRUUCBzZXJ2ZXIgZnJhbWV3b3JrIGZvciB5b3VyIGFwcGxpY2F0aW9uLiBBdCB0aGUgbW9tZW50IFRhdW51cyBzdXBwb3J0cyBvbmx5IGEgY291cGxlIG9mIEhUVFAgZnJhbWV3b3JrcywgYnV0IG1vcmUgbWF5IGJlIGFkZGVkIGlmIHRoZXkgYXJlIHBvcHVsYXIgZW5vdWdoLlxcblxcbiAgICAtIFtFeHByZXNzXVs2XSwgdGhyb3VnaCBbdGF1bnVzLWV4cHJlc3NdWzFdXFxuICAgIC0gW0hhcGldWzddLCB0aHJvdWdoIFt0YXVudXMtaGFwaV1bMl0gYW5kIHRoZSBbaGFwaWlmeV1bM10gdHJhbnNmb3JtXFxuXFxuICAgID4gSWYgeW91J3JlIG1vcmUgb2YgYSBfXFxcInJ1bW1hZ2UgdGhyb3VnaCBzb21lb25lIGVsc2UncyBjb2RlXFxcIl8gdHlwZSBvZiBkZXZlbG9wZXIsIHlvdSBtYXkgZmVlbCBjb21mb3J0YWJsZSBbZ29pbmcgdGhyb3VnaCB0aGlzIHdlYnNpdGUncyBzb3VyY2UgY29kZV1bNF0sIHdoaWNoIHVzZXMgdGhlIFtIYXBpXVs3XSBmbGF2b3Igb2YgVGF1bnVzLiBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gbG9vayBhdCB0aGUgc291cmNlIGNvZGUgZm9yIFtwb255Zm9vLmNvbV1bNV0sIHdoaWNoIGlzICoqYSBtb3JlIGFkdmFuY2VkIHVzZS1jYXNlKiogdW5kZXIgdGhlIFtFeHByZXNzXVs2XSBmbGF2b3IuIE9yLCB5b3UgY291bGQganVzdCBrZWVwIG9uIHJlYWRpbmcgdGhpcyBwYWdlLCB0aGF0J3Mgb2theSB0b28uXFxuICAgID5cXG4gICAgPiBUaGVyZSdzIGFsc28gW2EgWWVvbWFuIGdlbmVyYXRvciBuYW1lZCBgZ2VuZXJhdG9yLXRhdW51c2BdWzQyXSB5b3UgY291bGQgdXNlIHRvIGdldCBzdGFydGVkLCBpbnN0ZWFkLlxcblxcbiAgICBPbmNlIHlvdSd2ZSBzZXR0bGVkIGZvciBlaXRoZXIgW0V4cHJlc3NdWzZdIG9yIFtIYXBpXVs3XSB5b3UnbGwgYmUgYWJsZSB0byBwcm9jZWVkLiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZ3VpZGUsIHdlJ2xsIHVzZSBbRXhwcmVzc11bNl0uIFN3aXRjaGluZyBiZXR3ZWVuIG9uZSBvZiB0aGUgZGlmZmVyZW50IEhUVFAgZmxhdm9ycyBpcyBzdHJpa2luZ2x5IGVhc3ksIHRob3VnaC5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBTZXR0aW5nIHVwIHRoZSBzZXJ2ZXItc2lkZVxcblxcbiAgICBOYXR1cmFsbHksIHlvdSdsbCBuZWVkIHRvIGluc3RhbGwgYWxsIG9mIHRoZSBmb2xsb3dpbmcgbW9kdWxlcyBmcm9tIGBucG1gIHRvIGdldCBzdGFydGVkLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBta2RpciBnZXR0aW5nLXN0YXJ0ZWRcXG4gICAgY2QgZ2V0dGluZy1zdGFydGVkXFxuICAgIG5wbSBpbml0XFxuICAgIG5wbSBpbnN0YWxsIC0tc2F2ZSB0YXVudXMgdGF1bnVzLWV4cHJlc3MgZXhwcmVzc1xcbiAgICBgYGBcXG5cXG4gICAgIVtTY3JlZW5zaG90IHdpdGggYG5wbSBpbml0YCBvdXRwdXRdWzMwXVxcblxcbiAgICBMZXQncyBidWlsZCBvdXIgYXBwbGljYXRpb24gc3RlcC1ieS1zdGVwLCBhbmQgSSdsbCB3YWxrIHlvdSB0aHJvdWdoIHRoZW0gYXMgd2UgZ28gYWxvbmcuIEZpcnN0IG9mIGFsbCwgeW91J2xsIG5lZWQgdGhlIGZhbW91cyBgYXBwLmpzYCBmaWxlLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICB0b3VjaCBhcHAuanNcXG4gICAgYGBgXFxuXFxuICAgIEl0J3MgcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gcHV0IHNvbWV0aGluZyBpbiB5b3VyIGBhcHAuanNgIGZpbGUsIGxldCdzIGRvIHRoYXQgbm93LlxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHZhciB0YXVudXMgPSByZXF1aXJlKCd0YXVudXMnKTtcXG4gICAgdmFyIHRhdW51c0V4cHJlc3MgPSByZXF1aXJlKCd0YXVudXMtZXhwcmVzcycpO1xcbiAgICB2YXIgZXhwcmVzcyA9IHJlcXVpcmUoJ2V4cHJlc3MnKTtcXG4gICAgdmFyIGFwcCA9IGV4cHJlc3MoKTtcXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcXG5cXG4gICAgdGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuICAgIGFwcC5saXN0ZW4oMzAwMCk7XFxuICAgIGBgYFxcblxcbiAgICBBbGwgYHRhdW51cy1leHByZXNzYCByZWFsbHkgZG9lcyBpcyBhZGQgYSBidW5jaCBvZiByb3V0ZXMgdG8geW91ciBFeHByZXNzIGBhcHBgLiBZb3Ugc2hvdWxkIG5vdGUgdGhhdCBhbnkgbWlkZGxld2FyZSBhbmQgQVBJIHJvdXRlcyBzaG91bGQgcHJvYmFibHkgY29tZSBiZWZvcmUgdGhlIGB0YXVudXNFeHByZXNzYCBpbnZvY2F0aW9uLiBZb3UnbGwgcHJvYmFibHkgYmUgdXNpbmcgYSBjYXRjaC1hbGwgdmlldyByb3V0ZSB0aGF0IHJlbmRlcnMgYSBfXFxcIk5vdCBGb3VuZFxcXCJfIHZpZXcsIGJsb2NraW5nIGFueSByb3V0aW5nIGJleW9uZCB0aGF0IHJvdXRlLlxcblxcbiAgICBJZiB5b3Ugd2VyZSB0byBydW4gdGhlIGFwcGxpY2F0aW9uIG5vdyB5b3Ugd291bGQgZ2V0IGEgZnJpZW5kbHkgcmVtaW5lZCBmcm9tIFRhdW51cyBsZXR0aW5nIHlvdSBrbm93IHRoYXQgeW91IGZvcmdvdCB0byBkZWNsYXJlIGFueSB2aWV3IHJvdXRlcy4gU2lsbHkgeW91IVxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBub2RlIGFwcFxcbiAgICBgYGBcXG5cXG4gICAgIVtTY3JlZW5zaG90IHdpdGggYG5vZGUgYXBwYCBvdXRwdXRdWzMxXVxcblxcbiAgICBUaGUgYG9wdGlvbnNgIG9iamVjdCBwYXNzZWQgdG8gYHRhdW51c0V4cHJlc3NgIGxldCdzIHlvdSBjb25maWd1cmUgVGF1bnVzLiBJbnN0ZWFkIG9mIGRpc2N1c3NpbmcgZXZlcnkgc2luZ2xlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHlvdSBjb3VsZCBzZXQgaGVyZSwgbGV0J3MgZGlzY3VzcyB3aGF0IG1hdHRlcnM6IHRoZSBfcmVxdWlyZWQgY29uZmlndXJhdGlvbl8uIFRoZXJlJ3MgdHdvIG9wdGlvbnMgdGhhdCB5b3UgbXVzdCBzZXQgaWYgeW91IHdhbnQgeW91ciBUYXVudXMgYXBwbGljYXRpb24gdG8gbWFrZSBhbnkgc2Vuc2UuXFxuXFxuICAgIC0gYHJvdXRlc2Agc2hvdWxkIGJlIGFuIGFycmF5IG9mIHZpZXcgcm91dGVzXFxuICAgIC0gYGxheW91dGAgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBgbW9kZWxgIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGVudGlyZSBIVE1MIGRvY3VtZW50XFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgWW91ciBmaXJzdCByb3V0ZVxcblxcbiAgICBSb3V0ZXMgbmVlZCB0byBiZSBwbGFjZWQgaW4gaXRzIG93biBkZWRpY2F0ZWQgbW9kdWxlLCBzbyB0aGF0IHlvdSBjYW4gcmV1c2UgaXQgbGF0ZXIgb24gKip3aGVuIHNldHRpbmcgdXAgY2xpZW50LXNpZGUgcm91dGluZyoqLiBMZXQncyBjcmVhdGUgdGhhdCBtb2R1bGUgYW5kIGFkZCBhIHJvdXRlIHRvIGl0LlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICB0b3VjaCByb3V0ZXMuanNcXG4gICAgYGBgXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBbXFxuICAgICAgeyByb3V0ZTogJy8nLCBhY3Rpb246ICdob21lL2luZGV4JyB9XFxuICAgIF07XFxuICAgIGBgYFxcblxcbiAgICBFYWNoIGl0ZW0gaW4gdGhlIGV4cG9ydGVkIGFycmF5IGlzIGEgcm91dGUuIEluIHRoaXMgY2FzZSwgd2Ugb25seSBoYXZlIHRoZSBgL2Agcm91dGUgd2l0aCB0aGUgYGhvbWUvaW5kZXhgIGFjdGlvbi4gVGF1bnVzIGZvbGxvd3MgdGhlIHdlbGwga25vd24gW2NvbnZlbnRpb24gb3ZlciBjb25maWd1cmF0aW9uIHBhdHRlcm5dWzhdLCB3aGljaCBtYWRlIFtSdWJ5IG9uIFJhaWxzXVs5XSBmYW1vdXMuIF9NYXliZSBvbmUgZGF5IFRhdW51cyB3aWxsIGJlIGZhbW91cyB0b28hXyBCeSBjb252ZW50aW9uLCBUYXVudXMgd2lsbCBhc3N1bWUgdGhhdCB0aGUgYGhvbWUvaW5kZXhgIGFjdGlvbiB1c2VzIHRoZSBgaG9tZS9pbmRleGAgY29udHJvbGxlciBhbmQgcmVuZGVycyB0aGUgYGhvbWUvaW5kZXhgIHZpZXcuIE9mIGNvdXJzZSwgX2FsbCBvZiB0aGF0IGNhbiBiZSBjaGFuZ2VkIHVzaW5nIGNvbmZpZ3VyYXRpb25fLlxcblxcbiAgICBUaW1lIHRvIGdvIGJhY2sgdG8gYGFwcC5qc2AgYW5kIHVwZGF0ZSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgdGF1bnVzID0gcmVxdWlyZSgndGF1bnVzJyk7XFxuICAgIHZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgndGF1bnVzLWV4cHJlc3MnKTtcXG4gICAgdmFyIGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XFxuICAgIHZhciBhcHAgPSBleHByZXNzKCk7XFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIHJvdXRlczogcmVxdWlyZSgnLi9yb3V0ZXMnKVxcbiAgICB9O1xcblxcbiAgICB0YXVudXNFeHByZXNzKHRhdW51cywgYXBwLCBvcHRpb25zKTtcXG4gICAgYXBwLmxpc3RlbigzMDAwKTtcXG4gICAgYGBgXFxuXFxuICAgIEl0J3MgaW1wb3J0YW50IHRvIGtub3cgdGhhdCBpZiB5b3Ugb21pdCB0aGUgY3JlYXRpb24gb2YgYSBjb250cm9sbGVyIHRoZW4gVGF1bnVzIHdpbGwgc2tpcCB0aGF0IHN0ZXAsIGFuZCByZW5kZXIgdGhlIHZpZXcgcGFzc2luZyBpdCB3aGF0ZXZlciB0aGUgZGVmYXVsdCBtb2RlbCBpcyBfKG1vcmUgb24gdGhhdCBbaW4gdGhlIEFQSSBkb2N1bWVudGF0aW9uXVsxOF0sIGJ1dCBpdCBkZWZhdWx0cyB0byBge31gKV8uXFxuXFxuICAgIEhlcmUncyB3aGF0IHlvdSdkIGdldCBpZiB5b3UgYXR0ZW1wdGVkIHRvIHJ1biB0aGUgYXBwbGljYXRpb24gYXQgdGhpcyBwb2ludC5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbm9kZSBhcHAgJlxcbiAgICBjdXJsIGxvY2FsaG9zdDozMDAwXFxuICAgIGBgYFxcblxcbiAgICAhW1NjcmVlbnNob3Qgd2l0aCBgbm9kZSBhcHBgIHJlc3VsdHNdWzMyXVxcblxcbiAgICBUdXJucyBvdXQgeW91J3JlIG1pc3NpbmcgYSBsb3Qgb2YgdGhpbmdzISBUYXVudXMgaXMgcXVpdGUgbGVuaWVudCBhbmQgaXQnbGwgdHJ5IGl0cyBiZXN0IHRvIGxldCB5b3Uga25vdyB3aGF0IHlvdSBtaWdodCBiZSBtaXNzaW5nLCB0aG91Z2guIEFwcGFyZW50bHkgeW91IGRvbid0IGhhdmUgYSBsYXlvdXQsIGEgc2VydmVyLXNpZGUgY29udHJvbGxlciwgb3IgZXZlbiBhIHZpZXchIF9UaGF0J3Mgcm91Z2guX1xcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIENyZWF0aW5nIGEgbGF5b3V0XFxuXFxuICAgIExldCdzIGFsc28gY3JlYXRlIGEgbGF5b3V0LiBGb3IgdGhlIHB1cnBvc2VzIG9mIG1ha2luZyBvdXIgd2F5IHRocm91Z2ggdGhpcyBndWlkZSwgaXQnbGwganVzdCBiZSBhIHBsYWluIEphdmFTY3JpcHQgZnVuY3Rpb24uXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIHRvdWNoIGxheW91dC5qc1xcbiAgICBgYGBcXG5cXG4gICAgTm90ZSB0aGF0IHRoZSBgcGFydGlhbGAgcHJvcGVydHkgaW4gdGhlIGBtb2RlbGAgXyhhcyBzZWVuIGJlbG93KV8gaXMgY3JlYXRlZCBvbiB0aGUgZmx5IGFmdGVyIHJlbmRlcmluZyBwYXJ0aWFsIHZpZXdzLiBUaGUgbGF5b3V0IGZ1bmN0aW9uIHdlJ2xsIGJlIHVzaW5nIGhlcmUgZWZmZWN0aXZlbHkgbWVhbnMgX1xcXCJ1c2UgdGhlIGZvbGxvd2luZyBjb21iaW5hdGlvbiBvZiBwbGFpbiB0ZXh0IGFuZCB0aGUgKioobWF5YmUgSFRNTCkqKiBwYXJ0aWFsIHZpZXdcXFwiXy5cXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2RlbCkge1xcbiAgICAgIHJldHVybiAnVGhpcyBpcyB0aGUgcGFydGlhbDogXFxcIicgKyBtb2RlbC5wYXJ0aWFsICsgJ1xcXCInO1xcbiAgICB9O1xcbiAgICBgYGBcXG5cXG4gICAgT2YgY291cnNlLCBpZiB5b3Ugd2VyZSBkZXZlbG9waW5nIGEgcmVhbCBhcHBsaWNhdGlvbiwgdGhlbiB5b3UgcHJvYmFibHkgd291bGRuJ3Qgd2FudCB0byB3cml0ZSB2aWV3cyBhcyBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBhcyB0aGF0J3MgdW5wcm9kdWN0aXZlLCBjb25mdXNpbmcsIGFuZCBoYXJkIHRvIG1haW50YWluLiBXaGF0IHlvdSBjb3VsZCBkbyBpbnN0ZWFkLCBpcyB1c2UgYSB2aWV3LXJlbmRlcmluZyBlbmdpbmUgdGhhdCBhbGxvd3MgeW91IHRvIGNvbXBpbGUgeW91ciB2aWV3IHRlbXBsYXRlcyBpbnRvIEphdmFTY3JpcHQgZnVuY3Rpb25zLlxcblxcbiAgICAtIFtNdXN0YWNoZV1bMTBdIGlzIGEgdGVtcGxhdGluZyBlbmdpbmUgdGhhdCBjYW4gY29tcGlsZSB5b3VyIHZpZXdzIGludG8gcGxhaW4gZnVuY3Rpb25zLCB1c2luZyBhIHN5bnRheCB0aGF0J3MgbWluaW1hbGx5IGRpZmZlcmVudCBmcm9tIEhUTUxcXG4gICAgLSBbSmFkZV1bMTFdIGlzIGFub3RoZXIgb3B0aW9uLCBhbmQgaXQgaGFzIGEgdGVyc2Ugc3ludGF4IHdoZXJlIHNwYWNpbmcgbWF0dGVycyBidXQgdGhlcmUncyBubyBjbG9zaW5nIHRhZ3NcXG4gICAgLSBUaGVyZSdzIG1hbnkgbW9yZSBhbHRlcm5hdGl2ZXMgbGlrZSBbTW96aWxsYSdzIE51bmp1Y2tzXVsxMl0sIFtIYW5kbGViYXJzXVsxM10sIGFuZCBbRUpTXVsxNF0uXFxuXFxuICAgIFJlbWVtYmVyIHRvIGFkZCB0aGUgYGxheW91dGAgdW5kZXIgdGhlIGBvcHRpb25zYCBvYmplY3QgcGFzc2VkIHRvIGB0YXVudXNFeHByZXNzYCFcXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgdGF1bnVzID0gcmVxdWlyZSgndGF1bnVzJyk7XFxuICAgIHZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgndGF1bnVzLWV4cHJlc3MnKTtcXG4gICAgdmFyIGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XFxuICAgIHZhciBhcHAgPSBleHByZXNzKCk7XFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIHJvdXRlczogcmVxdWlyZSgnLi9yb3V0ZXMnKSxcXG4gICAgICBsYXlvdXQ6IHJlcXVpcmUoJy4vbGF5b3V0JylcXG4gICAgfTtcXG5cXG4gICAgdGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuICAgIGFwcC5saXN0ZW4oMzAwMCk7XFxuICAgIGBgYFxcblxcbiAgICBIZXJlJ3Mgd2hhdCB5b3UnZCBnZXQgaWYgeW91IHJhbiB0aGUgYXBwbGljYXRpb24gYXQgdGhpcyBwb2ludC5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbm9kZSBhcHAgJlxcbiAgICBjdXJsIGxvY2FsaG9zdDozMDAwXFxuICAgIGBgYFxcblxcbiAgICAhW1NjcmVlbnNob3Qgd2l0aCBgbm9kZSBhcHBgIG91dHB1dF1bMzNdXFxuXFxuICAgIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhIGxheW91dCwgYnV0IHdlJ3JlIHN0aWxsIG1pc3NpbmcgdGhlIHBhcnRpYWwgdmlldyBhbmQgdGhlIHNlcnZlci1zaWRlIGNvbnRyb2xsZXIuIFdlIGNhbiBkbyB3aXRob3V0IHRoZSBjb250cm9sbGVyLCBidXQgaGF2aW5nIG5vIHZpZXdzIGlzIGtpbmQgb2YgcG9pbnRsZXNzIHdoZW4geW91J3JlIHRyeWluZyB0byBnZXQgYW4gTVZDIGVuZ2luZSB1cCBhbmQgcnVubmluZywgcmlnaHQ/XFxuXFxuICAgIFlvdSdsbCBmaW5kIHRvb2xzIHJlbGF0ZWQgdG8gdmlldyB0ZW1wbGF0aW5nIGluIHRoZSBbY29tcGxlbWVudGFyeSBtb2R1bGVzIHNlY3Rpb25dWzE1XS4gSWYgeW91IGRvbid0IHByb3ZpZGUgYSBgbGF5b3V0YCBwcm9wZXJ0eSBhdCBhbGwsIFRhdW51cyB3aWxsIHJlbmRlciB5b3VyIG1vZGVsIGluIGEgcmVzcG9uc2UgYnkgd3JhcHBpbmcgaXQgaW4gYDxwcmU+YCBhbmQgYDxjb2RlPmAgdGFncywgd2hpY2ggbWF5IGFpZCB5b3Ugd2hlbiBnZXR0aW5nIHN0YXJ0ZWQuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVXNpbmcgSmFkZSBhcyB5b3VyIHZpZXcgZW5naW5lXFxuXFxuICAgIExldCdzIGdvIGFoZWFkIGFuZCB1c2UgSmFkZSBhcyB0aGUgdmlldy1yZW5kZXJpbmcgZW5naW5lIG9mIGNob2ljZSBmb3Igb3VyIHZpZXdzLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBta2RpciAtcCB2aWV3cy9ob21lXFxuICAgIHRvdWNoIHZpZXdzL2hvbWUvaW5kZXguamFkZVxcbiAgICBgYGBcXG5cXG4gICAgU2luY2Ugd2UncmUganVzdCBnZXR0aW5nIHN0YXJ0ZWQsIHRoZSB2aWV3IHdpbGwganVzdCBoYXZlIHNvbWUgYmFzaWMgc3RhdGljIGNvbnRlbnQsIGFuZCB0aGF0J3MgaXQuXFxuXFxuICAgIGBgYGphZGVcXG4gICAgcCBIZWxsbyBUYXVudXMhXFxuICAgIGBgYFxcblxcbiAgICBOZXh0IHlvdSdsbCB3YW50IHRvIGNvbXBpbGUgdGhlIHZpZXcgaW50byBhIGZ1bmN0aW9uLiBUbyBkbyB0aGF0IHlvdSBjYW4gdXNlIFtqYWR1bV1bMTZdLCBhIHNwZWNpYWxpemVkIEphZGUgY29tcGlsZXIgdGhhdCBwbGF5cyB3ZWxsIHdpdGggVGF1bnVzIGJ5IGJlaW5nIGF3YXJlIG9mIGByZXF1aXJlYCBzdGF0ZW1lbnRzLCBhbmQgdGh1cyBzYXZpbmcgYnl0ZXMgd2hlbiBpdCBjb21lcyB0byBjbGllbnQtc2lkZSByZW5kZXJpbmcuIExldCdzIGluc3RhbGwgaXQgZ2xvYmFsbHksIGZvciB0aGUgc2FrZSBvZiB0aGlzIGV4ZXJjaXNlIF8oeW91IHNob3VsZCBpbnN0YWxsIGl0IGxvY2FsbHkgd2hlbiB5b3UncmUgZGV2ZWxvcGluZyBhIHJlYWwgYXBwbGljYXRpb24pXy5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbnBtIGluc3RhbGwgLS1nbG9iYWwgamFkdW1cXG4gICAgYGBgXFxuXFxuICAgIFRvIGNvbXBpbGUgZXZlcnkgdmlldyBpbiB0aGUgYHZpZXdzYCBkaXJlY3RvcnkgaW50byBmdW5jdGlvbnMgdGhhdCB3b3JrIHdlbGwgd2l0aCBUYXVudXMsIHlvdSBjYW4gdXNlIHRoZSBjb21tYW5kIGJlbG93LiBUaGUgYC0tb3V0cHV0YCBmbGFnIGluZGljYXRlcyB3aGVyZSB5b3Ugd2FudCB0aGUgdmlld3MgdG8gYmUgcGxhY2VkLiBXZSBjaG9zZSB0byB1c2UgYC5iaW5gIGJlY2F1c2UgdGhhdCdzIHdoZXJlIFRhdW51cyBleHBlY3RzIHlvdXIgY29tcGlsZWQgdmlld3MgdG8gYmUgYnkgZGVmYXVsdC4gQnV0IHNpbmNlIFRhdW51cyBmb2xsb3dzIHRoZSBbY29udmVudGlvbiBvdmVyIGNvbmZpZ3VyYXRpb25dWzE3XSBhcHByb2FjaCwgeW91IGNvdWxkIGNoYW5nZSB0aGF0IGlmIHlvdSB3YW50ZWQgdG8uXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIGphZHVtIHZpZXdzLyoqIC0tb3V0cHV0IC5iaW5cXG4gICAgYGBgXFxuXFxuICAgIENvbmdyYXR1bGF0aW9ucyEgWW91ciBmaXJzdCB2aWV3IGlzIG5vdyBvcGVyYXRpb25hbCBhbmQgYnVpbHQgdXNpbmcgYSBmdWxsLWZsZWRnZWQgdGVtcGxhdGluZyBlbmdpbmUhIEFsbCB0aGF0J3MgbGVmdCBpcyBmb3IgeW91IHRvIHJ1biB0aGUgYXBwbGljYXRpb24gYW5kIHZpc2l0IGl0IG9uIHBvcnQgYDMwMDBgLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBub2RlIGFwcCAmXFxuICAgIG9wZW4gaHR0cDovL2xvY2FsaG9zdDozMDAwXFxuICAgIGBgYFxcblxcbiAgICAhW1NjcmVlbnNob3Qgd2l0aCBgbm9kZSBhcHBgIG91dHB1dF1bMzRdXFxuXFxuICAgIEdyYW50ZWQsIHlvdSBzaG91bGQgX3Byb2JhYmx5XyBtb3ZlIHRoZSBsYXlvdXQgaW50byBhIEphZGUgXyhhbnkgdmlldyBlbmdpbmUgd2lsbCBkbylfIHRlbXBsYXRlIGFzIHdlbGwuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVGhyb3dpbmcgaW4gYSBjb250cm9sbGVyXFxuXFxuICAgIENvbnRyb2xsZXJzIGFyZSBpbmRlZWQgb3B0aW9uYWwsIGJ1dCBhbiBhcHBsaWNhdGlvbiB0aGF0IHJlbmRlcnMgZXZlcnkgdmlldyB1c2luZyB0aGUgc2FtZSBtb2RlbCB3b24ndCBnZXQgeW91IHZlcnkgZmFyLiBDb250cm9sbGVycyBhbGxvdyB5b3UgdG8gaGFuZGxlIHRoZSByZXF1ZXN0IGFuZCBwdXQgdG9nZXRoZXIgdGhlIG1vZGVsIHRvIGJlIHVzZWQgd2hlbiBzZW5kaW5nIGEgcmVzcG9uc2UuIENvbnRyYXJ5IHRvIHdoYXQgbW9zdCBmcmFtZXdvcmtzIHByb3Bvc2UsIFRhdW51cyBleHBlY3RzIGV2ZXJ5IGFjdGlvbiB0byBoYXZlIGl0cyBvd24gaW5kaXZpZHVhbCBjb250cm9sbGVyLiBTaW5jZSBOb2RlLmpzIG1ha2VzIGl0IGVhc3kgdG8gaW1wb3J0IGNvbXBvbmVudHMsIHRoaXMgc2V0dXAgaGVscHMgeW91IGtlZXAgeW91ciBjb2RlIG1vZHVsYXIgd2hpbGUgc3RpbGwgYmVpbmcgYWJsZSB0byByZXVzZSBsb2dpYyBieSBzaGFyaW5nIG1vZHVsZXMgYWNyb3NzIGRpZmZlcmVudCBjb250cm9sbGVycy4gTGV0J3MgY3JlYXRlIGEgY29udHJvbGxlciBmb3IgdGhlIGBob21lL3ZpZXdgIGFjdGlvbi5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbWtkaXIgLXAgY29udHJvbGxlcnMvaG9tZVxcbiAgICB0b3VjaCBjb250cm9sbGVycy9ob21lL2luZGV4LmpzXFxuICAgIGBgYFxcblxcbiAgICBUaGUgY29udHJvbGxlciBtb2R1bGUgc2hvdWxkIG1lcmVseSBleHBvcnQgYSBmdW5jdGlvbi4gX1N0YXJ0ZWQgbm90aWNpbmcgdGhlIHBhdHRlcm4/XyBUaGUgc2lnbmF0dXJlIGZvciB0aGUgY29udHJvbGxlciBpcyB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhhdCBvZiBhbnkgb3RoZXIgbWlkZGxld2FyZSBwYXNzZWQgdG8gW0V4cHJlc3NdWzZdIF8ob3IgYW55IHJvdXRlIGhhbmRsZXIgcGFzc2VkIHRvIFtIYXBpXVs3XSBpbiB0aGUgY2FzZSBvZiBgdGF1bnVzLWhhcGlgKV8uXFxuXFxuICAgIEFzIHlvdSBtYXkgaGF2ZSBub3RpY2VkIGluIHRoZSBleGFtcGxlcyBzbyBmYXIsIHlvdSBoYXZlbid0IGV2ZW4gc2V0IGEgZG9jdW1lbnQgdGl0bGUgZm9yIHlvdXIgSFRNTCBwYWdlcyEgVHVybnMgb3V0LCB0aGVyZSdzIGEgZmV3IG1vZGVsIHByb3BlcnRpZXMgXyh2ZXJ5IGZldylfIHRoYXQgVGF1bnVzIGlzIGF3YXJlIG9mLiBPbmUgb2YgdGhvc2UgaXMgdGhlIGB0aXRsZWAgcHJvcGVydHksIGFuZCBpdCdsbCBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgYGRvY3VtZW50LnRpdGxlYCBpbiB5b3VyIHBhZ2VzIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIHRoZSBjbGllbnQtc2lkZS4gS2VlcCBpbiBtaW5kIHRoYXQgYW55dGhpbmcgdGhhdCdzIG5vdCBpbiB0aGUgYG1vZGVsYCBwcm9wZXJ0eSB3b24ndCBiZSB0cmFzbWl0dGVkIHRvIHRoZSBjbGllbnQsIGFuZCB3aWxsIGp1c3QgYmUgYWNjZXNzaWJsZSB0byB0aGUgbGF5b3V0LlxcblxcbiAgICBIZXJlIGlzIG91ciBuZXdmYW5nbGVkIGBob21lL2luZGV4YCBjb250cm9sbGVyLiBBcyB5b3UnbGwgbm90aWNlLCBpdCBkb2Vzbid0IGRpc3J1cHQgYW55IG9mIHRoZSB0eXBpY2FsIEV4cHJlc3MgZXhwZXJpZW5jZSwgYnV0IG1lcmVseSBidWlsZHMgdXBvbiBpdC4gV2hlbiBgbmV4dGAgaXMgY2FsbGVkLCB0aGUgVGF1bnVzIHZpZXctcmVuZGVyaW5nIGhhbmRsZXIgd2lsbCBraWNrIGluLCBhbmQgcmVuZGVyIHRoZSB2aWV3IHVzaW5nIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHdhcyBhc3NpZ25lZCB0byBgcmVzLnZpZXdNb2RlbGAuXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHtcXG4gICAgICByZXMudmlld01vZGVsID0ge1xcbiAgICAgICAgbW9kZWw6IHtcXG4gICAgICAgICAgdGl0bGU6ICdXZWxjb21lIEhvbWUsIFRhdW51cyEnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBuZXh0KCk7XFxuICAgIH07XFxuICAgIGBgYFxcblxcbiAgICBPZiBjb3Vyc2UsIHJlbHlpbmcgb24gdGhlIGNsaWVudC1zaWRlIGNoYW5nZXMgdG8geW91ciBwYWdlIGluIG9yZGVyIHRvIHNldCB0aGUgdmlldyB0aXRsZSBfd291bGRuJ3QgYmUgcHJvZ3Jlc3NpdmVfLCBhbmQgdGh1cyBbaXQgd291bGQgYmUgcmVhbGx5LCBfcmVhbGx5XyBiYWRdWzE3XS4gV2Ugc2hvdWxkIHVwZGF0ZSB0aGUgbGF5b3V0IHRvIHVzZSB3aGF0ZXZlciBgdGl0bGVgIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgbW9kZWwuIEluIGZhY3QsIGxldCdzIGdvIGJhY2sgdG8gdGhlIGRyYXdpbmcgYm9hcmQgYW5kIG1ha2UgdGhlIGxheW91dCBpbnRvIGEgSmFkZSB0ZW1wbGF0ZSFcXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgcm0gbGF5b3V0LmpzXFxuICAgIHRvdWNoIHZpZXdzL2xheW91dC5qYWRlXFxuICAgIGphZHVtIHZpZXdzLyoqIC0tb3V0cHV0IC5iaW5cXG4gICAgYGBgXFxuXFxuICAgIFlvdSBzaG91bGQgYWxzbyByZW1lbWJlciB0byB1cGRhdGUgdGhlIGBhcHAuanNgIG1vZHVsZSBvbmNlIGFnYWluIVxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHZhciB0YXVudXMgPSByZXF1aXJlKCd0YXVudXMnKTtcXG4gICAgdmFyIHRhdW51c0V4cHJlc3MgPSByZXF1aXJlKCd0YXVudXMtZXhwcmVzcycpO1xcbiAgICB2YXIgZXhwcmVzcyA9IHJlcXVpcmUoJ2V4cHJlc3MnKTtcXG4gICAgdmFyIGFwcCA9IGV4cHJlc3MoKTtcXG4gICAgdmFyIG9wdGlvbnMgPSB7XFxuICAgICAgcm91dGVzOiByZXF1aXJlKCcuL3JvdXRlcycpLFxcbiAgICAgIGxheW91dDogcmVxdWlyZSgnLi8uYmluL3ZpZXdzL2xheW91dCcpXFxuICAgIH07XFxuXFxuICAgIHRhdW51c0V4cHJlc3ModGF1bnVzLCBhcHAsIG9wdGlvbnMpO1xcbiAgICBhcHAubGlzdGVuKDMwMDApO1xcbiAgICBgYGBcXG5cXG4gICAgVGhlIGAhPWAgc3ludGF4IGJlbG93IG1lYW5zIHRoYXQgd2hhdGV2ZXIgaXMgaW4gdGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50IHdvbid0IGJlIGVzY2FwZWQuIFRoYXQncyBva2F5IGJlY2F1c2UgYHBhcnRpYWxgIGlzIGEgdmlldyB3aGVyZSBKYWRlIGVzY2FwZWQgYW55dGhpbmcgdGhhdCBuZWVkZWQgZXNjYXBpbmcsIGJ1dCB3ZSB3b3VsZG4ndCB3YW50IEhUTUwgdGFncyB0byBiZSBlc2NhcGVkIVxcblxcbiAgICBgYGBqYWRlXFxuICAgIHRpdGxlPW1vZGVsLnRpdGxlXFxuICAgIG1haW4hPXBhcnRpYWxcXG4gICAgYGBgXFxuXFxuICAgIEJ5IHRoZSB3YXksIGRpZCB5b3Uga25vdyB0aGF0IGA8aHRtbD5gLCBgPGhlYWQ+YCwgYW5kIGA8Ym9keT5gIGFyZSBhbGwgb3B0aW9uYWwgaW4gSFRNTCA1LCBhbmQgdGhhdCB5b3UgY2FuIHNhZmVseSBvbWl0IHRoZW0gaW4geW91ciBIVE1MPyBPZiBjb3Vyc2UsIHJlbmRlcmluZyBlbmdpbmVzIHdpbGwgc3RpbGwgaW5zZXJ0IHRob3NlIGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgaW50byB0aGUgRE9NIGZvciB5b3UhIF9Ib3cgY29vbCBpcyB0aGF0P19cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbm9kZSBhcHBcXG4gICAgYGBgXFxuXFxuICAgICFbU2NyZWVuc2hvdCB3aXRoIGBub2RlIGFwcGAgb3V0cHV0XVszNV1cXG5cXG4gICAgWW91IGNhbiBub3cgdmlzaXQgYGxvY2FsaG9zdDozMDAwYCB3aXRoIHlvdXIgZmF2b3JpdGUgd2ViIGJyb3dzZXIgYW5kIHlvdSdsbCBub3RpY2UgdGhhdCB0aGUgdmlldyByZW5kZXJzIGFzIHlvdSdkIGV4cGVjdC4gVGhlIHRpdGxlIHdpbGwgYmUgcHJvcGVybHkgc2V0LCBhbmQgYSBgPG1haW4+YCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgY29udGVudHMgb2YgeW91ciB2aWV3LlxcblxcbiAgICAhW1NjcmVlbnNob3Qgd2l0aCBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIEdvb2dsZSBDaHJvbWVdWzM2XVxcblxcbiAgICBUaGF0J3MgaXQsIG5vdyB5b3VyIHZpZXcgaGFzIGEgdGl0bGUuIE9mIGNvdXJzZSwgdGhlcmUncyBub3RoaW5nIHN0b3BwaW5nIHlvdSBmcm9tIGFkZGluZyBkYXRhYmFzZSBjYWxscyB0byBmZXRjaCBiaXRzIGFuZCBwaWVjZXMgb2YgdGhlIG1vZGVsIGJlZm9yZSBpbnZva2luZyBgbmV4dGAgdG8gcmVuZGVyIHRoZSB2aWV3LlxcblxcbiAgICBUaGVuIHRoZXJlJ3MgYWxzbyB0aGUgY2xpZW50LXNpZGUgYXNwZWN0IG9mIHNldHRpbmcgdXAgVGF1bnVzLiBMZXQncyBzZXQgaXQgdXAgYW5kIHNlZSBob3cgaXQgb3BlbnMgdXAgb3VyIHBvc3NpYmlsaXRpZXMuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMgVGF1bnVzIGluIHRoZSBjbGllbnRcXG5cXG4gICAgWW91IGFscmVhZHkga25vdyBob3cgdG8gc2V0IHVwIHRoZSBiYXNpY3MgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZywgYW5kIHlvdSBrbm93IHRoYXQgeW91IHNob3VsZCBbY2hlY2sgb3V0IHRoZSBBUEkgZG9jdW1lbnRhdGlvbl1bMThdIHRvIGdldCBhIG1vcmUgdGhvcm91Z2ggdW5kZXJzdGFuZGluZyBvZiB0aGUgcHVibGljIGludGVyZmFjZSBvbiBUYXVudXMsIGFuZCB3aGF0IGl0IGVuYWJsZXMgeW91IHRvIGRvLlxcblxcbiAgICBUaGUgd2F5IFRhdW51cyB3b3JrcyBvbiB0aGUgY2xpZW50LXNpZGUgaXMgc28gdGhhdCBvbmNlIHlvdSBzZXQgaXQgdXAsIGl0IHdpbGwgaGlqYWNrIGxpbmsgY2xpY2tzIGFuZCB1c2UgQUpBWCB0byBmZXRjaCBtb2RlbHMgYW5kIHJlbmRlciB0aG9zZSB2aWV3cyBpbiB0aGUgY2xpZW50LiBJZiB0aGUgSmF2YVNjcmlwdCBjb2RlIGZhaWxzIHRvIGxvYWQsIF9vciBpZiBpdCBoYXNuJ3QgbG9hZGVkIHlldCBkdWUgdG8gYSBzbG93IGNvbm5lY3Rpb24gc3VjaCBhcyB0aG9zZSBpbiB1bnN0YWJsZSBtb2JpbGUgbmV0d29ya3NfLCB0aGUgcmVndWxhciBsaW5rIHdvdWxkIGJlIGZvbGxvd2VkIGluc3RlYWQgYW5kIG5vIGhhcm0gd291bGQgYmUgdW5sZWFzaGVkIHVwb24gdGhlIGh1bWFuLCBleGNlcHQgdGhleSB3b3VsZCBnZXQgYSBzbGlnaHRseSBsZXNzIGZhbmN5IGV4cGVyaWVuY2UuXFxuXFxuICAgIFNldHRpbmcgdXAgdGhlIGNsaWVudC1zaWRlIGludm9sdmVzIGEgZmV3IGRpZmZlcmVudCBzdGVwcy4gRmlyc3RseSwgd2UnbGwgaGF2ZSB0byBjb21waWxlIHRoZSBhcHBsaWNhdGlvbidzIHdpcmluZyBfKHRoZSByb3V0ZXMgYW5kIEphdmFTY3JpcHQgdmlldyBmdW5jdGlvbnMpXyBpbnRvIHNvbWV0aGluZyB0aGUgYnJvd3NlciB1bmRlcnN0YW5kcy4gVGhlbiwgeW91J2xsIGhhdmUgdG8gbW91bnQgVGF1bnVzIG9uIHRoZSBjbGllbnQtc2lkZSwgcGFzc2luZyB0aGUgd2lyaW5nIHNvIHRoYXQgaXQga25vd3Mgd2hpY2ggcm91dGVzIGl0IHNob3VsZCByZXNwb25kIHRvLCBhbmQgd2hpY2ggb3RoZXJzIGl0IHNob3VsZCBtZXJlbHkgaWdub3JlLiBPbmNlIHRoYXQncyBvdXQgb2YgdGhlIHdheSwgY2xpZW50LXNpZGUgcm91dGluZyB3b3VsZCBiZSBzZXQgdXAuXFxuXFxuICAgIEFzIHN1Z2FyIGNvYXRpbmcgb24gdG9wIG9mIHRoYXQsIHlvdSBtYXkgYWRkIGNsaWVudC1zaWRlIGZ1bmN0aW9uYWxpdHkgdXNpbmcgY29udHJvbGxlcnMuIFRoZXNlIGNvbnRyb2xsZXJzIHdvdWxkIGJlIGV4ZWN1dGVkIGV2ZW4gaWYgdGhlIHZpZXcgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXItc2lkZS4gVGhleSBjYW4gYWNjZXNzIHRoZSBUYXVudXMgQVBJIGRpcmVjdGx5LCBpbiBjYXNlIHlvdSBuZWVkIHRvIG5hdmlnYXRlIHRvIGFub3RoZXIgdmlldyBpbiBzb21lIHdheSBvdGhlciB0aGFuIGJ5IGhhdmluZyBodW1hbnMgY2xpY2sgb24gYW5jaG9yIHRhZ3MuIFRoZSBBUEksIGFzIHlvdSdsbCBsZWFybiwgd2lsbCBhbHNvIGxldCB5b3UgcmVuZGVyIHBhcnRpYWwgdmlld3MgdXNpbmcgdGhlIHBvd2VyZnVsIFRhdW51cyBlbmdpbmUsIGxpc3RlbiBmb3IgZXZlbnRzIHRoYXQgbWF5IG9jY3VyIGF0IGtleSBzdGFnZXMgb2YgdGhlIHZpZXctcmVuZGVyaW5nIHByb2Nlc3MsIGFuZCBldmVuIGludGVyY2VwdCBBSkFYIHJlcXVlc3RzIGJsb2NraW5nIHRoZW0gYmVmb3JlIHRoZXkgZXZlciBoYXBwZW4uXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVXNpbmcgdGhlIFRhdW51cyBDTElcXG5cXG4gICAgVGF1bnVzIGNvbWVzIHdpdGggYSBDTEkgdGhhdCBjYW4gYmUgdXNlZCB0byB3aXJlIHlvdXIgTm9kZS5qcyByb3V0ZXMgYW5kIHZpZXdzIGludG8gdGhlIGNsaWVudC1zaWRlLiBUaGUgc2FtZSBDTEkgY2FuIGJlIHVzZWQgdG8gd2lyZSB1cCB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlcnMgYXMgd2VsbC4gVGhlIG1haW4gcmVhc29uIHdoeSB0aGUgVGF1bnVzIENMSSBleGlzdHMgaXMgc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byBgcmVxdWlyZWAgZXZlcnkgc2luZ2xlIHZpZXcgYW5kIGNvbnRyb2xsZXIsIHVuZG9pbmcgYSBsb3Qgb2YgdGhlIHdvcmsgdGhhdCB3YXMgcHV0IGludG8gY29kZSByZXVzZS4gSnVzdCBsaWtlIHdlIGRpZCB3aXRoIGBqYWR1bWAgZWFybGllciwgd2UnbGwgaW5zdGFsbCB0aGUgYHRhdW51c2AgQ0xJIGdsb2JhbGx5IGZvciB0aGUgc2FrZSBvZiBleGVyY2lzaW5nLCBidXQgd2UgdW5kZXJzdGFuZCB0aGF0IHJlbHlpbmcgb24gZ2xvYmFsbHkgaW5zdGFsbGVkIG1vZHVsZXMgaXMgaW5zdWZmaWNpZW50IGZvciBwcm9kdWN0aW9uLWdyYWRlIGFwcGxpY2F0aW9ucy5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbnBtIGluc3RhbGwgLS1nbG9iYWwgdGF1bnVzXFxuICAgIGBgYFxcblxcbiAgICBCZWZvcmUgeW91IGNhbiB1c2UgdGhlIENMSSwgeW91IHNob3VsZCBtb3ZlIHRoZSByb3V0ZSBkZWZpbml0aW9ucyB0byBgY29udHJvbGxlcnMvcm91dGVzLmpzYC4gVGhhdCdzIHdoZXJlIFRhdW51cyBleHBlY3RzIHRoZW0gdG8gYmUuIElmIHlvdSB3YW50IHRvIHBsYWNlIHRoZW0gc29tZXRoaW5nIGVsc2UsIFt0aGUgQVBJIGRvY3VtZW50YXRpb24gY2FuIGhlbHAgeW91XVsxOF0uXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIG12IHJvdXRlcy5qcyBjb250cm9sbGVycy9yb3V0ZXMuanNcXG4gICAgYGBgXFxuXFxuICAgIFNpbmNlIHlvdSBtb3ZlZCB0aGUgcm91dGVzIHlvdSBzaG91bGQgYWxzbyB1cGRhdGUgdGhlIGByZXF1aXJlYCBzdGF0ZW1lbnQgaW4gdGhlIGBhcHAuanNgIG1vZHVsZS5cXG5cXG4gICAgYGBganNcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgdGF1bnVzID0gcmVxdWlyZSgndGF1bnVzJyk7XFxuICAgIHZhciB0YXVudXNFeHByZXNzID0gcmVxdWlyZSgndGF1bnVzLWV4cHJlc3MnKTtcXG4gICAgdmFyIGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XFxuICAgIHZhciBhcHAgPSBleHByZXNzKCk7XFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIHJvdXRlczogcmVxdWlyZSgnLi9jb250cm9sbGVycy9yb3V0ZXMnKSxcXG4gICAgICBsYXlvdXQ6IHJlcXVpcmUoJy4vLmJpbi92aWV3cy9sYXlvdXQnKVxcbiAgICB9O1xcblxcbiAgICB0YXVudXNFeHByZXNzKHRhdW51cywgYXBwLCBvcHRpb25zKTtcXG4gICAgYXBwLmxpc3RlbigzMDAwKTtcXG4gICAgYGBgXFxuXFxuICAgIFRoZSBDTEkgaXMgdGVyc2UgaW4gYm90aCBpdHMgaW5wdXRzIGFuZCBpdHMgb3V0cHV0cy4gSWYgeW91IHJ1biBpdCB3aXRob3V0IGFueSBhcmd1bWVudHMgaXQnbGwgcHJpbnQgb3V0IHRoZSB3aXJpbmcgbW9kdWxlLCBhbmQgaWYgeW91IHdhbnQgdG8gcGVyc2lzdCBpdCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIGAtLW91dHB1dGAgZmxhZy4gSW4gdHlwaWNhbCBbY29udmVudGlvbi1vdmVyLWNvbmZpZ3VyYXRpb25dWzhdIGZhc2hpb24sIHRoZSBDTEkgd2lsbCBkZWZhdWx0IHRvIGluZmVycmluZyB5b3VyIHZpZXdzIGFyZSBsb2NhdGVkIGluIGAuYmluL3ZpZXdzYCBhbmQgdGhhdCB5b3Ugd2FudCB0aGUgd2lyaW5nIG1vZHVsZSB0byBiZSBwbGFjZWQgaW4gYC5iaW4vd2lyaW5nLmpzYCwgYnV0IHlvdSdsbCBiZSBhYmxlIHRvIGNoYW5nZSB0aGF0IGlmIGl0IGRvZXNuJ3QgbWVldCB5b3VyIG5lZWRzLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICB0YXVudXMgLS1vdXRwdXRcXG4gICAgYGBgXFxuXFxuICAgIEF0IHRoaXMgcG9pbnQgaW4gb3VyIGV4YW1wbGUsIHRoZSBDTEkgc2hvdWxkIGNyZWF0ZSBhIGAuYmluL3dpcmluZy5qc2AgZmlsZSB3aXRoIHRoZSBjb250ZW50cyBkZXRhaWxlZCBiZWxvdy4gQXMgeW91IGNhbiBzZWUsIGV2ZW4gaWYgYHRhdW51c2AgaXMgYW4gYXV0b21hdGVkIGNvZGUtZ2VuZXJhdGlvbiB0b29sLCBpdCdzIG91dHB1dCBpcyBhcyBodW1hbiByZWFkYWJsZSBhcyBhbnkgb3RoZXIgbW9kdWxlLlxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHZhciB0ZW1wbGF0ZXMgPSB7XFxuICAgICAgJ2hvbWUvaW5kZXgnOiByZXF1aXJlKCcuL3ZpZXdzL2hvbWUvaW5kZXguanMnKSxcXG4gICAgICAnbGF5b3V0JzogcmVxdWlyZSgnLi92aWV3cy9sYXlvdXQuanMnKVxcbiAgICB9O1xcblxcbiAgICB2YXIgY29udHJvbGxlcnMgPSB7XFxuICAgIH07XFxuXFxuICAgIHZhciByb3V0ZXMgPSBbXFxuICAgICAge1xcbiAgICAgICAgcm91dGU6ICcvJyxcXG4gICAgICAgIGFjdGlvbjogJ2hvbWUvaW5kZXgnXFxuICAgICAgfVxcbiAgICBdO1xcblxcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcXG4gICAgICBjb250cm9sbGVyczogY29udHJvbGxlcnMsXFxuICAgICAgcm91dGVzOiByb3V0ZXNcXG4gICAgfTtcXG4gICAgYGBgXFxuXFxuICAgICFbU2NyZWVuc2hvdCB3aXRoIGB0YXVudXNgIG91dHB1dF1bMzddXFxuXFxuICAgIE5vdGUgdGhhdCB0aGUgYGNvbnRyb2xsZXJzYCBvYmplY3QgaXMgZW1wdHkgYmVjYXVzZSB5b3UgaGF2ZW4ndCBjcmVhdGVkIGFueSBfY2xpZW50LXNpZGUgY29udHJvbGxlcnNfIHlldC4gV2UgY3JlYXRlZCBzZXJ2ZXItc2lkZSBjb250cm9sbGVycyBidXQgdGhvc2UgZG9uJ3QgaGF2ZSBhbnkgZWZmZWN0IGluIHRoZSBjbGllbnQtc2lkZSwgYmVzaWRlcyBkZXRlcm1pbmluZyB3aGF0IGdldHMgc2VudCB0byB0aGUgY2xpZW50LlxcblxcbiAgICA+ICoqVGhlIENMSSBjYW4gYmUgZW50aXJlbHkgaWdub3JlZCoqLiBZb3UgY291bGQgd3JpdGUgdGhlc2UgZGVmaW5pdGlvbnMgYnkgeW91cnNlbGYsIGJ1dCB5b3Ugd291bGQgaGF2ZSB0byByZW1lbWJlciB0byB1cGRhdGUgdGhlIHdpcmluZyBtb2R1bGUgd2hlbmV2ZXIgeW91IGFkZCwgY2hhbmdlLCBvciByZW1vdmUgYSB2aWV3LCBhIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIsIG9yIGEgcm91dGUuIERvaW5nIHRoYXQgd291bGQgYmUgY3VtYmVyc29tZSwgYW5kIHRoZSBDTEkgc29sdmVzIHRoYXQgcHJvYmxlbSBmb3IgdXMgYXQgdGhlIGV4cGVuc2Ugb2Ygb25lIGFkZGl0aW9uYWwgYnVpbGQgc3RlcC5cXG5cXG4gICAgRHVyaW5nIGRldmVsb3BtZW50LCB5b3UgY2FuIGFsc28gYWRkIHRoZSBgLS13YXRjaGAgZmxhZywgd2hpY2ggd2lsbCByZWJ1aWxkIHRoZSB3aXJpbmcgbW9kdWxlIGlmIGEgcmVsZXZhbnQgZmlsZSBjaGFuZ2VzLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICB0YXVudXMgLS1vdXRwdXQgLS13YXRjaFxcbiAgICBgYGBcXG5cXG4gICAgSWYgeW91J3JlIHVzaW5nIEhhcGkgaW5zdGVhZCBvZiBFeHByZXNzLCB5b3UnbGwgYWxzbyBuZWVkIHRvIHBhc3MgaW4gdGhlIGBoYXBpaWZ5YCB0cmFuc2Zvcm0gc28gdGhhdCByb3V0ZXMgZ2V0IGNvbnZlcnRlZCBpbnRvIHNvbWV0aGluZyB0aGUgY2xpZW50LXNpZGUgcm91dGluZyBtb2R1bGUgdW5kZXJzdGFuZC5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgdGF1bnVzIC0tb3V0cHV0IC0tdHJhbnNmb3JtIGhhcGlpZnlcXG4gICAgYGBgXFxuXFxuICAgIE5vdyB0aGF0IHlvdSB1bmRlcnN0YW5kIGhvdyB0byB1c2UgdGhlIENMSSBvciBidWlsZCB0aGUgd2lyaW5nIG1vZHVsZSBvbiB5b3VyIG93biwgYm9vdGluZyB1cCBUYXVudXMgb24gdGhlIGNsaWVudC1zaWRlIHdpbGwgYmUgYW4gZWFzeSB0aGluZyB0byBkbyFcXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBCb290aW5nIHVwIHRoZSBjbGllbnQtc2lkZSByb3V0ZXJcXG5cXG4gICAgT25jZSB3ZSBoYXZlIHRoZSB3aXJpbmcgbW9kdWxlLCBib290aW5nIHVwIHRoZSBjbGllbnQtc2lkZSBlbmdpbmUgaXMgcHJldHR5IGVhc3kuIFRhdW51cyBzdWdnZXN0cyB5b3UgdXNlIGBjbGllbnQvanNgIHRvIGtlZXAgYWxsIG9mIHlvdXIgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCBsb2dpYywgYnV0IHRoYXQgaXMgdXAgdG8geW91IHRvby4gRm9yIHRoZSBzYWtlIG9mIHRoaXMgZ3VpZGUsIGxldCdzIHN0aWNrIHRvIHRoZSBjb252ZW50aW9ucy5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgbWtkaXIgLXAgY2xpZW50L2pzXFxuICAgIHRvdWNoIGNsaWVudC9qcy9tYWluLmpzXFxuICAgIGBgYFxcblxcbiAgICBUaGUgYG1haW5gIG1vZHVsZSB3aWxsIGJlIHVzZWQgYXMgdGhlIF9lbnRyeSBwb2ludF8gb2YgeW91ciBhcHBsaWNhdGlvbiBvbiB0aGUgY2xpZW50LXNpZGUuIEhlcmUgeW91J2xsIG5lZWQgdG8gaW1wb3J0IGB0YXVudXNgLCB0aGUgd2lyaW5nIG1vZHVsZSB3ZSd2ZSBqdXN0IGJ1aWx0LCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIERPTSBlbGVtZW50IHdoZXJlIHlvdSBhcmUgcmVuZGVyaW5nIHlvdXIgcGFydGlhbCB2aWV3cy4gT25jZSB5b3UgaGF2ZSBhbGwgdGhhdCwgeW91IGNhbiBpbnZva2UgYHRhdW51cy5tb3VudGAuXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgdmFyIHRhdW51cyA9IHJlcXVpcmUoJ3RhdW51cycpO1xcbiAgICB2YXIgd2lyaW5nID0gcmVxdWlyZSgnLi4vLi4vLmJpbi93aXJpbmcnKTtcXG4gICAgdmFyIG1haW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbWFpbicpWzBdO1xcblxcbiAgICB0YXVudXMubW91bnQobWFpbiwgd2lyaW5nKTtcXG4gICAgYGBgXFxuXFxuICAgIFRoZSBtb3VudHBvaW50IHdpbGwgc2V0IHVwIHRoZSBjbGllbnQtc2lkZSBUYXVudXMgcm91dGVyIGFuZCBmaXJlIHRoZSBjbGllbnQtc2lkZSB2aWV3IGNvbnRyb2xsZXIgZm9yIHRoZSB2aWV3IHRoYXQgaGFzIGJlZW4gcmVuZGVyZWQgaW4gdGhlIHNlcnZlci1zaWRlLiBXaGVuZXZlciBhbiBhbmNob3IgbGluayBpcyBjbGlja2VkLCBUYXVudXMgd2lsbCBiZSBhYmxlIHRvIGhpamFjayB0aGF0IGNsaWNrIGFuZCByZXF1ZXN0IHRoZSBtb2RlbCB1c2luZyBBSkFYLCBidXQgb25seSBpZiBpdCBtYXRjaGVzIGEgdmlldyByb3V0ZS4gT3RoZXJ3aXNlIHRoZSBsaW5rIHdpbGwgYmVoYXZlIGp1c3QgbGlrZSBhbnkgbm9ybWFsIGxpbmsgd291bGQuXFxuXFxuICAgIEJ5IGRlZmF1bHQsIHRoZSBtb3VudHBvaW50IHdpbGwgaXNzdWUgYW4gQUpBWCByZXF1ZXN0IGZvciB0aGUgdmlldyBtb2RlbCBvZiB0aGUgc2VydmVyLXNpZGUgcmVuZGVyZWQgdmlldy4gVGhpcyBpcyBha2luIHRvIHdoYXQgZGVkaWNhdGVkIGNsaWVudC1zaWRlIHJlbmRlcmluZyBmcmFtZXdvcmtzIHN1Y2ggYXMgQW5ndWxhckpTIGRvLCB3aGVyZSB2aWV3cyBhcmUgb25seSByZW5kZXJlZCBhZnRlciBhbGwgdGhlIEphdmFTY3JpcHQgaGFzIGJlZW4gZG93bmxvYWRlZCwgcGFyc2VkLCBhbmQgZXhlY3V0ZWQuIEV4Y2VwdCBUYXVudXMgcHJvdmlkZXMgaHVtYW4tcmVhZGFibGUgY29udGVudCBmYXN0ZXIsIGJlZm9yZSB0aGUgSmF2YVNjcmlwdCBldmVuIGJlZ2lucyBkb3dubG9hZGluZywgYWx0aG91Z2ggaXQgd29uJ3QgYmUgZnVuY3Rpb25hbCB1bnRpbCB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlciBydW5zLlxcblxcbiAgICBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbmxpbmUgdGhlIHZpZXcgbW9kZWwgYWxvbmdzaWRlIHRoZSB2aWV3cyBpbiBhIGA8c2NyaXB0IHR5cGU9J3RleHQvdGF1bnVzJz5gIHRhZywgYnV0IHRoaXMgdGVuZHMgdG8gc2xvdyBkb3duIHRoZSBpbml0aWFsIHJlc3BvbnNlIChtb2RlbHMgYXJlIF90eXBpY2FsbHkgbGFyZ2VyXyB0aGFuIHRoZSByZXN1bHRpbmcgdmlld3MpLlxcblxcbiAgICBBIHRoaXJkIHN0cmF0ZWd5IGlzIHRoYXQgeW91IHJlcXVlc3QgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IG91dHNpZGUgb2YgVGF1bnVzLCBhbGxvd2luZyB5b3UgdG8gZmV0Y2ggYm90aCB0aGUgdmlldyBtb2RlbCBhbmQgVGF1bnVzIGl0c2VsZiBjb25jdXJyZW50bHksIGJ1dCB0aGF0J3MgaGFyZGVyIHRvIHNldCB1cC5cXG5cXG4gICAgVGhlIHRocmVlIGJvb3Rpbmcgc3RyYXRlZ2llcyBhcmUgZXhwbGFpbmVkIGluIFt0aGUgQVBJIGRvY3VtZW50YXRpb25dWzE4XSBhbmQgZnVydGhlciBkaXNjdXNzZWQgaW4gW3RoZSBvcHRpbWl6YXRpb24gZ3VpZGVdWzI1XS4gRm9yIG5vdywgdGhlIGRlZmF1bHQgc3RyYXRlZ3kgXyhgJ2F1dG8nYClfIHNob3VsZCBzdWZmaWNlLiBJdCBmZXRjaGVzIHRoZSB2aWV3IG1vZGVsIHVzaW5nIGFuIEFKQVggcmVxdWVzdCByaWdodCBhZnRlciBUYXVudXMgbG9hZHMuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgQWRkaW5nIGZ1bmN0aW9uYWxpdHkgaW4gYSBjbGllbnQtc2lkZSBjb250cm9sbGVyXFxuXFxuICAgIENsaWVudC1zaWRlIGNvbnRyb2xsZXJzIHJ1biB3aGVuZXZlciBhIHZpZXcgaXMgcmVuZGVyZWQsIGV2ZW4gaWYgaXQncyBhIHBhcnRpYWwuIFRoZSBjb250cm9sbGVyIGlzIHBhc3NlZCB0aGUgYG1vZGVsYCwgY29udGFpbmluZyB0aGUgbW9kZWwgdGhhdCB3YXMgdXNlZCB0byByZW5kZXIgdGhlIHZpZXc7IHRoZSBgcm91dGVgLCBicm9rZW4gZG93biBpbnRvIGl0cyBjb21wb25lbnRzOyBhbmQgdGhlIGBjb250YWluZXJgLCB3aGljaCBpcyB3aGF0ZXZlciBET00gZWxlbWVudCB0aGUgdmlldyB3YXMgcmVuZGVyZWQgaW50by5cXG5cXG4gICAgVGhlc2UgY29udHJvbGxlcnMgYXJlIGVudGlyZWx5IG9wdGlvbmFsLCB3aGljaCBtYWtlcyBzZW5zZSBzaW5jZSB3ZSdyZSBwcm9ncmVzc2l2ZWx5IGVuaGFuY2luZyB0aGUgYXBwbGljYXRpb246IGl0IG1pZ2h0IG5vdCBldmVuIGJlIG5lY2Vzc2FyeSEgTGV0J3MgYWRkIHNvbWUgY2xpZW50LXNpZGUgZnVuY3Rpb25hbGl0eSB0byB0aGUgZXhhbXBsZSB3ZSd2ZSBiZWVuIGJ1aWxkaW5nLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBta2RpciAtcCBjbGllbnQvanMvY29udHJvbGxlcnMvaG9tZVxcbiAgICB0b3VjaCBjbGllbnQvanMvY29udHJvbGxlcnMvaG9tZS9pbmRleC5qc1xcbiAgICBgYGBcXG5cXG4gICAgR3Vlc3Mgd2hhdD8gVGhlIGNvbnRyb2xsZXIgc2hvdWxkIGJlIGEgbW9kdWxlIHdoaWNoIGV4cG9ydHMgYSBmdW5jdGlvbi4gVGhhdCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdmlldyBpcyByZW5kZXJlZC4gRm9yIHRoZSBzYWtlIG9mIHNpbXBsaWNpdHkgd2UnbGwganVzdCBwcmludCB0aGUgYWN0aW9uIGFuZCB0aGUgbW9kZWwgdG8gdGhlIGNvbnNvbGUuIElmIHRoZXJlJ3Mgb25lIHBsYWNlIHdoZXJlIHlvdSdkIHdhbnQgdG8gZW5oYW5jZSB0aGUgZXhwZXJpZW5jZSwgY2xpZW50LXNpZGUgY29udHJvbGxlcnMgYXJlIHdoZXJlIHlvdSB3YW50IHRvIHB1dCB5b3VyIGNvZGUuXFxuXFxuICAgIGBgYGpzXFxuICAgICd1c2Ugc3RyaWN0JztcXG5cXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRhaW5lciwgcm91dGUpIHtcXG4gICAgICBjb25zb2xlLmxvZygnUmVuZGVyZWQgdmlldyAlcyB1c2luZyBtb2RlbDpcXFxcbiVzJywgcm91dGUuYWN0aW9uLCBKU09OLnN0cmluZ2lmeShtb2RlbCwgbnVsbCwgMikpO1xcbiAgICB9O1xcbiAgICBgYGBcXG5cXG4gICAgU2luY2Ugd2Ugd2VyZW4ndCB1c2luZyB0aGUgYC0td2F0Y2hgIGZsYWcgZnJvbSB0aGUgVGF1bnVzIENMSSwgeW91J2xsIGhhdmUgdG8gcmVjb21waWxlIHRoZSB3aXJpbmcgYXQgdGhpcyBwb2ludCwgc28gdGhhdCB0aGUgY29udHJvbGxlciBnZXRzIGFkZGVkIHRvIHRoYXQgbWFuaWZlc3QuXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIHRhdW51cyAtLW91dHB1dFxcbiAgICBgYGBcXG5cXG4gICAgT2YgY291cnNlLCB5b3UnbGwgbm93IGhhdmUgdG8gd2lyZSB1cCB0aGUgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCB1c2luZyBbQnJvd3NlcmlmeV1bMzhdIVxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIENvbXBpbGluZyB5b3VyIGNsaWVudC1zaWRlIEphdmFTY3JpcHRcXG5cXG4gICAgWW91J2xsIG5lZWQgdG8gY29tcGlsZSB0aGUgYGNsaWVudC9qcy9tYWluLmpzYCBtb2R1bGUsIG91ciBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbidzIGVudHJ5IHBvaW50LCB1c2luZyBCcm93c2VyaWZ5IHNpbmNlIHRoZSBjb2RlIGlzIHdyaXR0ZW4gdXNpbmcgQ29tbW9uSlMuIEluIHRoaXMgZXhhbXBsZSB5b3UnbGwgaW5zdGFsbCBgYnJvd3NlcmlmeWAgZ2xvYmFsbHkgdG8gY29tcGlsZSB0aGUgY29kZSwgYnV0IG5hdHVyYWxseSB5b3UnbGwgaW5zdGFsbCBpdCBsb2NhbGx5IHdoZW4gd29ya2luZyBvbiBhIHJlYWwtd29ybGQgYXBwbGljYXRpb24uXFxuXFxuICAgIGBgYHNoZWxsXFxuICAgIG5wbSBpbnN0YWxsIC0tZ2xvYmFsIGJyb3dzZXJpZnlcXG4gICAgYGBgXFxuXFxuICAgIE9uY2UgeW91IGhhdmUgdGhlIEJyb3dzZXJpZnkgQ0xJLCB5b3UnbGwgYmUgYWJsZSB0byBjb21waWxlIHRoZSBjb2RlIHJpZ2h0IGZyb20geW91ciBjb21tYW5kIGxpbmUuIFRoZSBgLWRgIGZsYWcgdGVsbHMgQnJvd3NlcmlmeSB0byBhZGQgYW4gaW5saW5lIHNvdXJjZSBtYXAgaW50byB0aGUgY29tcGlsZWQgYnVuZGxlLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBmb3IgdXMuIFRoZSBgLW9gIGZsYWcgcmVkaXJlY3RzIG91dHB1dCB0byB0aGUgaW5kaWNhdGVkIGZpbGUsIHdoZXJlYXMgdGhlIG91dHB1dCBpcyBwcmludGVkIHRvIHN0YW5kYXJkIG91dHB1dCBieSBkZWZhdWx0LlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBta2RpciAtcCAuYmluL3B1YmxpYy9qc1xcbiAgICBicm93c2VyaWZ5IGNsaWVudC9qcy9tYWluLmpzIC1kbyAuYmluL3B1YmxpYy9qcy9hbGwuanNcXG4gICAgYGBgXFxuXFxuICAgIFdlIGhhdmVuJ3QgZG9uZSBtdWNoIG9mIGFueXRoaW5nIHdpdGggdGhlIEV4cHJlc3MgYXBwbGljYXRpb24sIHNvIHlvdSdsbCBuZWVkIHRvIGFkanVzdCB0aGUgYGFwcC5qc2AgbW9kdWxlIHRvIHNlcnZlIHN0YXRpYyBhc3NldHMuIElmIHlvdSdyZSB1c2VkIHRvIEV4cHJlc3MsIHlvdSdsbCBub3RpY2UgdGhlcmUncyBub3RoaW5nIHNwZWNpYWwgYWJvdXQgaG93IHdlJ3JlIHVzaW5nIGBzZXJ2ZS1zdGF0aWNgLlxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBucG0gaW5zdGFsbCAtLXNhdmUgc2VydmUtc3RhdGljXFxuICAgIGBgYFxcblxcbiAgICBMZXQncyBjb25maWd1cmUgdGhlIGFwcGxpY2F0aW9uIHRvIHNlcnZlIHN0YXRpYyBhc3NldHMgZnJvbSBgLmJpbi9wdWJsaWNgLlxcblxcbiAgICBgYGBqc1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHZhciB0YXVudXMgPSByZXF1aXJlKCd0YXVudXMnKTtcXG4gICAgdmFyIHRhdW51c0V4cHJlc3MgPSByZXF1aXJlKCd0YXVudXMtZXhwcmVzcycpO1xcbiAgICB2YXIgZXhwcmVzcyA9IHJlcXVpcmUoJ2V4cHJlc3MnKTtcXG4gICAgdmFyIHNlcnZlU3RhdGljID0gcmVxdWlyZSgnc2VydmUtc3RhdGljJyk7XFxuICAgIHZhciBhcHAgPSBleHByZXNzKCk7XFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIHJvdXRlczogcmVxdWlyZSgnLi9jb250cm9sbGVycy9yb3V0ZXMnKSxcXG4gICAgICBsYXlvdXQ6IHJlcXVpcmUoJy4vLmJpbi92aWV3cy9sYXlvdXQnKVxcbiAgICB9O1xcblxcbiAgICBhcHAudXNlKHNlcnZlU3RhdGljKCcuYmluL3B1YmxpYycpKTtcXG4gICAgdGF1bnVzRXhwcmVzcyh0YXVudXMsIGFwcCwgb3B0aW9ucyk7XFxuICAgIGFwcC5saXN0ZW4oMzAwMCk7XFxuICAgIGBgYFxcblxcbiAgICBOZXh0IHVwLCB5b3UnbGwgaGF2ZSB0byBlZGl0IHRoZSBsYXlvdXQgdG8gaW5jbHVkZSB0aGUgY29tcGlsZWQgSmF2YVNjcmlwdCBidW5kbGUgZmlsZS5cXG5cXG4gICAgYGBgamFkZVxcbiAgICB0aXRsZT1tb2RlbC50aXRsZVxcbiAgICBtYWluIT1wYXJ0aWFsXFxuICAgIHNjcmlwdChzcmM9Jy9qcy9hbGwuanMnKVxcbiAgICBgYGBcXG5cXG4gICAgRG9uJ3QgZm9yZ2V0IHRvIGNvbXBpbGUgYGxheW91dC5qYWRlYCBhZ2Fpbi5cXG5cXG4gICAgYGBgc2hlbGxcXG4gICAgamFkdW0gdmlld3MvKiogLS1vdXRwdXQgLmJpblxcbiAgICBgYGBcXG5cXG4gICAgTGFzdGx5LCB5b3UgY2FuIGV4ZWN1dGUgdGhlIGFwcGxpY2F0aW9uIGFuZCBzZWUgaXQgaW4gYWN0aW9uIVxcblxcbiAgICBgYGBzaGVsbFxcbiAgICBub2RlIGFwcFxcbiAgICBgYGBcXG5cXG4gICAgIVtTY3JlZW5zaG90IHdpdGggYG5vZGUgYXBwYCBvdXRwdXRdWzM5XVxcblxcbiAgICBJZiB5b3Ugb3BlbiB0aGUgYXBwbGljYXRpb24gb24gYSB3ZWIgYnJvd3NlciwgeW91J2xsIG5vdGljZSB0aGF0IHRoZSBhcHByb3ByaWF0ZSBpbmZvcm1hdGlvbiB3aWxsIGJlIGxvZ2dlZCBpbnRvIHRoZSBkZXZlbG9wZXIgYGNvbnNvbGVgLlxcblxcbiAgICAhW1NjcmVlbnNob3Qgd2l0aCB0aGUgYXBwbGljYXRpb24gcnVubmluZyB1bmRlciBHb29nbGUgQ2hyb21lXVs0MF1cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCN0YWJsZS1vZi1jb250ZW50cyk8L3N1Yj5cXG5cXG4gICAgIyMjIyBVc2luZyB0aGUgY2xpZW50LXNpZGUgVGF1bnVzIEFQSVxcblxcbiAgICBUYXVudXMgZG9lcyBwcm92aWRlIFthIHRoaW4gQVBJXVsxOF0gaW4gdGhlIGNsaWVudC1zaWRlLiBVc2FnZSBvZiB0aGF0IEFQSSBiZWxvbmdzIG1vc3RseSBpbnNpZGUgdGhlIGJvZHkgb2YgY2xpZW50LXNpZGUgdmlldyBjb250cm9sbGVycywgYnV0IHRoZXJlJ3MgYSBmZXcgbWV0aG9kcyB5b3UgY2FuIHRha2UgYWR2YW50YWdlIG9mIG9uIGEgZ2xvYmFsIHNjYWxlIGFzIHdlbGwuXFxuXFxuICAgIFRhdW51cyBjYW4gbm90aWZ5IHlvdSB3aGVuZXZlciBpbXBvcnRhbnQgZXZlbnRzIG9jY3VyLlxcblxcbiAgICBFdmVudCAgICAgICAgICAgIHwgQXJndW1lbnRzICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgYCdzdGFydCdgICAgICAgICB8IGBjb250YWluZXIsIG1vZGVsLCByb3V0ZWAgfCBFbWl0dGVkIHdoZW4gYHRhdW51cy5tb3VudGAgZmluaXNoZWQgdGhlIHJvdXRlIHNldHVwIGFuZCBpcyBhYm91dCB0byBpbnZva2UgdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIuIFN1YnNjcmliZSB0byB0aGlzIGV2ZW50IGJlZm9yZSBjYWxsaW5nIGB0YXVudXMubW91bnRgLlxcbiAgICBgJ3JlbmRlcidgICAgICAgIHwgYGNvbnRhaW5lciwgbW9kZWwsIHJvdXRlYCB8IEEgdmlldyBoYXMganVzdCBiZWVuIHJlbmRlcmVkIGFuZCBpdHMgY2xpZW50LXNpZGUgY29udHJvbGxlciBpcyBhYm91dCB0byBiZSBpbnZva2VkXFxuICAgIGAnY2hhbmdlJ2AgICAgICAgfCBgcm91dGUsIG1vZGVsYCAgICAgICAgICAgIHwgU2FtZSBhcyBgJ3JlbmRlcidgLCBidXQgb25seSBpZiBgY29udGFpbmVyYCBpcyB0aGUgbW91bnRwb2ludCBhbmQgdGhlIHJvdXRlIGhhcyBjaGFuZ2VkLlxcbiAgICBgJ2ZldGNoLnN0YXJ0J2AgIHwgIGByb3V0ZSwgY29udGV4dGAgICAgICAgICB8IEVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3Qgc3RhcnRzLlxcbiAgICBgJ2ZldGNoLmRvbmUnYCAgIHwgIGByb3V0ZSwgY29udGV4dCwgZGF0YWAgICB8IEVtaXR0ZWQgd2hlbmV2ZXIgYW4gWEhSIHJlcXVlc3QgZW5kcyBzdWNjZXNzZnVsbHkuXFxuICAgIGAnZmV0Y2guYWJvcnQnYCAgfCAgYHJvdXRlLCBjb250ZXh0YCAgICAgICAgIHwgRW1pdHRlZCB3aGVuZXZlciBhbiBYSFIgcmVxdWVzdCBpcyBwdXJwb3NlbHkgYWJvcnRlZC5cXG4gICAgYCdmZXRjaC5lcnJvcidgICB8ICBgcm91dGUsIGNvbnRleHQsIGVycmAgICAgfCBFbWl0dGVkIHdoZW5ldmVyIGFuIFhIUiByZXF1ZXN0IHJlc3VsdHMgaW4gYW4gSFRUUCBlcnJvci5cXG5cXG4gICAgQmVzaWRlcyBldmVudHMsIHRoZXJlJ3MgYSBjb3VwbGUgbW9yZSBtZXRob2RzIHlvdSBjYW4gdXNlLiBUaGUgYHRhdW51cy5uYXZpZ2F0ZWAgbWV0aG9kIGFsbG93cyB5b3UgdG8gbmF2aWdhdGUgdG8gYSBVUkwgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBodW1hbiB0byBjbGljayBvbiBhbiBhbmNob3IgbGluay4gVGhlbiB0aGVyZSdzIGB0YXVudXMucGFydGlhbGAsIGFuZCB0aGF0IGFsbG93cyB5b3UgdG8gcmVuZGVyIGFueSBwYXJ0aWFsIHZpZXcgb24gYSBET00gZWxlbWVudCBvZiB5b3VyIGNob29zaW5nLCBhbmQgaXQnbGwgdGhlbiBpbnZva2UgaXRzIGNvbnRyb2xsZXIuIFlvdSdsbCBuZWVkIHRvIGNvbWUgdXAgd2l0aCB0aGUgbW9kZWwgeW91cnNlbGYsIHRob3VnaC5cXG5cXG4gICAgQXN0b25pc2hpbmdseSwgdGhlIEFQSSBpcyBmdXJ0aGVyIGRvY3VtZW50ZWQgaW4gW3RoZSBBUEkgZG9jdW1lbnRhdGlvbl1bMThdLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICAjIyMjIENhY2hpbmcgYW5kIFByZWZldGNoaW5nXFxuXFxuICAgIFtQZXJmb3JtYW5jZV1bMjVdIHBsYXlzIGFuIGltcG9ydGFudCByb2xlIGluIFRhdW51cy4gVGhhdCdzIHdoeSB0aGUgeW91IGNhbiBwZXJmb3JtIGNhY2hpbmcgYW5kIHByZWZldGNoaW5nIG9uIHRoZSBjbGllbnQtc2lkZSBqdXN0IGJ5IHR1cm5pbmcgb24gYSBwYWlyIG9mIGZsYWdzLiBCdXQgd2hhdCBkbyB0aGVzZSBmbGFncyBkbyBleGFjdGx5P1xcblxcbiAgICBXaGVuIHR1cm5lZCBvbiwgYnkgcGFzc2luZyBgeyBjYWNoZTogdHJ1ZSB9YCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIGZvciBgdGF1bnVzLm1vdW50YCwgdGhlIGNhY2hpbmcgbGF5ZXIgd2lsbCBtYWtlIHN1cmUgdGhhdCByZXNwb25zZXMgYXJlIGtlcHQgYXJvdW5kIGZvciBgMTVgIHNlY29uZHMuIFdoZW5ldmVyIGEgcm91dGUgbmVlZHMgYSBtb2RlbCBpbiBvcmRlciB0byByZW5kZXIgYSB2aWV3LCBpdCdsbCBmaXJzdCBhc2sgdGhlIGNhY2hpbmcgbGF5ZXIgZm9yIGEgZnJlc2ggY29weS4gSWYgdGhlIGNhY2hpbmcgbGF5ZXIgZG9lc24ndCBoYXZlIGEgY29weSwgb3IgaWYgdGhhdCBjb3B5IGlzIHN0YWxlIF8oaW4gdGhpcyBjYXNlLCBvbGRlciB0aGFuIGAxNWAgc2Vjb25kcylfLCB0aGVuIGFuIEFKQVggcmVxdWVzdCB3aWxsIGJlIGlzc3VlZCB0byB0aGUgc2VydmVyLiBPZiBjb3Vyc2UsIHRoZSBkdXJhdGlvbiBpcyBjb25maWd1cmFibGUuIElmIHlvdSB3YW50IHRvIHVzZSBhIHZhbHVlIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQsIHlvdSBzaG91bGQgc2V0IGBjYWNoZWAgdG8gYSBudW1iZXIgaW4gc2Vjb25kcyBpbnN0ZWFkIG9mIGp1c3QgYHRydWVgLlxcblxcbiAgICBTaW5jZSBUYXVudXMgdW5kZXJzdGFuZHMgdGhhdCBub3QgZXZlcnkgdmlldyBvcGVyYXRlcyB1bmRlciB0aGUgc2FtZSBjb25zdHJhaW50cywgeW91J3JlIGFsc28gYWJsZSB0byBzZXQgYSBgY2FjaGVgIGZyZXNobmVzcyBkdXJhdGlvbiBkaXJlY3RseSBpbiB5b3VyIHJvdXRlcy4gVGhlIGBjYWNoZWAgcHJvcGVydHkgaW4gcm91dGVzIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgdmFsdWUuXFxuXFxuICAgIFRoZXJlJ3MgY3VycmVudGx5IHR3byBjYWNoaW5nIHN0b3JlczogYSByYXcgaW4tbWVtb3J5IHN0b3JlLCBhbmQgYW4gW0luZGV4ZWREQl1bMjhdIHN0b3JlLiBJbmRleGVkREIgaXMgYW4gZW1iZWRkZWQgZGF0YWJhc2Ugc29sdXRpb24sIGFuZCB5b3UgY2FuIHRoaW5rIG9mIGl0IGxpa2UgYW4gYXN5bmNocm9ub3VzIHZlcnNpb24gb2YgYGxvY2FsU3RvcmFnZWAuIEl0IGhhcyBbc3VycHJpc2luZ2x5IGJyb2FkIGJyb3dzZXIgc3VwcG9ydF1bMjldLCBhbmQgaW4gdGhlIGNhc2VzIHdoZXJlIGl0J3Mgbm90IHN1cHBvcnRlZCB0aGVuIGNhY2hpbmcgaXMgZG9uZSBzb2xlbHkgaW4tbWVtb3J5LlxcblxcbiAgICBUaGUgcHJlZmV0Y2hpbmcgbWVjaGFuaXNtIGlzIGFuIGludGVyZXN0aW5nIHNwaW4tb2ZmIG9mIGNhY2hpbmcsIGFuZCBpdCByZXF1aXJlcyBjYWNoaW5nIHRvIGJlIGVuYWJsZWQgaW4gb3JkZXIgdG8gd29yay4gV2hlbmV2ZXIgaHVtYW5zIGhvdmVyIG92ZXIgYSBsaW5rLCBvciB3aGVuZXZlciB0aGV5IHB1dCB0aGVpciBmaW5nZXIgb24gb25lIG9mIHRoZW0gXyh0aGUgYHRvdWNoc3RhcnRgIGV2ZW50KV8sIHRoZSBwcmVmZXRjaGVyIHdpbGwgaXNzdWUgYW4gQUpBWCByZXF1ZXN0IGZvciB0aGUgdmlldyBtb2RlbCBmb3IgdGhhdCBsaW5rLlxcblxcbiAgICBJZiB0aGUgcmVxdWVzdCBlbmRzIHN1Y2Nlc3NmdWxseSB0aGVuIHRoZSByZXNwb25zZSB3aWxsIGJlIGNhY2hlZCBpbiB0aGUgc2FtZSB3YXkgYW55IG90aGVyIHZpZXcgd291bGQgYmUgY2FjaGVkLiBJZiB0aGUgaHVtYW4gaG92ZXJzIG92ZXIgYW5vdGhlciBsaW5rIHdoaWxlIHRoZSBwcmV2aW91cyBvbmUgaXMgc3RpbGwgYmVpbmcgcHJlZmV0Y2hlZCwgdGhlbiB0aGUgb2xkIHJlcXVlc3QgaXMgYWJvcnRlZCwgYXMgbm90IHRvIGRyYWluIHRoZWlyIF8ocG9zc2libHkgbGltaXRlZClfIEludGVybmV0IGNvbm5lY3Rpb24gYmFuZHdpZHRoLlxcblxcbiAgICBJZiB0aGUgaHVtYW4gY2xpY2tzIG9uIHRoZSBsaW5rIGJlZm9yZSBwcmVmZXRjaGluZyBpcyBjb21wbGV0ZWQsIGhlJ2xsIG5hdmlnYXRlIHRvIHRoZSB2aWV3IGFzIHNvb24gYXMgcHJlZmV0Y2hpbmcgZW5kcywgcmF0aGVyIHRoYW4gZmlyaW5nIGFub3RoZXIgcmVxdWVzdC4gVGhpcyBoZWxwcyBUYXVudXMgc2F2ZSBwcmVjaW91cyBtaWxsaXNlY29uZHMgd2hlbiBkZWFsaW5nIHdpdGggbGF0ZW5jeS1zZW5zaXRpdmUgb3BlcmF0aW9ucy5cXG5cXG4gICAgVHVybmluZyBwcmVmZXRjaGluZyBvbiBpcyBzaW1wbHkgYSBtYXR0ZXIgb2Ygc2V0dGluZyBgcHJlZmV0Y2hgIHRvIGB0cnVlYCBpbiB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gYHRhdW51cy5tb3VudGAuIEZvciBhZGRpdGlvbmFsIGluc2lnaHRzIGludG8gdGhlIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBUYXVudXMgY2FuIG9mZmVyLCBoZWFkIG92ZXIgdG8gdGhlIFtQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb25zXVsyNV0gZ3VpZGUuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMjIyMgVmVyc2lvbmluZ1xcblxcbiAgICBXaGVuIHlvdSBhbHRlciB5b3VyIHZpZXdzLCBjaGFuZ2UgY29udHJvbGxlcnMsIG9yIG1vZGlmeSB0aGUgbW9kZWxzLCBjaGFuY2VzIGFyZSB0aGUgY2xpZW50LXNpZGUgaXMgZ29pbmcgdG8gY29tZSBhY3Jvc3Mgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXNzdWVzLlxcblxcbiAgICAtIE91dGRhdGVkIHZpZXcgdGVtcGxhdGUgZnVuY3Rpb25zIGluIHRoZSBjbGllbnQtc2lkZSwgY2F1c2luZyBuZXcgbW9kZWxzIHRvIGJyZWFrXFxuICAgIC0gT3V0ZGF0ZWQgY2xpZW50LXNpZGUgY29udHJvbGxlcnMsIGNhdXNpbmcgbmV3IG1vZGVscyB0byBicmVhayBvciBtaXNzIG91dCBvbiBmdW5jdGlvbmFsaXR5XFxuICAgIC0gT3V0ZGF0ZWQgbW9kZWxzIGluIHRoZSBjYWNoZSwgY2F1c2luZyBuZXcgdmlld3Mgb3IgY29udHJvbGxlcnMgdG8gYnJlYWtcXG5cXG4gICAgVmVyc2lvbmluZyBoYW5kbGVzIHRoZXNlIGlzc3VlcyBncmFjZWZ1bGx5IG9uIHlvdXIgYmVoYWxmLiBUaGUgd2F5IGl0IHdvcmtzIGlzIHRoYXQgd2hlbmV2ZXIgeW91IGdldCBhIHJlc3BvbnNlIGZyb20gVGF1bnVzLCBhIF92ZXJzaW9uIHN0cmluZyAoY29uZmlndXJlZCBvbiB0aGUgc2VydmVyLXNpZGUpXyBpcyBpbmNsdWRlZCB3aXRoIGl0LiBJZiB0aGF0IHZlcnNpb24gc3RyaW5nIGRvZXNuJ3QgbWF0Y2ggdGhlIG9uZSBzdG9yZWQgaW4gdGhlIGNsaWVudCwgdGhlbiB0aGUgY2FjaGUgd2lsbCBiZSBmbHVzaGVkIGFuZCB0aGUgaHVtYW4gd2lsbCBiZSByZWRpcmVjdGVkLCBmb3JjaW5nIGEgZnVsbCBwYWdlIHJlbG9hZC5cXG5cXG4gICAgPiBUaGUgdmVyc2lvbmluZyBBUEkgaXMgdW5hYmxlIHRvIGhhbmRsZSBjaGFuZ2VzIHRvIHJvdXRlcywgYW5kIGl0J3MgdXAgdG8geW91IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBzdGF5cyBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aGVuIGl0IGNvbWVzIHRvIHJvdXRpbmcuXFxuICAgID5cXG4gICAgPiBWZXJzaW9uaW5nIGNhbid0IGludGVydmVuZSB3aGVuIHRoZSBjbGllbnQtc2lkZSBpcyBoZWF2aWx5IHJlbHlpbmcgb24gY2FjaGVkIHZpZXdzIGFuZCBtb2RlbHMsIGFuZCB0aGUgaHVtYW4gaXMgcmVmdXNpbmcgdG8gcmVsb2FkIHRoZWlyIGJyb3dzZXIuIFRoZSBzZXJ2ZXIgaXNuJ3QgYmVpbmcgYWNjZXNzZWQgYW5kIHRodXMgaXQgY2FuJ3QgY29tbXVuaWNhdGUgdGhhdCBldmVyeXRoaW5nIG9uIHRoZSBjYWNoZSBtYXkgaGF2ZSBiZWNvbWUgc3RhbGUuIFRoZSBnb29kIG5ld3MgaXMgdGhhdCB0aGUgaHVtYW4gd29uJ3Qgbm90aWNlIGFueSBvZGRpdGllcywgYXMgdGhlIHNpdGUgd2lsbCBjb250aW51ZSB0byB3b3JrIGFzIGhlIGtub3dzIGl0LiBXaGVuIGhlIGZpbmFsbHkgYXR0ZW1wdHMgdG8gdmlzaXQgc29tZXRoaW5nIHRoYXQgaXNuJ3QgY2FjaGVkLCBhIHJlcXVlc3QgaXMgbWFkZSwgYW5kIHRoZSB2ZXJzaW9uaW5nIGVuZ2luZSByZXNvbHZlcyB2ZXJzaW9uIGRpc2NyZXBhbmNpZXMgZm9yIHRoZW0uXFxuXFxuICAgIE1ha2luZyB1c2Ugb2YgdmVyc2lvbmluZyBpbnZvbHZlcyBzZXR0aW5nIHRoZSBgdmVyc2lvbmAgZmllbGQgaW4gdGhlIG9wdGlvbnMsIHdoZW4gaW52b2tpbmcgYHRhdW51cy5tb3VudGAgKipvbiBib3RoIHRoZSBzZXJ2ZXItc2lkZSBhbmQgdGhlIGNsaWVudC1zaWRlLCB1c2luZyB0aGUgc2FtZSB2YWx1ZSoqLiBUaGUgVGF1bnVzIHZlcnNpb24gc3RyaW5nIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG9uZSB5b3UgcHJvdmlkZWQsIHNvIHRoYXQgVGF1bnVzIHdpbGwga25vdyB0byBzdGF5IGFsZXJ0IGZvciBjaGFuZ2VzIHRvIFRhdW51cyBpdHNlbGYsIGFzIHdlbGwuXFxuXFxuICAgIFlvdSBtYXkgdXNlIHlvdXIgYnVpbGQgaWRlbnRpZmllciBvciB0aGUgYHZlcnNpb25gIGZpZWxkIGluIGBwYWNrYWdlLmpzb25gLCBidXQgdW5kZXJzdGFuZCB0aGF0IGl0IG1heSBjYXVzZSB0aGUgY2xpZW50LXNpZGUgdG8gZmx1c2ggdGhlIGNhY2hlIHRvbyBvZnRlbiBfKG1heWJlIGV2ZW4gb24gZXZlcnkgZGVwbG95bWVudClfLlxcblxcbiAgICBUaGUgZGVmYXVsdCB2ZXJzaW9uIHN0cmluZyBpcyBzZXQgdG8gYDFgLiBUaGUgVGF1bnVzIHZlcnNpb24gd2lsbCBiZSBwcmVwZW5kZWQgdG8geW91cnMsIHJlc3VsdGluZyBpbiBhIHZhbHVlIHN1Y2ggYXMgYHQzLjAuMDt2MWAgd2hlcmUgVGF1bnVzIGlzIHJ1bm5pbmcgdmVyc2lvbiBgMy4wLjBgIGFuZCB5b3VyIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgdmVyc2lvbiBgMWAuXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjdGFibGUtb2YtY29udGVudHMpPC9zdWI+XFxuXFxuICAgICMgVGhlIHNreSBpcyB0aGUgbGltaXQhXFxuXFxuICAgIFlvdSdyZSBub3cgZmFtaWxpYXIgd2l0aCBob3cgVGF1bnVzIHdvcmtzIG9uIGEgaGlnaC1sZXZlbC4gWW91IGhhdmUgY292ZXJlZCBhIGRlY2VudCBhbW91bnQgb2YgZ3JvdW5kLCBidXQgeW91IHNob3VsZG4ndCBzdG9wIHRoZXJlLlxcblxcbiAgICAtIExlYXJuIG1vcmUgYWJvdXQgW3RoZSBBUEkgVGF1bnVzIGhhc11bMThdIHRvIG9mZmVyXFxuICAgIC0gR28gdGhyb3VnaCB0aGUgW3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aXBzXVsyNV0uIFlvdSBtYXkgbGVhcm4gc29tZXRoaW5nIG5ldyFcXG4gICAgLSBfRmFtaWxpYXJpemUgeW91cnNlbGYgd2l0aCB0aGUgd2F5cyBvZiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudF9cXG4gICAgICAtIEplcmVteSBLZWl0aCBlbnVuY2lhdGVzIFtcXFwiQmUgcHJvZ3Jlc3NpdmVcXFwiXVsyMF1cXG4gICAgICAtIENocmlzdGlhbiBIZWlsbWFubiBhZHZvY2F0ZXMgZm9yIFtcXFwiUHJhZ21hdGljIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50XFxcIl1bMjZdXFxuICAgICAgLSBKYWtlIEFyY2hpYmFsZCBleHBsYWlucyBob3cgW1xcXCJQcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBpcyBmYXN0ZXJcXFwiXVsyMl1cXG4gICAgICAtIEkgYmxvZ2dlZCBhYm91dCBob3cgd2Ugc2hvdWxkIFtcXFwiU3RvcCBCcmVha2luZyB0aGUgV2ViXFxcIl1bMTddXFxuICAgICAgLSBHdWlsbGVybW8gUmF1Y2ggYXJndWVzIGZvciBbXFxcIjcgUHJpbmNpcGxlcyBvZiBSaWNoIFdlYiBBcHBsaWNhdGlvbnNcXFwiXVsyNF1cXG4gICAgICAtIEFhcm9uIEd1c3RhZnNvbiB3cml0ZXMgW1xcXCJVbmRlcnN0YW5kaW5nIFByb2dyZXNzaXZlIEVuaGFuY2VtZW50XFxcIl1bMjFdXFxuICAgICAgLSBPcmRlIFNhdW5kZXJzIGdpdmVzIGhpcyBwb2ludCBvZiB2aWV3IGluIFtcXFwiUHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9yIGZhdWx0IHRvbGVyYW5jZVxcXCJdWzIzXVxcbiAgICAtIFNpZnQgdGhyb3VnaCB0aGUgW2NvbXBsZW1lbnRhcnkgbW9kdWxlc11bMTVdLiBZb3UgbWF5IGZpbmQgc29tZXRoaW5nIHlvdSBoYWRuJ3QgdGhvdWdodCBvZiFcXG5cXG4gICAgQWxzbywgZ2V0IGludm9sdmVkIVxcblxcbiAgICAtIEZvcmsgdGhpcyByZXBvc2l0b3J5IGFuZCBbc2VuZCBzb21lIHB1bGwgcmVxdWVzdHNdWzE5XSB0byBpbXByb3ZlIHRoZXNlIGd1aWRlcyFcXG4gICAgLSBTZWUgc29tZXRoaW5nLCBzYXkgc29tZXRoaW5nISBJZiB5b3UgZGV0ZWN0IGEgYnVnLCBbcGxlYXNlIGNyZWF0ZSBhbiBpc3N1ZV1bMjddIVxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI3RhYmxlLW9mLWNvbnRlbnRzKTwvc3ViPlxcblxcbiAgICA+IFlvdSdsbCBmaW5kIGEgW2Z1bGwgZmxlZGdlZCB2ZXJzaW9uIG9mIHRoZSBHZXR0aW5nIFN0YXJ0ZWRdWzQxXSB0dXRvcmlhbCBhcHBsaWNhdGlvbiBvbiBHaXRIdWIuXFxuXFxuICAgIFsxXTogaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy90YXVudXMtZXhwcmVzc1xcbiAgICBbMl06IGh0dHBzOi8vZ2l0aHViLmNvbS90YXVudXMvdGF1bnVzLWhhcGlcXG4gICAgWzNdOiBodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL2hhcGlpZnlcXG4gICAgWzRdOiBodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL3RhdW51cy5iZXZhY3F1YS5pb1xcbiAgICBbNV06IGh0dHBzOi8vZ2l0aHViLmNvbS9wb255Zm9vL3Bvbnlmb29cXG4gICAgWzZdOiBodHRwOi8vZXhwcmVzc2pzLmNvbVxcbiAgICBbN106IGh0dHA6Ly9oYXBpanMuY29tXFxuICAgIFs4XTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252ZW50aW9uX292ZXJfY29uZmlndXJhdGlvblxcbiAgICBbOV06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUnVieV9vbl9SYWlsc1xcbiAgICBbMTBdOiBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xcbiAgICBbMTFdOiBodHRwczovL2dpdGh1Yi5jb20vamFkZWpzL2phZGVcXG4gICAgWzEyXTogaHR0cDovL21vemlsbGEuZ2l0aHViLmlvL251bmp1Y2tzL1xcbiAgICBbMTNdOiBodHRwOi8vaGFuZGxlYmFyc2pzLmNvbS9cXG4gICAgWzE0XTogaHR0cDovL3d3dy5lbWJlZGRlZGpzLmNvbS9cXG4gICAgWzE1XTogL2NvbXBsZW1lbnRzXFxuICAgIFsxNl06IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9qYWR1bVxcbiAgICBbMTddOiBodHRwOi8vcG9ueWZvby5jb20vc3RvcC1icmVha2luZy10aGUtd2ViXFxuICAgIFsxOF06IC9hcGlcXG4gICAgWzE5XTogaHR0cHM6Ly9naXRodWIuY29tL3RhdW51cy90YXVudXMuYmV2YWNxdWEuaW8vcHVsbHNcXG4gICAgWzIwXTogaHR0cHM6Ly9hZGFjdGlvLmNvbS9qb3VybmFsLzc3MDZcXG4gICAgWzIxXTogaHR0cDovL2FsaXN0YXBhcnQuY29tL2FydGljbGUvdW5kZXJzdGFuZGluZ3Byb2dyZXNzaXZlZW5oYW5jZW1lbnRcXG4gICAgWzIyXTogaHR0cDovL2pha2VhcmNoaWJhbGQuY29tLzIwMTMvcHJvZ3Jlc3NpdmUtZW5oYW5jZW1lbnQtaXMtZmFzdGVyL1xcbiAgICBbMjNdOiBodHRwczovL2RlY2FkZWNpdHkubmV0L2Jsb2cvMjAxMy8wOS8xNi9wcm9ncmVzc2l2ZS1lbmhhbmNlbWVudC1mb3ItZmF1bHQtdG9sZXJhbmNlXFxuICAgIFsyNF06IGh0dHA6Ly9yYXVjaGcuY29tLzIwMTQvNy1wcmluY2lwbGVzLW9mLXJpY2gtd2ViLWFwcGxpY2F0aW9ucy9cXG4gICAgWzI1XTogL3BlcmZvcm1hbmNlXFxuICAgIFsyNl06IGh0dHA6Ly9pY2FudC5jby51ay9hcnRpY2xlcy9wcmFnbWF0aWMtcHJvZ3Jlc3NpdmUtZW5oYW5jZW1lbnQvXFxuICAgIFsyN106IGh0dHBzOi8vZ2l0aHViLmNvbS90YXVudXMvdGF1bnVzL2lzc3Vlcy9uZXdcXG4gICAgWzI4XTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUElcXG4gICAgWzI5XTogaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxcbiAgICBbMzBdOiBodHRwOi8vaS5pbWd1ci5jb20vNFA4dk5lOS5wbmdcXG4gICAgWzMxXTogaHR0cDovL2kuaW1ndXIuY29tL244bUg0bU4ucG5nXFxuICAgIFszMl06IGh0dHA6Ly9pLmltZ3VyLmNvbS8wOGxuQ2VjLnBuZ1xcbiAgICBbMzNdOiBodHRwOi8vaS5pbWd1ci5jb20vd1VibkN5ay5wbmdcXG4gICAgWzM0XTogaHR0cDovL2kuaW1ndXIuY29tL3pqYUpZQ3EucG5nXFxuICAgIFszNV06IGh0dHA6Ly9pLmltZ3VyLmNvbS9OdkVXeDl6LnBuZ1xcbiAgICBbMzZdOiBodHRwOi8vaS5pbWd1ci5jb20vTGdaUkZuNS5wbmdcXG4gICAgWzM3XTogaHR0cDovL2kuaW1ndXIuY29tL2ZJRWU1VG0ucG5nXFxuICAgIFszOF06IGh0dHA6Ly9icm93c2VyaWZ5Lm9yZy9cXG4gICAgWzM5XTogaHR0cDovL2kuaW1ndXIuY29tLzY4Tzg0d1gucG5nXFxuICAgIFs0MF06IGh0dHA6Ly9pLmltZ3VyLmNvbS9aVUY2TkZsLnBuZ1xcbiAgICBbNDFdOiBodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL2dldHRpbmctc3RhcnRlZFxcbiAgICBbNDJdOiBodHRwczovL2dpdGh1Yi5jb20vdGF1bnVzL2dlbmVyYXRvci10YXVudXNcXG5cIik7XG59XG59IiwidmFyIGphZGUgPSByZXF1aXJlKFwiamFkdW0vcnVudGltZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGVyZm9ybWFuY2UobG9jYWxzKSB7XG52YXIgamFkZV9kZWJ1ZyA9IFt7IGxpbmVubzogMSwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9wZXJmb3JtYW5jZS5qYWRlXCIgfV07XG50cnkge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2RvY3VtZW50YXRpb24vcGVyZm9ybWFuY2UuamFkZVwiIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAxLCBmaWxlbmFtZTogXCJ2aWV3cy9kb2N1bWVudGF0aW9uL3BlcmZvcm1hbmNlLmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPHNlY3Rpb24gY2xhc3M9XFxcImx5LXNlY3Rpb24gbWQtbWFya2Rvd25cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMiwgZmlsZW5hbWU6IFwidmlld3MvZG9jdW1lbnRhdGlvbi9wZXJmb3JtYW5jZS5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMSBpZD1cXFwicGVyZm9ybWFuY2Utb3B0aW1pemF0aW9uXFxcIj5QZXJmb3JtYW5jZSBPcHRpbWl6YXRpb248L2gxPlxcbjxwPkdpdmVuIHRoYXQgcGVyZm9ybWFuY2UgaXMgb25lIG9mIHRoZSBjb3JlIHZhbHVlcyBpbiBib3RoIFRhdW51cyBhbmQgVXNlciBFeHBlcmllbmNlLCBpdCBkZXNlcnZlZCBhIGZpcnN0LWNsYXNzIGFydGljbGUgb24gdGhpcyBzaXRlIGFzIHdlbGwuPC9wPlxcbjxwPlRoZXJlJiMzOTtzIGEgZmV3IHRoaW5ncyB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGRldmVsb3BpbmcgYW4gYXBwbGljYXRpb24gaWYgd2Ugd2FudCB0byBzdHJpdmUgZm9yIHBlcmZvcm1hbmNlLCBhbmQgdGhpcyBhcnRpY2xlIGFpbXMgdG8gYmUgYSBjb2xsZWN0aW9uIG9mIHdlYiBwZXJmb3JtYW5jZSBiZXN0IHByYWN0aWNlcyBhbG9uZyB3aXRoIHRpcHMgb24gaG93IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgZXNwZWNpZmljYWxseSBmb3IgYXBwbGljYXRpb25zIGJ1aWx0IG9uIHRvcCBvZiBUYXVudXMuPC9wPlxcbjxoMSBpZD1cXFwicGVyZm9ybWFuY2UtY2hlY2tsaXN0XFxcIj5QZXJmb3JtYW5jZSBDaGVja2xpc3Q8L2gxPlxcbjxwPklmIHlvdSBoYXZlbiYjMzk7dCwgeW91IHNob3VsZCByZWFkIDxhIGhyZWY9XFxcImh0dHA6Ly9wb255Zm9vLmNvbS9hcnRpY2xlcy9jcml0aWNhbC1wYXRoLXBlcmZvcm1hbmNlLW9wdGltaXphdGlvblxcXCI+JnF1b3Q7Q3JpdGljYWwgUGF0aCBQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb24mcXVvdDs8L2E+IGFzIGEgc21hbGwgZ3VpZGUgb2YgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucyB5b3Ugc2hvdWxkIGFscmVhZHkgYmUgZG9pbmcuIFRoZSBsaXN0IGJlbG93IGNvbnRhaW5zIHNvbWUgb2Ygd2hhdCYjMzk7cyBkaXNjdXNzZWQgaW4gdGhhdCBhcnRpY2xlLjwvcD5cXG48dWw+XFxuPGxpPk1vdmUgYXdheSBmcm9tIGRlZGljYXRlZCBjbGllbnQtc2lkZSByZW5kZXJpbmc8L2xpPlxcbjxsaT5Vc2UgPGEgaHJlZj1cXFwiaHR0cDovL25naW54Lm9yZy9cXFwiPjxjb2RlPm5naW54PC9jb2RlPjwvYT4gYXMgYSByZXZlcnNlIHByb3h5IGZvciB5b3VyIGZyb250LWVuZCBzZXJ2ZXJzPC9saT5cXG48bGk+UmVzaXplIGFuZCBvcHRpbWl6ZSBpbWFnZXM8L2xpPlxcbjxsaT5EZWZlciBub24tY3JpdGljYWwgc3RhdGljIGFzc2V0IGxvYWRpbmc8L2xpPlxcbjxsaT5JbmxpbmUgY3JpdGljYWwgQ1NTIGFuZCBKYXZhU2NyaXB0PC9saT5cXG48bGk+Q2FjaGUgcmVzcG9uc2VzIGFnZ3Jlc3NpdmVseTwvbGk+XFxuPGxpPkRpdGNoIGxhcmdlIGxpYnJhcmllcyBhbmQgZnJhbWV3b3JrczwvbGk+XFxuPC91bD5cXG48aDEgaWQ9XFxcImJvb3N0aW5nLXBlcmZvcm1hbmNlLXdpdGgtdGF1bnVzXFxcIj5Cb29zdGluZyBQZXJmb3JtYW5jZSB3aXRoIFRhdW51czwvaDE+XFxuPHA+V2hlbiBpdCBjb21lcyB0byBUYXVudXMsIHRoZXJlJiMzOTtzIGEgZmV3IG1vcmUgcGVyZm9ybWFuY2UgdHdlYWtzIHlvdSBzaG91bGQgY29uc2lkZXIgaW1wbGVtZW50aW5nLjwvcD5cXG48dWw+XFxuPGxpPkNob29zZSA8YSBocmVmPVxcXCIjY2hvb3NlLXRoZS1yaWdodC1ib290LXN0cmF0ZWd5XFxcIj50aGUgcmlnaHQgYm9vdCBzdHJhdGVneTwvYT48L2xpPlxcbjxsaT5UdXJuIG9uIGNsaWVudC1zaWRlIDxhIGhyZWY9XFxcIiN0dXJuLW9uLWNsaWVudC1zaWRlLWNhY2hpbmdcXFwiPmNhY2hpbmc8L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI3VzZS12ZXJzaW9uaW5nLXRvLWVuc3VyZS1jYWNoZS12YWxpZGl0eVxcXCI+VXNlIHZlcnNpb25pbmc8L2E+IHRvIGVuc3VyZSBjYWNoZSB2YWxpZGl0eTwvbGk+XFxuPGxpPkVuYWJsZSBwcmVmZXRjaGluZyBmb3IgPGEgaHJlZj1cXFwiI2VuYWJsZS1wcmVmZXRjaGluZy1mb3ItcHJlZGljdGl2ZS1jYWNoZS1sb2FkaW5nXFxcIj5wcmVkaWN0aXZlIGNhY2hlIGxvYWRpbmc8L2E+PC9saT5cXG48bGk+PGEgaHJlZj1cXFwiI3NlbmQtdmlld3MtYW5kLWNvbnRyb2xsZXJzLXRvLXRoZS1jbGllbnQtc2VsZWN0aXZlbHlcXFwiPlNlbmQgdmlld3MgYW5kIGNvbnRyb2xsZXJzIHRvIHRoZSBjbGllbnQgc2VsZWN0aXZlbHk8L2E+PC9saT5cXG48L3VsPlxcbjxwPkdpdmVuIHRoYXQgdGhpcyBzaXRlIGlzIGFib3V0IFRhdW51cywgd2UmIzM5O2xsIGZvY3VzIG9uIHRoZSBUYXVudXMgdHdlYWtzLCBhcyB5b3UgY2FuIHJlYWRpbHkgc2NvdXIgdGhlIHdlYiBmb3IgZ2VuZXJhbCB3ZWIgcGVyZm9ybWFuY2UgYWR2aWNlLjwvcD5cXG48aDEgaWQ9XFxcImNob29zZS10aGUtcmlnaHQtYm9vdC1zdHJhdGVneVxcXCI+Q2hvb3NlIHRoZSByaWdodCBib290IHN0cmF0ZWd5PC9oMT5cXG48cD5UYXVudXMgbmVlZHMgdG8gY29uanVyZSB1cCBhIHZpZXcgbW9kZWwgc28gdGhhdCB5b3UgaGF2ZSBhY2Nlc3MgdG8gaXRzIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudC1zaWRlIHZpZXcgY29udHJvbGxlci4gVG8gdGhhdCBlbmQsIFRhdW51cyBvZmZlcnMgdGhyZWUgZGlmZmVyZW50IGJvb3Qgc3RyYXRlZ2llcyBiZWNhdXNlIHRoZXJlIGlzbiYjMzk7dCBhIG9uZS1zaXplLWZpdHMtYWxsIGFuc3dlciB0byB0aGUgcXVlc3Rpb24gPGVtPiZxdW90O3doaWNoIGJvb3Qgc3RyYXRlZ3kgaXMgdGhlIGJlc3Qgb25lIGZvciBtZT8mcXVvdDs8L2VtPi48L3A+XFxuPHA+V2hlbiB5b3Ugd2FudCBhIHJlbGF4ZWQgYXBwcm9hY2ggdG8gdXNpbmcgVGF1bnVzLCB5b3Ugc2hvdWxkIGdvIGZvciB0aGUgPGEgaHJlZj1cXFwiL2FwaSN1c2luZy10aGUtYXV0by1zdHJhdGVneVxcXCI+PGNvZGU+YXV0bzwvY29kZT48L2E+IHN0cmF0ZWd5LiBNYXliZSB5b3UmIzM5O3JlIGp1c3QgZ2V0dGluZyBzdGFydGVkIG9yIHlvdSYjMzk7cmUgbm90IGFzIGNvbmNlcm5lZCBhYm91dCBwZXJmb3JtYW5jZSBqdXN0IHlldC4gSGVyZSBUYXVudXMgd2lsbCB3YWl0IG9uIHlvdSB0byBjYWxsIDxhIGhyZWY9XFxcIi9hcGkjLXRhdW51cy1tb3VudC1jb250YWluZXItd2lyaW5nLW9wdGlvbnMtXFxcIj48Y29kZT50YXVudXMubW91bnQ8L2NvZGU+PC9hPiwgYW5kIHRoZW4gbWFrZSBhbiBBSkFYIHJlcXVlc3QgdG8gZ2V0IHRoZSBtb2RlbCBmb3IgdGhhdCB2aWV3IG9uIHlvdXIgYmVoYWxmLiA8ZW0+VGhpcyBpcyB0aGUgc3RyYXRlZ3kgdGhhdCBUYXVudXMgdXNlcyBieSBkZWZhdWx0LjwvZW0+PC9wPlxcbjxwPklmIHlvdXIgbW9kZWxzIGFyZSBjb25zaXN0ZW50bHkgc21hbGwgYmVjYXVzZSB5b3UgaGF2ZSBsaXR0bGUgZHluYW1pYyBjb250ZW50LCBvciBpZiB5b3Ugd2FudCB0byA8ZW0+ZXhlY3V0ZSB0aGUgY2xpZW50LXNpZGUgY29udHJvbGxlciBhcyBxdWlja2x5IGFzIHBvc3NpYmxlPC9lbT4sIHRoZW4gdGhlIDxhIGhyZWY9XFxcIi9hcGkjdXNpbmctdGhlLWlubGluZS1zdHJhdGVneVxcXCI+PGNvZGU+aW5saW5lPC9jb2RlPjwvYT4gc3RyYXRlZ3kgbWlnaHQgYmUgdGhlIGJlc3QgZm9yIHlvdS4gSGVyZSB5b3UmIzM5O3JlIGV4cGVjdGVkIHRvIHBsYWNlIHRoZSBtb2RlbCBpbiBhIDxjb2RlPiZsdDtzY3JpcHQmZ3Q7PC9jb2RlPiB0YWcgaW5zaWRlIHRoZSB2aWV3IGxheW91dCwgYW5kIFRhdW51cyB0YWtlcyBjYXJlIG9mIHRoZSByZXN0LjwvcD5cXG48cD5UaGUgdGhpcmQgc3RyYXRlZ3kgaXMgPGEgaHJlZj1cXFwiL2FwaSN1c2luZy10aGUtbWFudWFsLXN0cmF0ZWd5XFxcIj48Y29kZT5tYW51YWw8L2NvZGU+PC9hPiwgd2hlcmUgeW91IGFyZSBzdXBwb3NlZCB0byBzb21laG93IGdldCBhIG1vZGVsLCBwcmVzdW1hYmx5IHVzaW5nIEFKQVggb3Igc2NyaXB0IGxvYWRpbmcsIGFuZCB0aGVuIGxldHRpbmcgVGF1bnVzIGtub3cgdGhhdCB5b3UmIzM5O3JlIGRvbmUuIFRoaXMgbWlnaHQgYmUgZmFzdGVyIHRoYW4gdGhlIDxhIGhyZWY9XFxcIi9hcGkjdXNpbmctdGhlLWF1dG8tc3RyYXRlZ3lcXFwiPjxjb2RlPmF1dG88L2NvZGU+PC9hPiBhcHByb2FjaCwgYmVjYXVzZSB5b3UgY291bGQgd3JpdGUgYW4gaW5saW5lIHNjcmlwdCB0byBmZXRjaCB0aGUgbW9kZWwgYXMgVGF1bnVzIGlzIGJlaW5nIGRvd25sb2FkZWQuIEl0IGFsc28gbWlnaHQgYmUgc2xvd2VyIHRoYW4gPGNvZGU+YXV0bzwvY29kZT4gaW4gdGhvc2UgY2FzZXMgd2hlcmUgPGNvZGU+YXV0bzwvY29kZT4gd291bGQmIzM5O3ZlIHVzZWQgYSBjYWNoZWQgY29weSBvZiB0aGUgbW9kZWwgaW5zdGVhZCBvZiBtYWtpbmcgYSByZXF1ZXN0LCBzbyA8ZW0+eW91ciBtaWxlYWdlIG1heSB2YXJ5PC9lbT4uPC9wPlxcbjxwPkZvciBtb3JlIGNvbXBsZXggdXNlIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gY29uc2lkZXIgbWl4aW5nIGRpZmZlcmVudCBib290IHN0cmF0ZWdpZXMsIGNob29zaW5nIHRoZSBvbmUgdGhhdCBtYWtlcyB0aGUgbW9zdCBzZW5zZSBpbiBlYWNoIGNhc2UuIEluIHRoZXNlIGNhc2VzLCB5b3UgbmVlZCB0byBwYXkgYXR0ZW50aW9uIHRvIGhhdmluZyBhbiBhZ3JlZW1lbnQgYmV0d2VlbiB3aGF0JiMzOTtzIGJlaW5nIGRvbmUgaW4gdGhlIHZpZXcgbGF5b3V0IDxlbT4oc2NyaXB0IGlubGluaW5nLCBBSkFYIGNhbGwsIG9yIGRvaW5nIG5vdGhpbmcpPC9lbT4gYW5kIHRoZSA8YSBocmVmPVxcXCIvYXBpIy10YXVudXMtbW91bnQtY29udGFpbmVyLXdpcmluZy1vcHRpb25zLVxcXCI+PGNvZGU+dGF1bnVzLm1vdW50PC9jb2RlPjwvYT4gY2FsbCA8ZW0+KHBpY2tpbmcgYSBib290IHN0cmF0ZWd5IHRoYXQgbWF0Y2hlcyB3aGF0JiMzOTtzIGJlaW5nIGRvbmUgb24gdGhlIGxheW91dCk8L2VtPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjYm9vc3RpbmctcGVyZm9ybWFuY2Utd2l0aC10YXVudXNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJ0dXJuLW9uLWNsaWVudC1zaWRlLWNhY2hpbmdcXFwiPlR1cm4gb24gY2xpZW50LXNpZGUgY2FjaGluZzwvaDE+XFxuPHA+QSBjYWNoaW5nIGVuZ2luZSBpcyBidWlsdCBpbnRvIFRhdW51cywgYW5kIGl0JiMzOTtzIHZlcnkgZWFzeSB0byBzZXQgdXAsIHlvdSBqdXN0IGhhdmUgdG8gYXNrIGZvciBpdCBieSBwYXNzaW5nIDxhIGhyZWY9XFxcIi9hcGkjY2FjaGluZ1xcXCI+PGNvZGU+Y2FjaGU6IHRydWU8L2NvZGU+PC9hPiB0byB0aGUgY2xpZW50LXNpZGUgbW91bnRwb2ludC4gVGhlIGNhY2hlIGNhbiBiZSB1c2VkIGFzIGEgbWVhbnMgdG8gYXZvaWQgbWFraW5nIGV4cGVuc2l2ZSBBSkFYIGNhbGxzIGZvciB3ZWxsLWRlZmluZWQgcGVyaW9kcyBvZiB0aW1lLiBZb3UgY2FuIGRldGVybWluZSBob3cgbG9uZyBhbiBpdGVtIHdpbGwgYmUgY2FjaGVkIGZvciBvbiBhIGdsb2JhbCBsZXZlbCwgYXMgd2VsbCBhcyBvbiBhIHJvdXRlLWJ5LXJvdXRlIGJhc2lzLjwvcD5cXG48cD5UYXVudXMgaW1wbGVtZW50cyBhIHR3by10aWVyZWQgY2FjaGUgaW4gd2hpY2ggaXRlbXMgYXJlIHBlcnNpc3RlZCBib3RoIGluLW1lbW9yeSBhbmQgaW4gYW4gSW5kZXhlZERCIGRhdGFiYXNlLiBUaGlzIHByb3ZpZGVzIGZhc3RlciBhY2Nlc3MgdG8gdGhlIGNhY2hlIHdoaWxlIGVuc3VyaW5nIHRoYXQgZGF0YSBwZXJzaXN0cyBhY3Jvc3MgYnJvd3NlciByZWxvYWRzLiBJbiBicm93c2VycyB0aGF0IGRvbiYjMzk7dCBzdXBwb3J0IEluZGV4ZWREQiwgb25seSB0aGUgaW4tbWVtb3J5IGNhY2hlIHdpbGwgYmUgdXNlZC48L3A+XFxuPGJsb2NrcXVvdGU+XFxuPHA+WW91IGNhbiBhbHNvIHVzZSBhIDxhIGhyZWY9XFxcIi9hcGkjLXRhdW51cy1pbnRlcmNlcHQtYWN0aW9uLWZuLVxcXCI+Y3VzdG9tIHJlcXVlc3QgaW50ZXJjZXB0b3I8L2E+IHRvIGxpc3RlbiBmb3IgcmVxdWVzdHMgYmVmb3JlIHRoZXkgYmVjb21lIEFKQVggY2FsbHMgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbm5pbmcuIFRoZSBjYWNoaW5nIGxheWVyIGlzIGluIGZhY3QgYnVpbHQgYXMgYSByZXF1ZXN0IGludGVyY2VwdG9yLiBZb3UgbWF5IHdhbnQgdG8gdXNlIG90aGVyIG1lY2hhbmlzbXMgZm9yIHByZXZlbnRpbmcgQUpBWCByZXF1ZXN0cyBmcm9tIGJlaW5nIG1hZGUsIHN1Y2ggYXMgaW5mZXJyaW5nIGEgbW9kZWwgZnJvbSB0aGUgbW9kZWxzIHRoYXQgd2VyZSBmZXRjaGVkIHNvIGZhciBmb3Igb3RoZXIgdmlld3MsIG9yIG1heWJlIHNpbXBseSBwcmV2ZW50aW5nIHRoZSByZXF1ZXN0IGZvciB2aWV3cyB0aGF0IGRvbiYjMzk7dCBuZWVkIGEgbW9kZWwgZnJvbSB0aGUgc2VydmVyIGF0IGFsbC48L3A+XFxuPC9ibG9ja3F1b3RlPlxcbjxwPlRoZSA8c3Ryb25nPmNhY2hlIGNhbiBzaWduaWZpY2FudGx5IGltcHJvdmUgeW91ciBhcHBsaWNhdGlvbiYjMzk7cyBwZXJjZWl2ZWQgcmVzcG9uc2l2ZW5lc3M8L3N0cm9uZz4sIGJ1dCBpdCBjb3VsZCBhbHNvIGRvIGRhbWFnZSBpZiB5b3VyIGFwcGxpY2F0aW9uIGlzIHVwZGF0ZWQgdG9vIGZyZXF1ZW50bHkgYnV0IHlvdSBjYWNoZSByZXNwb25zZXMgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lLiBJdCBjYW4gYWxzbyBwcm92ZSBwcm9ibGVtYXRpYyBpZiB0aGUgbW9kZWxzIGFyZSBoaWdobHkgdm9sYXRpbGUsIGFzIGEgY2FjaGVkIHJlc3BvbnNlIG1pZ2h0IGJlIHVzZWQgZm9yIGEgdmlldyB0aGF0IGV4cGVjdHMgc29tZSB2YWx1ZSB0byBjaGFuZ2UgZXZlcnkgdGltZS4gV2hpbGUgY2FjaGluZyBpc24mIzM5O3QgdGhlIHNvbHV0aW9uIHRvIHRoZSBsYXR0ZXIsIHRoZSBmb3JtZXIgY2FuIGJlIGFkZHJlc3NlZCB1c2luZyA8YSBocmVmPVxcXCIjdXNlLXZlcnNpb25pbmctdG8tZW5zdXJlLWNhY2hlLXZhbGlkaXR5XFxcIj52ZXJzaW9uaW5nPC9hPi48L3A+XFxuPHA+PHN1Yj48YSBocmVmPVxcXCIjYm9vc3RpbmctcGVyZm9ybWFuY2Utd2l0aC10YXVudXNcXFwiPjxlbT4oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cyk8L2VtPjwvYT48L3N1Yj48L3A+XFxuPGgxIGlkPVxcXCJ1c2UtdmVyc2lvbmluZy10by1lbnN1cmUtY2FjaGUtdmFsaWRpdHlcXFwiPlVzZSB2ZXJzaW9uaW5nIHRvIGVuc3VyZSBjYWNoZSB2YWxpZGl0eTwvaDE+XFxuPHA+VmVyc2lvbmluZyBpcyBhIHRvdWdoIHByb2JsZW0gdGhhdCBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbiBmcmFtZXdvcmtzIGRvbiYjMzk7dCBhZGRyZXNzLiBJZiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgcmVuZGVycyB5b3VyIGFwcGxpY2F0aW9uIGFzIGEgU1BBLCBob3cgZXhhY3RseSB3aWxsIGl0IGJlaGF2ZSB3aGVuIHlvdSBwdXNoIHVwZGF0ZXMgdG8gdGhlIHNlcnZlciwgPGEgaHJlZj1cXFwiaHR0cDovL2JldmFjcXVhLmlvL2JmXFxcIj5tYW55IHRpbWVzIGEgZGF5PC9hPj8gSXMgaXQgd2VsbCBkZWZpbmVkPyBXaWxsIHZpZXdzIHJlY2VpdmVkIGJlZm9yZSB0aGUgZGVwbG95bWVudCBiZSB1cGRhdGVkIHRvIHRoZSBsYXRlc3QgdmVyc2lvbj8gV2lsbCBtb2RlbHMgY2FjaGVkIGluIHRoZSBvbGQgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24gYmUgaW52YWxpZGF0ZWQ/IFdpbGwgbmV3IHZpZXdzIGFuZCBjbGllbnQtc2lkZSBjb250cm9sbGVycyBtYWtlIGl0IHRvIHRoZSB1c2VyPzwvcD5cXG48cD5UYXVudXMgaGFuZGxlcyBhbGwgb2YgdGhlc2Ugc2NlbmFyaW9zIGZvciB5b3UuIEV2ZXJ5IHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBjb250YWlucyB0aGUgY3VycmVudCB2ZXJzaW9uIHN0cmluZyBmb3IgeW91ciBhcHAuIElmIGEgcmVzcG9uc2UgdXBkYXRlcyB0aGUgdmVyc2lvbiBudW1iZXIgc3RvcmVkIGluIHRoZSBjbGllbnQsIGNhY2hlZCB2aWV3cywgY29udHJvbGxlcnMsIGFuZCBtb2RlbHMsIHdpbGwgYmVjb21lIGludmFsaWRhdGVkLjwvcD5cXG48cD5JZiBhdCBhbnkgcG9pbnQgVGF1bnVzIGlzIHJlbHlpbmcgc29sZWx5IG9uIHRoZSBjYWNoZSB0byByZW5kZXIgYSB2aWV3LCB0aGVuIHllcywgdGhlIHVzZXIgd2lsbCBzZWUgdGhlIHNhbWUgdmlldyB3aXRoIHRoZSBzYW1lIG1vZGVsIGFuZCB0aGUgc2FtZSBjb250cm9sbGVyIHRoYXQgaGUgc2F3IGEgZmV3IHNlY29uZHMgYWdvLiBCdXQgd2hlbmV2ZXIgYSByZXF1ZXN0IGhpdHMgdGhlIHNlcnZlciBhbmQgZ2V0cyBiYWNrIHRvIHRoZSBjbGllbnQgd2l0aCBhbiB1cGRhdGVkIHZlcnNpb24gbnVtYmVyLCBUYXVudXMgd2lsbCBrbm93IHRvIHJlZGlyZWN0IHRoZSB1c2VyIDxlbT4ob3IgcmUtZmV0Y2ggZWFjaCB2aWV3KTwvZW0+IHNvIHRoYXQgdGhlIHVzZXIgZ2V0cyB0aGUgdXBncmFkZWQgZXhwZXJpZW5jZS48L3A+XFxuPGJsb2NrcXVvdGU+XFxuPHA+TW9zdCBpbXBvcnRhbnRseSwgdmVyc2lvbmluZyBtZWFucyB0aGF0IHJlc3BvbnNlcyBmcm9tIHRoZSBzZXJ2ZXIgd2lsbCBuZXZlciBicmVhayBjb21tdW5pY2F0aW9uIHdpdGggY2xpZW50cyB0aGF0IHdlcmUgY29ubmVjdGVkIGJlZm9yZSBhIGRlcGxveW1lbnQgaW50cm9kdWNlZCBhbiB1cGRhdGUsIGNoYW5naW5nIHRoZSBtb2RlbHMgdGhhdCB0aGUgc2VydmVyIHJldHVybnMsIHdoaWxlIHRoZSBjbGllbnQgZXhwZWN0ZWQgbW9kZWxzIHVzaW5nIGEgZGlmZmVyZW50IHN0cnVjdHVyZS48L3A+XFxuPC9ibG9ja3F1b3RlPlxcbjxwPlRvIDxhIGhyZWY9XFxcIi9hcGkjdmVyc2lvbmluZ1xcXCI+ZW5hYmxlIHZlcnNpb25pbmc8L2E+IHlvdSBqdXN0IGhhdmUgdG8gY2hvb3NlIGEgdmVyc2lvbiBudW1iZXIgb24gYm90aCB0aGUgc2VydmVyIGFuZCB0aGUgY2xpZW50IG1vdW50cG9pbnRzLiBUaGlzIG51bWJlciBzaG91bGQgYmUgdXBkYXRlZCB3aXRoIGRpc2NyZXRpb24sIGFzIGZyZXF1ZW50IGNoYW5nZXMgdG8gdGhlIHZlcnNpb24gbnVtYmVyIG1heSBkZWZlYXQgdGhlIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBvZiBjbGllbnQtc2lkZSByZW5kZXJpbmcuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI2Jvb3N0aW5nLXBlcmZvcm1hbmNlLXdpdGgtdGF1bnVzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMSBpZD1cXFwiZW5hYmxlLXByZWZldGNoaW5nLWZvci1wcmVkaWN0aXZlLWNhY2hlLWxvYWRpbmdcXFwiPkVuYWJsZSBwcmVmZXRjaGluZyBmb3IgcHJlZGljdGl2ZSBjYWNoZSBsb2FkaW5nPC9oMT5cXG48YmxvY2txdW90ZT5cXG48cD5QcmVmZXRjaGluZyBjYW4geWllbGQgaHVnZSBwZXJmb3JtYW5jZSBib29zdHMgYnkgc2ltcGx5IGlzc3VpbmcgcmVxdWVzdHMgYXMgc29vbiBhcyB0aGUgaHVtYW4gaGludHMgYXQgaGlzIGludGVyZXN0IHRvIGxvYWQgYSB2aWV3LjwvcD5cXG48L2Jsb2NrcXVvdGU+XFxuPHA+QnkgZGVmYXVsdCBUYXVudXMgc2hpcHMgd2l0aCBhbiA8ZW0+JnF1b3Q7b24taG92ZXIvb24tdG91Y2gtc3RhcnQmcXVvdDs8L2VtPiBwcmVmZXRjaGVyIHRoYXQgeW91IGNhbiBlbmFibGUganVzdCBieSA8YSBocmVmPVxcXCIvYXBpI3ByZWZldGNoaW5nXFxcIj5zZXR0aW5nIHRoZSA8Y29kZT5wcmVmZXRjaDogdHJ1ZTwvY29kZT4gb3B0aW9uPC9hPiBvbiB0aGUgY2xpZW50LXNpZGUgbW91bnRwb2ludC4gSXQgd29ya3MgYnkgc3RhcnRpbmcgdG8gZmV0Y2ggdGhlIG1vZGVsIGZvciBhIHZpZXcgYXMgc29vbiBhcyBodW1hbnMgaG92ZXIgb3ZlciBhbiBhbmNob3IgbGluaywgb3IgcHV0IHRoZWlyIGZpbmdlciBvbiBpdCBvbiBtb2JpbGUgZGV2aWNlcy4gV2hlbiB0aGUgaHVtYW4gZG9lcyBkZWNpZGUgdG8gY2xpY2sgb24gdGhlIGxpbmssIHRoZSBwcmVmZXRjaGVyIG1heSBiZSBkb25lLCBtZWFuaW5nIHRoYXQgdGhleSYjMzk7bGwgYmUgaW5zdGFudGx5IHJlZGlyZWN0ZWQuIElmIHRoZSBwcmVmZXRjaGVyIGlzIHN0aWxsIHdvcmtpbmcsIHlvdSYjMzk7ZCBzdGlsbCBiZSBtYWtpbmcgYSBzaG9ydGN1dCwgYXMgdGhlIHVzZXIgd2lsbCBiZSByZWRpcmVjdGVkIGFzIHNvb24gYXMgdGhlIHByZWZldGNoZXIgZmluaXNoZXMsIGdpdmluZyB5b3UgYSBoZWFkIHN0YXJ0IGFuZCByZXByZXNlbnRpbmcgYSBwZXJjZWl2ZWQgcGVyZm9ybWFuY2UgYm9vc3QuPC9wPlxcbjxwPllvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gcHJlZmV0Y2hpbmcgcnVsZXMuIE1heWJlIHlvdSYjMzk7ZCBsaWtlIHRvIHN0YXJ0IHByZWZldGNoaW5nIGEgdmlldyBhcyBzb29uIGFzIGh1bWFucyBzdGFydCBtb3ZpbmcgdGhlIG1vdXNlIGN1cnNvciB0b3dhcmRzIGEgbGluay4gV2hlbiB5b3UgY29uc2lkZXIgdGhhdCBhIHVzZXIgc2hvd3MgaW50ZW50IHRvIG5hdmlnYXRlIHRvIGFuIGFjdGlvbiwgeW91IGNhbiBjYWxsIDxhIGhyZWY9XFxcIi9hcGkjdXNpbmctdGF1bnVzLXByZWZldGNoLXVybC1lbGVtZW50LVxcXCI+PGNvZGU+dGF1bnVzLnByZWZldGNoPC9jb2RlPjwvYT4gYW5kIHN0YXJ0IGxvYWRpbmcgZXZlcnl0aGluZyBuZWNlc3NhcnkgZm9yIHRoZSB2aWV3IHRvIGJlIGltbWVkaWF0ZWx5IGxvYWRlZC48L3A+XFxuPHA+Tm90ZSB0aGF0IDxzdHJvbmc+dGhlIHByZWZldGNoZXIgY2FuIG9ubHkgbG9hZCA8ZW0+b25lIHJvdXRlPC9lbT4gYXQgYSB0aW1lPC9zdHJvbmc+LiBUaGlzIGlzIGJ5IGRlc2lnbiwgYXMgcHJlZmV0Y2hpbmcgbG90cyBvZiBsaW5rcyB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgaHVtYW4mIzM5O3MgY29ubmVjdGl2aXR5LCBkb2luZyBtb3JlIGhhcm0gdGhhbiBnb29kLiBJZiB0aGUgcHJlZmV0Y2hlciBpcyBhbHJlYWR5IGxvYWRpbmcgYSByb3V0ZSB3aGVuIGFub3RoZXIgYXR0ZW1wdCB0byBwcmVmZXRjaCBpcyByZWdpc3RlcmVkLCB0aGUgb2xkIHJlcXVlc3Qgd2lsbCBiZSBhYm9ydGVkIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIG5ldyBvbmUuPC9wPlxcbjxwPjxzdWI+PGEgaHJlZj1cXFwiI2Jvb3N0aW5nLXBlcmZvcm1hbmNlLXdpdGgtdGF1bnVzXFxcIj48ZW0+KGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpPC9lbT48L2E+PC9zdWI+PC9wPlxcbjxoMSBpZD1cXFwic2VuZC12aWV3cy1hbmQtY29udHJvbGxlcnMtdG8tdGhlLWNsaWVudC1zZWxlY3RpdmVseVxcXCI+U2VuZCB2aWV3cyBhbmQgY29udHJvbGxlcnMgdG8gdGhlIGNsaWVudCBzZWxlY3RpdmVseTwvaDE+XFxuPHA+VGhlIG1vc3QgYW1iaXRpb3VzIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aGF0IGNhbiBiZSBkb25lIHdpdGggVGF1bnVzIGlzIGRlZmVycmluZyBjbGllbnQtc2lkZSB2aWV3cyBhbmQgY29udHJvbGxlcnMuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNvbXBpbGUgZXZlcnkgdmlldyBhbmQgY29udHJvbGxlciwgYWxvbmdzaWRlIHJvdXRlcyBhbmQgVGF1bnVzIGl0c2VsZiwgYW5kIHNlbmQgZXZlcnl0aGluZyBpbiBhIHNpbmdsZSBidW5kbGUgdG8gdGhlIGNsaWVudC4gQXMgeW91ciBhcHBsaWNhdGlvbiBncm93cywgaXQgbWlnaHQgbm8gbG9uZ2VyIGJlIHByYWN0aWNhbCB0byBzZW5kIGV2ZXJ5dGhpbmcgdG9nZXRoZXIgaW4gYSBodWdlIGJ1bmRsZSwgYXMgcGVyZm9ybWFuY2Ugd291bGQgc3VmZmVyLjwvcD5cXG48cD5UYXVudXMgb2ZmZXJzIGEgbWVjaGFuaXNtIHRocm91Z2ggd2hpY2ggeW91IGNhbiBkZWZlciBzcGVjaWZpYyBhY3Rpb25zLCBvciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24uIFdoZW4gb25lIG9mIHRob3NlIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiBuZWVkcyB0byBiZSBsb2FkZWQsIGV2ZW4gd2hlbiB1c2luZyA8YSBocmVmPVxcXCIvYXBpIy10YXVudXMtcGFydGlhbC1jb250YWluZXItYWN0aW9uLW1vZGVsLVxcXCI+PGNvZGU+dGF1bnVzLnBhcnRpYWw8L2NvZGU+PC9hPiwgdGhlIHNlcnZlci1zaWRlIHdpbGwgYnVuZGxlIHRoZSB2aWV3IHRlbXBsYXRlIG1vZHVsZSBhbmQgdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgbW9kdWxlIGFuZCBzZW5kIHRoYXQgdG8gdGhlIGNsaWVudC4gVGhlIGNsaWVudCB0aGVuIHJ1bnMgPGNvZGU+ZXZhbDwvY29kZT4gb24gdGhlIGJ1bmRsZSBhbmQgcHJvY2VlZHMgdG8gc3RvcmUgaXQgaW4gaXRzIGNhY2hlLCB1c2luZyB0aGUgc2FtZSBjYWNoaW5nIG1lY2hhbmlzbSB0aGF0JiMzOTtzIHVzZWQgZm9yIG1vZGVscyA8ZW0+KGV4Y2VwdCB0aGF0IHZpZXdzIGFuZCBjb250cm9sbGVycyBvbmx5IGdvIHN0YWxlIGR1ZSB0byB2ZXJzaW9uIGNoYW5nZXMsIGFuZCBuZXZlciBiZWNhdXNlIG9mIGR1cmF0aW9ucyk8L2VtPi48L3A+XFxuPHA+VG8gbWFrZSB1c2Ugb2YgdGhlIGRlZmVycmFsIG1lY2hhbmlzbSB5b3UgaGF2ZSB0byB0YWtlIGEgZmV3IHRoaW5ncyBpbnRvIGNvbnNpZGVyYXRpb24uIEZpcnN0IG9mZiwgeW91JiMzOTtsbCBoYXZlIHRvIHVzZSB0aGUgPGEgaHJlZj1cXFwiL2FwaSMtZGVmZXItYWN0aW9ucy1cXFwiPjxjb2RlPi0tZGVmZXI8L2NvZGU+PC9hPiBmbGFnIGluIHRoZSBDTEkgdG8gc2VsZWN0IHRoZSBhY3Rpb25zIHlvdSB3YW50IHRvIGRlZmVyLiBGb3IgaW5zdGFuY2UsIGRvaW5nIDxjb2RlPnRhdW51cyAtLWRlZmVyIGFkbWluPC9jb2RlPiB3aWxsIGRlZmVyIGFsbCBhY3Rpb25zIGZvciB0aGUgPGNvZGU+YWRtaW48L2NvZGU+IGNvbnRyb2xsZXIuPC9wPlxcbjxwPkRlZmVycmVkIG1vZHVsZXMgYXJlIGJ1bmRsZWQgd2l0aCBCcm93c2VyaWZ5IGFuZCBnZXQgPHN0cm9uZz5zb3VyY2UgbWFwcyBieSBkZWZhdWx0PC9zdHJvbmc+LCBzbyBkZWJ1Z2dpbmcgdGhlbSBkdXJpbmcgZGV2ZWxvcG1lbnQgaXMgYXMgZWFzeSBhcyBkZWJ1Z2dpbmcgbm9uLWRlZmVycmVkIGNvbnRyb2xsZXJzIG9yIHZpZXcgdGVtcGxhdGUgZnVuY3Rpb25zLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW9yIGJ5IDxhIGhyZWY9XFxcIi9hcGkjLW9wdGlvbnMtZGVmZXJtaW5pZmllZC1cXFwiPnNldHRpbmcgPGNvZGU+ZGVmZXJNaW5pZmllZDogdHJ1ZTwvY29kZT4gYXQgdGhlIHNlcnZlci1zaWRlIG1vdW50cG9pbnQ8L2E+LCB3aGljaCB3aWxsIG1pbmlmeSB0aGUgYnVuZGxlIGFuZCBhbHNvIHJlbW92ZSB0aGUgc291cmNlbWFwLiBUaGVzZSBidW5kbGVzIGFyZSBnZW5lcmF0ZWQgdGhlIGZpcnN0IHRpbWUgdGhhdCB0aGV5IGdldCByZXF1ZXN0ZWQsIGFuZCBzdWJzZXF1ZW50IHJlcXVlc3RzIGZvciB0aGUgc2FtZSBidW5kbGUgd2lsbCByZWNlaXZlIGEgY29weSB0aGF0IGdldHMgY2FjaGVkIGluIG1lbW9yeS48L3A+XFxuPHA+WW91IGhhdmUgdG8gYmUgY2FyZWZ1bCB3aGVuIGRlZmVycmluZyB2aWV3cyBhbmQgY29udHJvbGxlcnMsIGFzIHRoZSBidW5kbGUgZm9yIGV2ZXJ5IGNvbXBvbmVudCB3aWxsIGJlIGNvbXBpbGVkIGluZGVwZW5kZW50bHkuIEhlcmUmIzM5O3MgYSBmZXcgY29uc2lkZXJhdGlvbnMgdG8gdGFrZSBpbiBtaW5kLjwvcD5cXG48dWw+XFxuPGxpPlVzZSA8Y29kZT5yZXF1aXJlKCYjMzk7dGF1bnVzL2dsb2JhbCYjMzk7KTwvY29kZT4gaW5zdGVhZCBvZiA8Y29kZT5yZXF1aXJlKCYjMzk7dGF1bnVzJiMzOTspPC9jb2RlPi4gVGhpcyB3YXkgeW91JiMzOTtsbCBhY2Nlc3MgVGF1bnVzIGdsb2JhbGx5IHdpdGhvdXQgZW1iZWRkaW5nIHRoZSBlbnRpcmUgbGlicmFyeSBhZ2Fpbi4gVGhpcyBpcyA8c3Ryb25nPm1hbmRhdG9yeSBmb3IgZGVmZXJyZWQgY29tcG9uZW50czwvc3Ryb25nPiB0aGF0IG5lZWQgdG8gYWNjZXNzIHRoZSA8Y29kZT50YXVudXM8L2NvZGU+IHB1YmxpYyBBUEk8L2xpPlxcbjxsaT5TaW1pbGFybHksIHRyeSBhbmQgbWFrZSB1c2Ugb2YgZ2xvYmFscyBmb3IgYW55IGxhcmdlIGxpYnJhcmllcyB5b3UgcGxhbiB0byB1c2Ugb24gZGVmZXJyZWQgY29tcG9uZW50cy4gRWFjaCBtb2R1bGUgeW91IHJlZmVyZW5jZSBnbG9iYWxseSBpcyBhIG1vZHVsZSB0aGF0JiMzOTtzIG5vdCBjb21waWxlZCBvbiBldmVyeSBjb21wb25lbnQgdGhhdCA8Y29kZT5yZXF1aXJlPC9jb2RlPnMgaXQuIFRoaXMgdHJhbnNsYXRlcyBpbnRvIGxlYW5lciByZXNwb25zZXMgd2hlbiBjbGllbnRzIG5lZWQgdG8gZmV0Y2ggYSB0ZW1wbGF0ZSBhbmQgYSBjbGllbnQtc2lkZSBjb250cm9sbGVyPC9saT5cXG48bGk+QXZvaWQgbWFpbnRhaW5pbmcgZ2xvYmFsIHN0YXRlIGFjcm9zcyB2aWV3IGNvbnRyb2xsZXJzIHVzaW5nIG1vZHVsZXMuIElmIHlvdSBuZWVkIHRvIGRvIHNvLCBjb25zaWRlciB1c2luZyBldmVudHMgaW5zdGVhZC4gRGVmZXJyZWQgbW9kdWxlcyBhcmUgc2VsZi1jb250YWluZWQsIG1lYW5pbmcgdGhhdCBldmVuIGlmIHR3byBzZXBhcmF0ZSBjb250cm9sbGVycyByZXF1aXJlIGEgPGNvZGU+Li9zdGF0ZTwvY29kZT4gbW9kdWxlLCBlYWNoIGNvbnRyb2xsZXIgd2lsbCBnZXQgaXRzIG93biBjb3B5IG9mIHRoZSA8Y29kZT4uL3N0YXRlPC9jb2RlPiBtb2R1bGUsIGFuZCBub3RoaW5nIHdpbGwgYmUgc2hhcmVkLjwvbGk+XFxuPC91bD5cXG48cD5JbiB0aGUgZnV0dXJlLCB0cmFuc3BvcnRzIG90aGVyIHRoYW4gQ29tbW9uSlMgbWF5IGJlIGF2YWlsYWJsZSBmb3IgZGVmaW5pbmcgY29udHJvbGxlcnMgYW5kIHZpZXcgdGVtcGxhdGVzIHRoYXQgY2FuIGJlIGRlZmVycmVkLCBidXQgZm9yIG5vdyB0aGF0JiMzOTtzIHRoZSBvbmx5IHZpYWJsZSB0cmFuc3BvcnQgd2hlbiBpdCBjb21lcyB0byBkZWZlcnJlZCBleGVjdXRpb24gaW4gVGF1bnVzLjwvcD5cXG48cD48c3ViPjxhIGhyZWY9XFxcIiNib29zdGluZy1wZXJmb3JtYW5jZS13aXRoLXRhdW51c1xcXCI+PGVtPihiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKTwvZW0+PC9hPjwvc3ViPjwvcD5cXG5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2VjdGlvbj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7fS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnVuZGVmaW5lZDp0eXBlb2YgdW5kZWZpbmVkIT09XCJ1bmRlZmluZWRcIj91bmRlZmluZWQ6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn0gY2F0Y2ggKGVycikge1xuICBqYWRlLnJldGhyb3coZXJyLCBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lLCBqYWRlX2RlYnVnWzBdLmxpbmVubywgXCJzZWN0aW9uLmx5LXNlY3Rpb24ubWQtbWFya2Rvd25cXG4gIDptYXJrZG93blxcbiAgICAjIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvblxcblxcbiAgICBHaXZlbiB0aGF0IHBlcmZvcm1hbmNlIGlzIG9uZSBvZiB0aGUgY29yZSB2YWx1ZXMgaW4gYm90aCBUYXVudXMgYW5kIFVzZXIgRXhwZXJpZW5jZSwgaXQgZGVzZXJ2ZWQgYSBmaXJzdC1jbGFzcyBhcnRpY2xlIG9uIHRoaXMgc2l0ZSBhcyB3ZWxsLlxcblxcbiAgICBUaGVyZSdzIGEgZmV3IHRoaW5ncyB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGRldmVsb3BpbmcgYW4gYXBwbGljYXRpb24gaWYgd2Ugd2FudCB0byBzdHJpdmUgZm9yIHBlcmZvcm1hbmNlLCBhbmQgdGhpcyBhcnRpY2xlIGFpbXMgdG8gYmUgYSBjb2xsZWN0aW9uIG9mIHdlYiBwZXJmb3JtYW5jZSBiZXN0IHByYWN0aWNlcyBhbG9uZyB3aXRoIHRpcHMgb24gaG93IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgZXNwZWNpZmljYWxseSBmb3IgYXBwbGljYXRpb25zIGJ1aWx0IG9uIHRvcCBvZiBUYXVudXMuXFxuXFxuICAgICMgUGVyZm9ybWFuY2UgQ2hlY2tsaXN0XFxuXFxuICAgIElmIHlvdSBoYXZlbid0LCB5b3Ugc2hvdWxkIHJlYWQgW1xcXCJDcml0aWNhbCBQYXRoIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvblxcXCJdWzFdIGFzIGEgc21hbGwgZ3VpZGUgb2YgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucyB5b3Ugc2hvdWxkIGFscmVhZHkgYmUgZG9pbmcuIFRoZSBsaXN0IGJlbG93IGNvbnRhaW5zIHNvbWUgb2Ygd2hhdCdzIGRpc2N1c3NlZCBpbiB0aGF0IGFydGljbGUuXFxuXFxuICAgIC0gTW92ZSBhd2F5IGZyb20gZGVkaWNhdGVkIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xcbiAgICAtIFVzZSBbYG5naW54YF1bMl0gYXMgYSByZXZlcnNlIHByb3h5IGZvciB5b3VyIGZyb250LWVuZCBzZXJ2ZXJzXFxuICAgIC0gUmVzaXplIGFuZCBvcHRpbWl6ZSBpbWFnZXNcXG4gICAgLSBEZWZlciBub24tY3JpdGljYWwgc3RhdGljIGFzc2V0IGxvYWRpbmdcXG4gICAgLSBJbmxpbmUgY3JpdGljYWwgQ1NTIGFuZCBKYXZhU2NyaXB0XFxuICAgIC0gQ2FjaGUgcmVzcG9uc2VzIGFnZ3Jlc3NpdmVseVxcbiAgICAtIERpdGNoIGxhcmdlIGxpYnJhcmllcyBhbmQgZnJhbWV3b3Jrc1xcblxcbiAgICAjIEJvb3N0aW5nIFBlcmZvcm1hbmNlIHdpdGggVGF1bnVzXFxuXFxuICAgIFdoZW4gaXQgY29tZXMgdG8gVGF1bnVzLCB0aGVyZSdzIGEgZmV3IG1vcmUgcGVyZm9ybWFuY2UgdHdlYWtzIHlvdSBzaG91bGQgY29uc2lkZXIgaW1wbGVtZW50aW5nLlxcblxcbiAgICAtIENob29zZSBbdGhlIHJpZ2h0IGJvb3Qgc3RyYXRlZ3ldKCNjaG9vc2UtdGhlLXJpZ2h0LWJvb3Qtc3RyYXRlZ3kpXFxuICAgIC0gVHVybiBvbiBjbGllbnQtc2lkZSBbY2FjaGluZ10oI3R1cm4tb24tY2xpZW50LXNpZGUtY2FjaGluZylcXG4gICAgLSBbVXNlIHZlcnNpb25pbmddKCN1c2UtdmVyc2lvbmluZy10by1lbnN1cmUtY2FjaGUtdmFsaWRpdHkpIHRvIGVuc3VyZSBjYWNoZSB2YWxpZGl0eVxcbiAgICAtIEVuYWJsZSBwcmVmZXRjaGluZyBmb3IgW3ByZWRpY3RpdmUgY2FjaGUgbG9hZGluZ10oI2VuYWJsZS1wcmVmZXRjaGluZy1mb3ItcHJlZGljdGl2ZS1jYWNoZS1sb2FkaW5nKVxcbiAgICAtIFtTZW5kIHZpZXdzIGFuZCBjb250cm9sbGVycyB0byB0aGUgY2xpZW50IHNlbGVjdGl2ZWx5XSgjc2VuZC12aWV3cy1hbmQtY29udHJvbGxlcnMtdG8tdGhlLWNsaWVudC1zZWxlY3RpdmVseSlcXG5cXG4gICAgR2l2ZW4gdGhhdCB0aGlzIHNpdGUgaXMgYWJvdXQgVGF1bnVzLCB3ZSdsbCBmb2N1cyBvbiB0aGUgVGF1bnVzIHR3ZWFrcywgYXMgeW91IGNhbiByZWFkaWx5IHNjb3VyIHRoZSB3ZWIgZm9yIGdlbmVyYWwgd2ViIHBlcmZvcm1hbmNlIGFkdmljZS5cXG5cXG4gICAgIyBDaG9vc2UgdGhlIHJpZ2h0IGJvb3Qgc3RyYXRlZ3lcXG5cXG4gICAgVGF1bnVzIG5lZWRzIHRvIGNvbmp1cmUgdXAgYSB2aWV3IG1vZGVsIHNvIHRoYXQgeW91IGhhdmUgYWNjZXNzIHRvIGl0cyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQtc2lkZSB2aWV3IGNvbnRyb2xsZXIuIFRvIHRoYXQgZW5kLCBUYXVudXMgb2ZmZXJzIHRocmVlIGRpZmZlcmVudCBib290IHN0cmF0ZWdpZXMgYmVjYXVzZSB0aGVyZSBpc24ndCBhIG9uZS1zaXplLWZpdHMtYWxsIGFuc3dlciB0byB0aGUgcXVlc3Rpb24gX1xcXCJ3aGljaCBib290IHN0cmF0ZWd5IGlzIHRoZSBiZXN0IG9uZSBmb3IgbWU/XFxcIl8uXFxuXFxuICAgIFdoZW4geW91IHdhbnQgYSByZWxheGVkIGFwcHJvYWNoIHRvIHVzaW5nIFRhdW51cywgeW91IHNob3VsZCBnbyBmb3IgdGhlIFtgYXV0b2BdWzNdIHN0cmF0ZWd5LiBNYXliZSB5b3UncmUganVzdCBnZXR0aW5nIHN0YXJ0ZWQgb3IgeW91J3JlIG5vdCBhcyBjb25jZXJuZWQgYWJvdXQgcGVyZm9ybWFuY2UganVzdCB5ZXQuIEhlcmUgVGF1bnVzIHdpbGwgd2FpdCBvbiB5b3UgdG8gY2FsbCBbYHRhdW51cy5tb3VudGBdWzVdLCBhbmQgdGhlbiBtYWtlIGFuIEFKQVggcmVxdWVzdCB0byBnZXQgdGhlIG1vZGVsIGZvciB0aGF0IHZpZXcgb24geW91ciBiZWhhbGYuIF9UaGlzIGlzIHRoZSBzdHJhdGVneSB0aGF0IFRhdW51cyB1c2VzIGJ5IGRlZmF1bHQuX1xcblxcbiAgICBJZiB5b3VyIG1vZGVscyBhcmUgY29uc2lzdGVudGx5IHNtYWxsIGJlY2F1c2UgeW91IGhhdmUgbGl0dGxlIGR5bmFtaWMgY29udGVudCwgb3IgaWYgeW91IHdhbnQgdG8gX2V4ZWN1dGUgdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgYXMgcXVpY2tseSBhcyBwb3NzaWJsZV8sIHRoZW4gdGhlIFtgaW5saW5lYF1bNF0gc3RyYXRlZ3kgbWlnaHQgYmUgdGhlIGJlc3QgZm9yIHlvdS4gSGVyZSB5b3UncmUgZXhwZWN0ZWQgdG8gcGxhY2UgdGhlIG1vZGVsIGluIGEgYDxzY3JpcHQ+YCB0YWcgaW5zaWRlIHRoZSB2aWV3IGxheW91dCwgYW5kIFRhdW51cyB0YWtlcyBjYXJlIG9mIHRoZSByZXN0LlxcblxcbiAgICBUaGUgdGhpcmQgc3RyYXRlZ3kgaXMgW2BtYW51YWxgXVs2XSwgd2hlcmUgeW91IGFyZSBzdXBwb3NlZCB0byBzb21laG93IGdldCBhIG1vZGVsLCBwcmVzdW1hYmx5IHVzaW5nIEFKQVggb3Igc2NyaXB0IGxvYWRpbmcsIGFuZCB0aGVuIGxldHRpbmcgVGF1bnVzIGtub3cgdGhhdCB5b3UncmUgZG9uZS4gVGhpcyBtaWdodCBiZSBmYXN0ZXIgdGhhbiB0aGUgW2BhdXRvYF1bM10gYXBwcm9hY2gsIGJlY2F1c2UgeW91IGNvdWxkIHdyaXRlIGFuIGlubGluZSBzY3JpcHQgdG8gZmV0Y2ggdGhlIG1vZGVsIGFzIFRhdW51cyBpcyBiZWluZyBkb3dubG9hZGVkLiBJdCBhbHNvIG1pZ2h0IGJlIHNsb3dlciB0aGFuIGBhdXRvYCBpbiB0aG9zZSBjYXNlcyB3aGVyZSBgYXV0b2Agd291bGQndmUgdXNlZCBhIGNhY2hlZCBjb3B5IG9mIHRoZSBtb2RlbCBpbnN0ZWFkIG9mIG1ha2luZyBhIHJlcXVlc3QsIHNvIF95b3VyIG1pbGVhZ2UgbWF5IHZhcnlfLlxcblxcbiAgICBGb3IgbW9yZSBjb21wbGV4IHVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNvbnNpZGVyIG1peGluZyBkaWZmZXJlbnQgYm9vdCBzdHJhdGVnaWVzLCBjaG9vc2luZyB0aGUgb25lIHRoYXQgbWFrZXMgdGhlIG1vc3Qgc2Vuc2UgaW4gZWFjaCBjYXNlLiBJbiB0aGVzZSBjYXNlcywgeW91IG5lZWQgdG8gcGF5IGF0dGVudGlvbiB0byBoYXZpbmcgYW4gYWdyZWVtZW50IGJldHdlZW4gd2hhdCdzIGJlaW5nIGRvbmUgaW4gdGhlIHZpZXcgbGF5b3V0IF8oc2NyaXB0IGlubGluaW5nLCBBSkFYIGNhbGwsIG9yIGRvaW5nIG5vdGhpbmcpXyBhbmQgdGhlIFtgdGF1bnVzLm1vdW50YF1bNV0gY2FsbCBfKHBpY2tpbmcgYSBib290IHN0cmF0ZWd5IHRoYXQgbWF0Y2hlcyB3aGF0J3MgYmVpbmcgZG9uZSBvbiB0aGUgbGF5b3V0KV8uXFxuXFxuICAgIDxzdWI+W18oYmFjayB0byB0YWJsZSBvZiBjb250ZW50cylfXSgjYm9vc3RpbmctcGVyZm9ybWFuY2Utd2l0aC10YXVudXMpPC9zdWI+XFxuXFxuICAgICMgVHVybiBvbiBjbGllbnQtc2lkZSBjYWNoaW5nXFxuXFxuICAgIEEgY2FjaGluZyBlbmdpbmUgaXMgYnVpbHQgaW50byBUYXVudXMsIGFuZCBpdCdzIHZlcnkgZWFzeSB0byBzZXQgdXAsIHlvdSBqdXN0IGhhdmUgdG8gYXNrIGZvciBpdCBieSBwYXNzaW5nIFtgY2FjaGU6IHRydWVgXVs3XSB0byB0aGUgY2xpZW50LXNpZGUgbW91bnRwb2ludC4gVGhlIGNhY2hlIGNhbiBiZSB1c2VkIGFzIGEgbWVhbnMgdG8gYXZvaWQgbWFraW5nIGV4cGVuc2l2ZSBBSkFYIGNhbGxzIGZvciB3ZWxsLWRlZmluZWQgcGVyaW9kcyBvZiB0aW1lLiBZb3UgY2FuIGRldGVybWluZSBob3cgbG9uZyBhbiBpdGVtIHdpbGwgYmUgY2FjaGVkIGZvciBvbiBhIGdsb2JhbCBsZXZlbCwgYXMgd2VsbCBhcyBvbiBhIHJvdXRlLWJ5LXJvdXRlIGJhc2lzLlxcblxcbiAgICBUYXVudXMgaW1wbGVtZW50cyBhIHR3by10aWVyZWQgY2FjaGUgaW4gd2hpY2ggaXRlbXMgYXJlIHBlcnNpc3RlZCBib3RoIGluLW1lbW9yeSBhbmQgaW4gYW4gSW5kZXhlZERCIGRhdGFiYXNlLiBUaGlzIHByb3ZpZGVzIGZhc3RlciBhY2Nlc3MgdG8gdGhlIGNhY2hlIHdoaWxlIGVuc3VyaW5nIHRoYXQgZGF0YSBwZXJzaXN0cyBhY3Jvc3MgYnJvd3NlciByZWxvYWRzLiBJbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgSW5kZXhlZERCLCBvbmx5IHRoZSBpbi1tZW1vcnkgY2FjaGUgd2lsbCBiZSB1c2VkLlxcblxcbiAgICA+IFlvdSBjYW4gYWxzbyB1c2UgYSBbY3VzdG9tIHJlcXVlc3QgaW50ZXJjZXB0b3JdWzhdIHRvIGxpc3RlbiBmb3IgcmVxdWVzdHMgYmVmb3JlIHRoZXkgYmVjb21lIEFKQVggY2FsbHMgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbm5pbmcuIFRoZSBjYWNoaW5nIGxheWVyIGlzIGluIGZhY3QgYnVpbHQgYXMgYSByZXF1ZXN0IGludGVyY2VwdG9yLiBZb3UgbWF5IHdhbnQgdG8gdXNlIG90aGVyIG1lY2hhbmlzbXMgZm9yIHByZXZlbnRpbmcgQUpBWCByZXF1ZXN0cyBmcm9tIGJlaW5nIG1hZGUsIHN1Y2ggYXMgaW5mZXJyaW5nIGEgbW9kZWwgZnJvbSB0aGUgbW9kZWxzIHRoYXQgd2VyZSBmZXRjaGVkIHNvIGZhciBmb3Igb3RoZXIgdmlld3MsIG9yIG1heWJlIHNpbXBseSBwcmV2ZW50aW5nIHRoZSByZXF1ZXN0IGZvciB2aWV3cyB0aGF0IGRvbid0IG5lZWQgYSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIgYXQgYWxsLlxcblxcbiAgICBUaGUgKipjYWNoZSBjYW4gc2lnbmlmaWNhbnRseSBpbXByb3ZlIHlvdXIgYXBwbGljYXRpb24ncyBwZXJjZWl2ZWQgcmVzcG9uc2l2ZW5lc3MqKiwgYnV0IGl0IGNvdWxkIGFsc28gZG8gZGFtYWdlIGlmIHlvdXIgYXBwbGljYXRpb24gaXMgdXBkYXRlZCB0b28gZnJlcXVlbnRseSBidXQgeW91IGNhY2hlIHJlc3BvbnNlcyBmb3IgbG9uZyBwZXJpb2RzIG9mIHRpbWUuIEl0IGNhbiBhbHNvIHByb3ZlIHByb2JsZW1hdGljIGlmIHRoZSBtb2RlbHMgYXJlIGhpZ2hseSB2b2xhdGlsZSwgYXMgYSBjYWNoZWQgcmVzcG9uc2UgbWlnaHQgYmUgdXNlZCBmb3IgYSB2aWV3IHRoYXQgZXhwZWN0cyBzb21lIHZhbHVlIHRvIGNoYW5nZSBldmVyeSB0aW1lLiBXaGlsZSBjYWNoaW5nIGlzbid0IHRoZSBzb2x1dGlvbiB0byB0aGUgbGF0dGVyLCB0aGUgZm9ybWVyIGNhbiBiZSBhZGRyZXNzZWQgdXNpbmcgW3ZlcnNpb25pbmddKCN1c2UtdmVyc2lvbmluZy10by1lbnN1cmUtY2FjaGUtdmFsaWRpdHkpLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI2Jvb3N0aW5nLXBlcmZvcm1hbmNlLXdpdGgtdGF1bnVzKTwvc3ViPlxcblxcbiAgICAjIFVzZSB2ZXJzaW9uaW5nIHRvIGVuc3VyZSBjYWNoZSB2YWxpZGl0eVxcblxcbiAgICBWZXJzaW9uaW5nIGlzIGEgdG91Z2ggcHJvYmxlbSB0aGF0IHNpbmdsZS1wYWdlIGFwcGxpY2F0aW9uIGZyYW1ld29ya3MgZG9uJ3QgYWRkcmVzcy4gSWYgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHJlbmRlcnMgeW91ciBhcHBsaWNhdGlvbiBhcyBhIFNQQSwgaG93IGV4YWN0bHkgd2lsbCBpdCBiZWhhdmUgd2hlbiB5b3UgcHVzaCB1cGRhdGVzIHRvIHRoZSBzZXJ2ZXIsIFttYW55IHRpbWVzIGEgZGF5XVsxMF0/IElzIGl0IHdlbGwgZGVmaW5lZD8gV2lsbCB2aWV3cyByZWNlaXZlZCBiZWZvcmUgdGhlIGRlcGxveW1lbnQgYmUgdXBkYXRlZCB0byB0aGUgbGF0ZXN0IHZlcnNpb24/IFdpbGwgbW9kZWxzIGNhY2hlZCBpbiB0aGUgb2xkIHZlcnNpb24gb2YgdGhlIGFwcGxpY2F0aW9uIGJlIGludmFsaWRhdGVkPyBXaWxsIG5ldyB2aWV3cyBhbmQgY2xpZW50LXNpZGUgY29udHJvbGxlcnMgbWFrZSBpdCB0byB0aGUgdXNlcj9cXG5cXG4gICAgVGF1bnVzIGhhbmRsZXMgYWxsIG9mIHRoZXNlIHNjZW5hcmlvcyBmb3IgeW91LiBFdmVyeSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgY29udGFpbnMgdGhlIGN1cnJlbnQgdmVyc2lvbiBzdHJpbmcgZm9yIHlvdXIgYXBwLiBJZiBhIHJlc3BvbnNlIHVwZGF0ZXMgdGhlIHZlcnNpb24gbnVtYmVyIHN0b3JlZCBpbiB0aGUgY2xpZW50LCBjYWNoZWQgdmlld3MsIGNvbnRyb2xsZXJzLCBhbmQgbW9kZWxzLCB3aWxsIGJlY29tZSBpbnZhbGlkYXRlZC5cXG5cXG4gICAgSWYgYXQgYW55IHBvaW50IFRhdW51cyBpcyByZWx5aW5nIHNvbGVseSBvbiB0aGUgY2FjaGUgdG8gcmVuZGVyIGEgdmlldywgdGhlbiB5ZXMsIHRoZSB1c2VyIHdpbGwgc2VlIHRoZSBzYW1lIHZpZXcgd2l0aCB0aGUgc2FtZSBtb2RlbCBhbmQgdGhlIHNhbWUgY29udHJvbGxlciB0aGF0IGhlIHNhdyBhIGZldyBzZWNvbmRzIGFnby4gQnV0IHdoZW5ldmVyIGEgcmVxdWVzdCBoaXRzIHRoZSBzZXJ2ZXIgYW5kIGdldHMgYmFjayB0byB0aGUgY2xpZW50IHdpdGggYW4gdXBkYXRlZCB2ZXJzaW9uIG51bWJlciwgVGF1bnVzIHdpbGwga25vdyB0byByZWRpcmVjdCB0aGUgdXNlciBfKG9yIHJlLWZldGNoIGVhY2ggdmlldylfIHNvIHRoYXQgdGhlIHVzZXIgZ2V0cyB0aGUgdXBncmFkZWQgZXhwZXJpZW5jZS5cXG5cXG4gICAgPiBNb3N0IGltcG9ydGFudGx5LCB2ZXJzaW9uaW5nIG1lYW5zIHRoYXQgcmVzcG9uc2VzIGZyb20gdGhlIHNlcnZlciB3aWxsIG5ldmVyIGJyZWFrIGNvbW11bmljYXRpb24gd2l0aCBjbGllbnRzIHRoYXQgd2VyZSBjb25uZWN0ZWQgYmVmb3JlIGEgZGVwbG95bWVudCBpbnRyb2R1Y2VkIGFuIHVwZGF0ZSwgY2hhbmdpbmcgdGhlIG1vZGVscyB0aGF0IHRoZSBzZXJ2ZXIgcmV0dXJucywgd2hpbGUgdGhlIGNsaWVudCBleHBlY3RlZCBtb2RlbHMgdXNpbmcgYSBkaWZmZXJlbnQgc3RydWN0dXJlLlxcblxcbiAgICBUbyBbZW5hYmxlIHZlcnNpb25pbmddWzExXSB5b3UganVzdCBoYXZlIHRvIGNob29zZSBhIHZlcnNpb24gbnVtYmVyIG9uIGJvdGggdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudCBtb3VudHBvaW50cy4gVGhpcyBudW1iZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2l0aCBkaXNjcmV0aW9uLCBhcyBmcmVxdWVudCBjaGFuZ2VzIHRvIHRoZSB2ZXJzaW9uIG51bWJlciBtYXkgZGVmZWF0IHRoZSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgb2YgY2xpZW50LXNpZGUgcmVuZGVyaW5nLlxcblxcbiAgICA8c3ViPltfKGJhY2sgdG8gdGFibGUgb2YgY29udGVudHMpX10oI2Jvb3N0aW5nLXBlcmZvcm1hbmNlLXdpdGgtdGF1bnVzKTwvc3ViPlxcblxcbiAgICAjIEVuYWJsZSBwcmVmZXRjaGluZyBmb3IgcHJlZGljdGl2ZSBjYWNoZSBsb2FkaW5nXFxuXFxuICAgID4gUHJlZmV0Y2hpbmcgY2FuIHlpZWxkIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3RzIGJ5IHNpbXBseSBpc3N1aW5nIHJlcXVlc3RzIGFzIHNvb24gYXMgdGhlIGh1bWFuIGhpbnRzIGF0IGhpcyBpbnRlcmVzdCB0byBsb2FkIGEgdmlldy5cXG5cXG4gICAgQnkgZGVmYXVsdCBUYXVudXMgc2hpcHMgd2l0aCBhbiBfXFxcIm9uLWhvdmVyL29uLXRvdWNoLXN0YXJ0XFxcIl8gcHJlZmV0Y2hlciB0aGF0IHlvdSBjYW4gZW5hYmxlIGp1c3QgYnkgW3NldHRpbmcgdGhlIGBwcmVmZXRjaDogdHJ1ZWAgb3B0aW9uXVsxMl0gb24gdGhlIGNsaWVudC1zaWRlIG1vdW50cG9pbnQuIEl0IHdvcmtzIGJ5IHN0YXJ0aW5nIHRvIGZldGNoIHRoZSBtb2RlbCBmb3IgYSB2aWV3IGFzIHNvb24gYXMgaHVtYW5zIGhvdmVyIG92ZXIgYW4gYW5jaG9yIGxpbmssIG9yIHB1dCB0aGVpciBmaW5nZXIgb24gaXQgb24gbW9iaWxlIGRldmljZXMuIFdoZW4gdGhlIGh1bWFuIGRvZXMgZGVjaWRlIHRvIGNsaWNrIG9uIHRoZSBsaW5rLCB0aGUgcHJlZmV0Y2hlciBtYXkgYmUgZG9uZSwgbWVhbmluZyB0aGF0IHRoZXknbGwgYmUgaW5zdGFudGx5IHJlZGlyZWN0ZWQuIElmIHRoZSBwcmVmZXRjaGVyIGlzIHN0aWxsIHdvcmtpbmcsIHlvdSdkIHN0aWxsIGJlIG1ha2luZyBhIHNob3J0Y3V0LCBhcyB0aGUgdXNlciB3aWxsIGJlIHJlZGlyZWN0ZWQgYXMgc29vbiBhcyB0aGUgcHJlZmV0Y2hlciBmaW5pc2hlcywgZ2l2aW5nIHlvdSBhIGhlYWQgc3RhcnQgYW5kIHJlcHJlc2VudGluZyBhIHBlcmNlaXZlZCBwZXJmb3JtYW5jZSBib29zdC5cXG5cXG4gICAgWW91IGNhbiBhbHNvIGNyZWF0ZSB5b3VyIG93biBwcmVmZXRjaGluZyBydWxlcy4gTWF5YmUgeW91J2QgbGlrZSB0byBzdGFydCBwcmVmZXRjaGluZyBhIHZpZXcgYXMgc29vbiBhcyBodW1hbnMgc3RhcnQgbW92aW5nIHRoZSBtb3VzZSBjdXJzb3IgdG93YXJkcyBhIGxpbmsuIFdoZW4geW91IGNvbnNpZGVyIHRoYXQgYSB1c2VyIHNob3dzIGludGVudCB0byBuYXZpZ2F0ZSB0byBhbiBhY3Rpb24sIHlvdSBjYW4gY2FsbCBbYHRhdW51cy5wcmVmZXRjaGBdWzEzXSBhbmQgc3RhcnQgbG9hZGluZyBldmVyeXRoaW5nIG5lY2Vzc2FyeSBmb3IgdGhlIHZpZXcgdG8gYmUgaW1tZWRpYXRlbHkgbG9hZGVkLlxcblxcbiAgICBOb3RlIHRoYXQgKip0aGUgcHJlZmV0Y2hlciBjYW4gb25seSBsb2FkIF9vbmUgcm91dGVfIGF0IGEgdGltZSoqLiBUaGlzIGlzIGJ5IGRlc2lnbiwgYXMgcHJlZmV0Y2hpbmcgbG90cyBvZiBsaW5rcyB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgaHVtYW4ncyBjb25uZWN0aXZpdHksIGRvaW5nIG1vcmUgaGFybSB0aGFuIGdvb2QuIElmIHRoZSBwcmVmZXRjaGVyIGlzIGFscmVhZHkgbG9hZGluZyBhIHJvdXRlIHdoZW4gYW5vdGhlciBhdHRlbXB0IHRvIHByZWZldGNoIGlzIHJlZ2lzdGVyZWQsIHRoZSBvbGQgcmVxdWVzdCB3aWxsIGJlIGFib3J0ZWQgdG8gbWFrZSByb29tIGZvciB0aGUgbmV3IG9uZS5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCNib29zdGluZy1wZXJmb3JtYW5jZS13aXRoLXRhdW51cyk8L3N1Yj5cXG5cXG4gICAgIyBTZW5kIHZpZXdzIGFuZCBjb250cm9sbGVycyB0byB0aGUgY2xpZW50IHNlbGVjdGl2ZWx5XFxuXFxuICAgIFRoZSBtb3N0IGFtYml0aW91cyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdGhhdCBjYW4gYmUgZG9uZSB3aXRoIFRhdW51cyBpcyBkZWZlcnJpbmcgY2xpZW50LXNpZGUgdmlld3MgYW5kIGNvbnRyb2xsZXJzLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjb21waWxlIGV2ZXJ5IHZpZXcgYW5kIGNvbnRyb2xsZXIsIGFsb25nc2lkZSByb3V0ZXMgYW5kIFRhdW51cyBpdHNlbGYsIGFuZCBzZW5kIGV2ZXJ5dGhpbmcgaW4gYSBzaW5nbGUgYnVuZGxlIHRvIHRoZSBjbGllbnQuIEFzIHlvdXIgYXBwbGljYXRpb24gZ3Jvd3MsIGl0IG1pZ2h0IG5vIGxvbmdlciBiZSBwcmFjdGljYWwgdG8gc2VuZCBldmVyeXRoaW5nIHRvZ2V0aGVyIGluIGEgaHVnZSBidW5kbGUsIGFzIHBlcmZvcm1hbmNlIHdvdWxkIHN1ZmZlci5cXG5cXG4gICAgVGF1bnVzIG9mZmVycyBhIG1lY2hhbmlzbSB0aHJvdWdoIHdoaWNoIHlvdSBjYW4gZGVmZXIgc3BlY2lmaWMgYWN0aW9ucywgb3IgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLiBXaGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24gbmVlZHMgdG8gYmUgbG9hZGVkLCBldmVuIHdoZW4gdXNpbmcgW2B0YXVudXMucGFydGlhbGBdWzE0XSwgdGhlIHNlcnZlci1zaWRlIHdpbGwgYnVuZGxlIHRoZSB2aWV3IHRlbXBsYXRlIG1vZHVsZSBhbmQgdGhlIGNsaWVudC1zaWRlIGNvbnRyb2xsZXIgbW9kdWxlIGFuZCBzZW5kIHRoYXQgdG8gdGhlIGNsaWVudC4gVGhlIGNsaWVudCB0aGVuIHJ1bnMgYGV2YWxgIG9uIHRoZSBidW5kbGUgYW5kIHByb2NlZWRzIHRvIHN0b3JlIGl0IGluIGl0cyBjYWNoZSwgdXNpbmcgdGhlIHNhbWUgY2FjaGluZyBtZWNoYW5pc20gdGhhdCdzIHVzZWQgZm9yIG1vZGVscyBfKGV4Y2VwdCB0aGF0IHZpZXdzIGFuZCBjb250cm9sbGVycyBvbmx5IGdvIHN0YWxlIGR1ZSB0byB2ZXJzaW9uIGNoYW5nZXMsIGFuZCBuZXZlciBiZWNhdXNlIG9mIGR1cmF0aW9ucylfLlxcblxcbiAgICBUbyBtYWtlIHVzZSBvZiB0aGUgZGVmZXJyYWwgbWVjaGFuaXNtIHlvdSBoYXZlIHRvIHRha2UgYSBmZXcgdGhpbmdzIGludG8gY29uc2lkZXJhdGlvbi4gRmlyc3Qgb2ZmLCB5b3UnbGwgaGF2ZSB0byB1c2UgdGhlIFtgLS1kZWZlcmBdWzE1XSBmbGFnIGluIHRoZSBDTEkgdG8gc2VsZWN0IHRoZSBhY3Rpb25zIHlvdSB3YW50IHRvIGRlZmVyLiBGb3IgaW5zdGFuY2UsIGRvaW5nIGB0YXVudXMgLS1kZWZlciBhZG1pbmAgd2lsbCBkZWZlciBhbGwgYWN0aW9ucyBmb3IgdGhlIGBhZG1pbmAgY29udHJvbGxlci5cXG5cXG4gICAgRGVmZXJyZWQgbW9kdWxlcyBhcmUgYnVuZGxlZCB3aXRoIEJyb3dzZXJpZnkgYW5kIGdldCAqKnNvdXJjZSBtYXBzIGJ5IGRlZmF1bHQqKiwgc28gZGVidWdnaW5nIHRoZW0gZHVyaW5nIGRldmVsb3BtZW50IGlzIGFzIGVhc3kgYXMgZGVidWdnaW5nIG5vbi1kZWZlcnJlZCBjb250cm9sbGVycyBvciB2aWV3IHRlbXBsYXRlIGZ1bmN0aW9ucy4gWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvciBieSBbc2V0dGluZyBgZGVmZXJNaW5pZmllZDogdHJ1ZWAgYXQgdGhlIHNlcnZlci1zaWRlIG1vdW50cG9pbnRdWzE2XSwgd2hpY2ggd2lsbCBtaW5pZnkgdGhlIGJ1bmRsZSBhbmQgYWxzbyByZW1vdmUgdGhlIHNvdXJjZW1hcC4gVGhlc2UgYnVuZGxlcyBhcmUgZ2VuZXJhdGVkIHRoZSBmaXJzdCB0aW1lIHRoYXQgdGhleSBnZXQgcmVxdWVzdGVkLCBhbmQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhlIHNhbWUgYnVuZGxlIHdpbGwgcmVjZWl2ZSBhIGNvcHkgdGhhdCBnZXRzIGNhY2hlZCBpbiBtZW1vcnkuXFxuXFxuICAgIFlvdSBoYXZlIHRvIGJlIGNhcmVmdWwgd2hlbiBkZWZlcnJpbmcgdmlld3MgYW5kIGNvbnRyb2xsZXJzLCBhcyB0aGUgYnVuZGxlIGZvciBldmVyeSBjb21wb25lbnQgd2lsbCBiZSBjb21waWxlZCBpbmRlcGVuZGVudGx5LiBIZXJlJ3MgYSBmZXcgY29uc2lkZXJhdGlvbnMgdG8gdGFrZSBpbiBtaW5kLlxcblxcbiAgICAtIFVzZSBgcmVxdWlyZSgndGF1bnVzL2dsb2JhbCcpYCBpbnN0ZWFkIG9mIGByZXF1aXJlKCd0YXVudXMnKWAuIFRoaXMgd2F5IHlvdSdsbCBhY2Nlc3MgVGF1bnVzIGdsb2JhbGx5IHdpdGhvdXQgZW1iZWRkaW5nIHRoZSBlbnRpcmUgbGlicmFyeSBhZ2Fpbi4gVGhpcyBpcyAqKm1hbmRhdG9yeSBmb3IgZGVmZXJyZWQgY29tcG9uZW50cyoqIHRoYXQgbmVlZCB0byBhY2Nlc3MgdGhlIGB0YXVudXNgIHB1YmxpYyBBUElcXG4gICAgLSBTaW1pbGFybHksIHRyeSBhbmQgbWFrZSB1c2Ugb2YgZ2xvYmFscyBmb3IgYW55IGxhcmdlIGxpYnJhcmllcyB5b3UgcGxhbiB0byB1c2Ugb24gZGVmZXJyZWQgY29tcG9uZW50cy4gRWFjaCBtb2R1bGUgeW91IHJlZmVyZW5jZSBnbG9iYWxseSBpcyBhIG1vZHVsZSB0aGF0J3Mgbm90IGNvbXBpbGVkIG9uIGV2ZXJ5IGNvbXBvbmVudCB0aGF0IGByZXF1aXJlYHMgaXQuIFRoaXMgdHJhbnNsYXRlcyBpbnRvIGxlYW5lciByZXNwb25zZXMgd2hlbiBjbGllbnRzIG5lZWQgdG8gZmV0Y2ggYSB0ZW1wbGF0ZSBhbmQgYSBjbGllbnQtc2lkZSBjb250cm9sbGVyXFxuICAgIC0gQXZvaWQgbWFpbnRhaW5pbmcgZ2xvYmFsIHN0YXRlIGFjcm9zcyB2aWV3IGNvbnRyb2xsZXJzIHVzaW5nIG1vZHVsZXMuIElmIHlvdSBuZWVkIHRvIGRvIHNvLCBjb25zaWRlciB1c2luZyBldmVudHMgaW5zdGVhZC4gRGVmZXJyZWQgbW9kdWxlcyBhcmUgc2VsZi1jb250YWluZWQsIG1lYW5pbmcgdGhhdCBldmVuIGlmIHR3byBzZXBhcmF0ZSBjb250cm9sbGVycyByZXF1aXJlIGEgYC4vc3RhdGVgIG1vZHVsZSwgZWFjaCBjb250cm9sbGVyIHdpbGwgZ2V0IGl0cyBvd24gY29weSBvZiB0aGUgYC4vc3RhdGVgIG1vZHVsZSwgYW5kIG5vdGhpbmcgd2lsbCBiZSBzaGFyZWQuXFxuXFxuICAgIEluIHRoZSBmdXR1cmUsIHRyYW5zcG9ydHMgb3RoZXIgdGhhbiBDb21tb25KUyBtYXkgYmUgYXZhaWxhYmxlIGZvciBkZWZpbmluZyBjb250cm9sbGVycyBhbmQgdmlldyB0ZW1wbGF0ZXMgdGhhdCBjYW4gYmUgZGVmZXJyZWQsIGJ1dCBmb3Igbm93IHRoYXQncyB0aGUgb25seSB2aWFibGUgdHJhbnNwb3J0IHdoZW4gaXQgY29tZXMgdG8gZGVmZXJyZWQgZXhlY3V0aW9uIGluIFRhdW51cy5cXG5cXG4gICAgPHN1Yj5bXyhiYWNrIHRvIHRhYmxlIG9mIGNvbnRlbnRzKV9dKCNib29zdGluZy1wZXJmb3JtYW5jZS13aXRoLXRhdW51cyk8L3N1Yj5cXG5cXG4gICAgWzFdOiBodHRwOi8vcG9ueWZvby5jb20vYXJ0aWNsZXMvY3JpdGljYWwtcGF0aC1wZXJmb3JtYW5jZS1vcHRpbWl6YXRpb25cXG4gICAgWzJdOiBodHRwOi8vbmdpbngub3JnL1xcbiAgICBbM106IC9hcGkjdXNpbmctdGhlLWF1dG8tc3RyYXRlZ3lcXG4gICAgWzRdOiAvYXBpI3VzaW5nLXRoZS1pbmxpbmUtc3RyYXRlZ3lcXG4gICAgWzVdOiAvYXBpIy10YXVudXMtbW91bnQtY29udGFpbmVyLXdpcmluZy1vcHRpb25zLVxcbiAgICBbNl06IC9hcGkjdXNpbmctdGhlLW1hbnVhbC1zdHJhdGVneVxcbiAgICBbN106IC9hcGkjY2FjaGluZ1xcbiAgICBbOF06IC9hcGkjLXRhdW51cy1pbnRlcmNlcHQtYWN0aW9uLWZuLVxcbiAgICBbOV06IGh0dHA6Ly9yYXVjaGcuY29tLzIwMTQvNy1wcmluY2lwbGVzLW9mLXJpY2gtd2ViLWFwcGxpY2F0aW9ucy9cXG4gICAgWzEwXTogaHR0cDovL2JldmFjcXVhLmlvL2JmXFxuICAgIFsxMV06IC9hcGkjdmVyc2lvbmluZ1xcbiAgICBbMTJdOiAvYXBpI3ByZWZldGNoaW5nXFxuICAgIFsxM106IC9hcGkjdXNpbmctdGF1bnVzLXByZWZldGNoLXVybC1lbGVtZW50LVxcbiAgICBbMTRdOiAvYXBpIy10YXVudXMtcGFydGlhbC1jb250YWluZXItYWN0aW9uLW1vZGVsLVxcbiAgICBbMTVdOiAvYXBpIy1kZWZlci1hY3Rpb25zLVxcbiAgICBbMTZdOiAvYXBpIy1vcHRpb25zLWRlZmVybWluaWZpZWQtXFxuXCIpO1xufVxufSIsInZhciBqYWRlID0gcmVxdWlyZShcImphZHVtL3J1bnRpbWVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vdEZvdW5kKGxvY2Fscykge1xudmFyIGphZGVfZGVidWcgPSBbeyBsaW5lbm86IDEsIGZpbGVuYW1lOiBcInZpZXdzL2Vycm9yL25vdC1mb3VuZC5qYWRlXCIgfV07XG50cnkge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2Vycm9yL25vdC1mb3VuZC5qYWRlXCIgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEsIGZpbGVuYW1lOiBcInZpZXdzL2Vycm9yL25vdC1mb3VuZC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMT5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuYnVmLnB1c2goXCJOb3QgRm91bmRcIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvaDE+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzLCBmaWxlbmFtZTogXCJ2aWV3cy9lcnJvci9ub3QtZm91bmQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8cD5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDMsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuYnVmLnB1c2goXCJUaGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYW55dGhpbmcgaGVyZSB5ZXQuIElmIHlvdSBiZWxpZXZlIHRoaXMgdG8gYmUgYSBtaXN0YWtlLCBwbGVhc2UgbGV0IHVzIGtub3chXCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L3A+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiA0LCBmaWxlbmFtZTogXCJ2aWV3cy9lcnJvci9ub3QtZm91bmQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8cD5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDUsIGZpbGVuYW1lOiBcInZpZXdzL2Vycm9yL25vdC1mb3VuZC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxhIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vbnpnYlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogNSwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIiZtZGFzaDsgQG56Z2JcIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvYT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvcD5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7fS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnVuZGVmaW5lZDp0eXBlb2YgdW5kZWZpbmVkIT09XCJ1bmRlZmluZWRcIj91bmRlZmluZWQ6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn0gY2F0Y2ggKGVycikge1xuICBqYWRlLnJldGhyb3coZXJyLCBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lLCBqYWRlX2RlYnVnWzBdLmxpbmVubywgXCJoMSBOb3QgRm91bmRcXG5cXG5wIFRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhbnl0aGluZyBoZXJlIHlldC4gSWYgeW91IGJlbGlldmUgdGhpcyB0byBiZSBhIG1pc3Rha2UsIHBsZWFzZSBsZXQgdXMga25vdyFcXG5wXFxuICBhKGhyZWY9J2h0dHBzOi8vdHdpdHRlci5jb20vbnpnYicsIHRhcmdldD0nX2JsYW5rJykgJm1kYXNoOyBAbnpnYlxcblwiKTtcbn1cbn0iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJqYWR1bS9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsYXlvdXQobG9jYWxzKSB7XG52YXIgamFkZV9kZWJ1ZyA9IFt7IGxpbmVubzogMSwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9XTtcbnRyeSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uICh1bmRlZmluZWQsIG1vZGVsLCBwYXJ0aWFsKSB7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDAsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjwhRE9DVFlQRSBodG1sPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMiwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGh0bWwgbGFuZz1cXFwiZW5cXFwiIGl0ZW1zY29wZSBpdGVtdHlwZT1cXFwiaHR0cDovL3NjaGVtYS5vcmcvQmxvZ1xcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzLCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8aGVhZD5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDQsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjx0aXRsZT5cIiArIChqYWRlLmVzY2FwZShudWxsID09IChqYWRlX2ludGVycCA9IG1vZGVsLnRpdGxlKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC90aXRsZT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDUsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxtZXRhIGNoYXJzZXQ9XFxcInV0Zi04XFxcIj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDYsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxsaW5rIHJlbD1cXFwic2hvcnRjdXQgaWNvblxcXCIgaHJlZj1cXFwiL2Zhdmljb24uaWNvXFxcIj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDcsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxtZXRhIGh0dHAtZXF1aXY9XFxcIlgtVUEtQ29tcGF0aWJsZVxcXCIgY29udGVudD1cXFwiSUU9ZWRnZSxjaHJvbWU9MVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiA4LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bWV0YSBuYW1lPVxcXCJ2aWV3cG9ydFxcXCIgY29udGVudD1cXFwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcXFwiPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogOSwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCIgaHJlZj1cXFwiL2Nzcy9hbGwuY3NzXFxcIj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEwLCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIiBocmVmPVxcXCJodHRwOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1VbmljYStPbmU6NDAwfFBsYXlmYWlyK0Rpc3BsYXk6NzAwfE1lZ3JpbTo3MDB8RmF1bmErT25lOjQwMGl0YWxpYyw0MDAsNzAwXFxcIj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvaGVhZD5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEyLCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8Ym9keSBpZD1cXFwidG9wXFxcIj5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDEzLCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8aGVhZGVyPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMTQsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxoMT5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDE1LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8YSBocmVmPVxcXCIvXFxcIiBhcmlhLWxhYmVsPVxcXCJHbyB0byBob21lXFxcIiBjbGFzcz1cXFwibHktdGl0bGVcXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMTUsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuYnVmLnB1c2goXCJUYXVudXNcIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvYT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvaDE+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAxNiwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGgyIGNsYXNzPVxcXCJseS1zdWJoZWFkaW5nXFxcIj5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDE2LCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmJ1Zi5wdXNoKFwiTWljcm8gSXNvbW9ycGhpYyBNVkMgRW5naW5lIGZvciBOb2RlLmpzXCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L2gyPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9oZWFkZXI+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAxOCwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGFzaWRlIGNsYXNzPVxcXCJzYi1zaWRlYmFyXFxcIj5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDE5LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bmF2IGNsYXNzPVxcXCJzYi1jb250YWluZXJcXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjAsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjx1bCBjbGFzcz1cXFwibnYtaXRlbXNcXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjEsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxsaSBjbGFzcz1cXFwibnYtaXRlbVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyMiwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGEgaHJlZj1cXFwiL1xcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyMiwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIkFib3V0XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L2E+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L2xpPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjMsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxsaSBjbGFzcz1cXFwibnYtaXRlbVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyNCwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGEgaHJlZj1cXFwiL2dldHRpbmctc3RhcnRlZFxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyNCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIkdldHRpbmcgU3RhcnRlZFwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9hPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9saT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDI1LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bGkgY2xhc3M9XFxcIm52LWl0ZW1cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjYsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxhIGhyZWY9XFxcIi9hcGlcXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjYsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuYnVmLnB1c2goXCJBUEkgRG9jdW1lbnRhdGlvblwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9hPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9saT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDI3LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bGkgY2xhc3M9XFxcIm52LWl0ZW1cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMjgsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxhIGhyZWY9XFxcIi9jb21wbGVtZW50c1xcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAyOCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIkNvbXBsZW1lbnRhcnkgTW9kdWxlc1wiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9hPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9saT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDI5LCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bGkgY2xhc3M9XFxcIm52LWl0ZW1cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMzAsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxhIGhyZWY9XFxcIi9wZXJmb3JtYW5jZVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzMCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIlBlcmZvcm1hbmNlIE9wdGltaXphdGlvblwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9hPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9saT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IDMxLCBmaWxlbmFtZTogXCJ2aWV3cy9sYXlvdXQuamFkZVwiIH0pO1xuYnVmLnB1c2goXCI8bGkgY2xhc3M9XFxcIm52LWl0ZW1cXFwiPlwiKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMzIsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxhIGhyZWY9XFxcIi9zb3VyY2UtY29kZVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzMiwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIlNvdXJjZSBDb2RlXCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L2E+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L2xpPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMzMsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxsaSBjbGFzcz1cXFwibnYtaXRlbVxcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzNCwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPGEgaHJlZj1cXFwiL2NoYW5nZWxvZ1xcXCI+XCIpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiB1bmRlZmluZWQsIGZpbGVuYW1lOiBqYWRlX2RlYnVnWzBdLmZpbGVuYW1lIH0pO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzNCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5idWYucHVzaChcIkNoYW5nZWxvZ1wiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9hPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9saT5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvdWw+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuYnVmLnB1c2goXCI8L25hdj5cIik7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvYXNpZGU+XCIpO1xuamFkZV9kZWJ1Zy5zaGlmdCgpO1xuamFkZV9kZWJ1Zy51bnNoaWZ0KHsgbGluZW5vOiAzNiwgZmlsZW5hbWU6IFwidmlld3MvbGF5b3V0LmphZGVcIiB9KTtcbmJ1Zi5wdXNoKFwiPG1haW4gaWQ9XFxcImFwcGxpY2F0aW9uLXJvb3RcXFwiIGRhdGEtdGF1bnVzPVxcXCJtb2RlbFxcXCIgY2xhc3M9XFxcImx5LW1haW5cXFwiPlwiICsgKG51bGwgPT0gKGphZGVfaW50ZXJwID0gcGFydGlhbCkgPyBcIlwiIDogamFkZV9pbnRlcnApKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogdW5kZWZpbmVkLCBmaWxlbmFtZTogamFkZV9kZWJ1Z1swXS5maWxlbmFtZSB9KTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9tYWluPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcudW5zaGlmdCh7IGxpbmVubzogMzcsIGZpbGVuYW1lOiBcInZpZXdzL2xheW91dC5qYWRlXCIgfSk7XG5idWYucHVzaChcIjxzY3JpcHQgc3JjPVxcXCIvanMvYWxsLmpzXFxcIj5cIik7XG5qYWRlX2RlYnVnLnVuc2hpZnQoeyBsaW5lbm86IHVuZGVmaW5lZCwgZmlsZW5hbWU6IGphZGVfZGVidWdbMF0uZmlsZW5hbWUgfSk7XG5qYWRlX2RlYnVnLnNoaWZ0KCk7XG5idWYucHVzaChcIjwvc2NyaXB0PlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9ib2R5PlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmJ1Zi5wdXNoKFwiPC9odG1sPlwiKTtcbmphZGVfZGVidWcuc2hpZnQoKTtcbmphZGVfZGVidWcuc2hpZnQoKTt9LmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGgudW5kZWZpbmVkOnR5cGVvZiB1bmRlZmluZWQhPT1cInVuZGVmaW5lZFwiP3VuZGVmaW5lZDp1bmRlZmluZWQsXCJtb2RlbFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGgubW9kZWw6dHlwZW9mIG1vZGVsIT09XCJ1bmRlZmluZWRcIj9tb2RlbDp1bmRlZmluZWQsXCJwYXJ0aWFsXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5wYXJ0aWFsOnR5cGVvZiBwYXJ0aWFsIT09XCJ1bmRlZmluZWRcIj9wYXJ0aWFsOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59IGNhdGNoIChlcnIpIHtcbiAgamFkZS5yZXRocm93KGVyciwgamFkZV9kZWJ1Z1swXS5maWxlbmFtZSwgamFkZV9kZWJ1Z1swXS5saW5lbm8sIFwiZG9jdHlwZSBodG1sXFxuaHRtbChsYW5nPSdlbicsIGl0ZW1zY29wZSwgaXRlbXR5cGU9J2h0dHA6Ly9zY2hlbWEub3JnL0Jsb2cnKVxcbiAgaGVhZFxcbiAgICB0aXRsZT1tb2RlbC50aXRsZVxcbiAgICBtZXRhKGNoYXJzZXQ9J3V0Zi04JylcXG4gICAgbGluayhyZWw9J3Nob3J0Y3V0IGljb24nLCBocmVmPScvZmF2aWNvbi5pY28nKVxcbiAgICBtZXRhKGh0dHAtZXF1aXY9J1gtVUEtQ29tcGF0aWJsZScsIGNvbnRlbnQ9J0lFPWVkZ2UsY2hyb21lPTEnKVxcbiAgICBtZXRhKG5hbWU9J3ZpZXdwb3J0JywgY29udGVudD0nd2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEnKVxcbiAgICBsaW5rKHJlbD0nc3R5bGVzaGVldCcsIHR5cGU9J3RleHQvY3NzJywgaHJlZj0nL2Nzcy9hbGwuY3NzJylcXG4gICAgbGluayhyZWw9J3N0eWxlc2hlZXQnLCB0eXBlPSd0ZXh0L2NzcycsIGhyZWY9J2h0dHA6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVVuaWNhK09uZTo0MDB8UGxheWZhaXIrRGlzcGxheTo3MDB8TWVncmltOjcwMHxGYXVuYStPbmU6NDAwaXRhbGljLDQwMCw3MDAnKVxcblxcbiAgYm9keSN0b3BcXG4gICAgaGVhZGVyXFxuICAgICAgaDFcXG4gICAgICAgIGEubHktdGl0bGUoaHJlZj0nLycsIGFyaWEtbGFiZWw9J0dvIHRvIGhvbWUnKSBUYXVudXNcXG4gICAgICBoMi5seS1zdWJoZWFkaW5nIE1pY3JvIElzb21vcnBoaWMgTVZDIEVuZ2luZSBmb3IgTm9kZS5qc1xcblxcbiAgICBhc2lkZS5zYi1zaWRlYmFyXFxuICAgICAgbmF2LnNiLWNvbnRhaW5lclxcbiAgICAgICAgdWwubnYtaXRlbXNcXG4gICAgICAgICAgbGkubnYtaXRlbVxcbiAgICAgICAgICAgIGEoaHJlZj0nLycpIEFib3V0XFxuICAgICAgICAgIGxpLm52LWl0ZW1cXG4gICAgICAgICAgICBhKGhyZWY9Jy9nZXR0aW5nLXN0YXJ0ZWQnKSBHZXR0aW5nIFN0YXJ0ZWRcXG4gICAgICAgICAgbGkubnYtaXRlbVxcbiAgICAgICAgICAgIGEoaHJlZj0nL2FwaScpIEFQSSBEb2N1bWVudGF0aW9uXFxuICAgICAgICAgIGxpLm52LWl0ZW1cXG4gICAgICAgICAgICBhKGhyZWY9Jy9jb21wbGVtZW50cycpIENvbXBsZW1lbnRhcnkgTW9kdWxlc1xcbiAgICAgICAgICBsaS5udi1pdGVtXFxuICAgICAgICAgICAgYShocmVmPScvcGVyZm9ybWFuY2UnKSBQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb25cXG4gICAgICAgICAgbGkubnYtaXRlbVxcbiAgICAgICAgICAgIGEoaHJlZj0nL3NvdXJjZS1jb2RlJykgU291cmNlIENvZGVcXG4gICAgICAgICAgbGkubnYtaXRlbVxcbiAgICAgICAgICAgIGEoaHJlZj0nL2NoYW5nZWxvZycpIENoYW5nZWxvZ1xcblxcbiAgICBtYWluLmx5LW1haW4jYXBwbGljYXRpb24tcm9vdChkYXRhLXRhdW51cz0nbW9kZWwnKSE9cGFydGlhbFxcbiAgICBzY3JpcHQoc3JjPScvanMvYWxsLmpzJylcXG5cIik7XG59XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVzID0ge1xuICAnZG9jdW1lbnRhdGlvbi9hYm91dCc6IHJlcXVpcmUoJy4vdmlld3MvZG9jdW1lbnRhdGlvbi9hYm91dC5qcycpLFxuICAnZG9jdW1lbnRhdGlvbi9hcGknOiByZXF1aXJlKCcuL3ZpZXdzL2RvY3VtZW50YXRpb24vYXBpLmpzJyksXG4gICdkb2N1bWVudGF0aW9uL2NvbXBsZW1lbnRzJzogcmVxdWlyZSgnLi92aWV3cy9kb2N1bWVudGF0aW9uL2NvbXBsZW1lbnRzLmpzJyksXG4gICdkb2N1bWVudGF0aW9uL2dldHRpbmctc3RhcnRlZCc6IHJlcXVpcmUoJy4vdmlld3MvZG9jdW1lbnRhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQuanMnKSxcbiAgJ2RvY3VtZW50YXRpb24vcGVyZm9ybWFuY2UnOiByZXF1aXJlKCcuL3ZpZXdzL2RvY3VtZW50YXRpb24vcGVyZm9ybWFuY2UuanMnKSxcbiAgJ2Vycm9yL25vdC1mb3VuZCc6IHJlcXVpcmUoJy4vdmlld3MvZXJyb3Ivbm90LWZvdW5kLmpzJyksXG4gICdsYXlvdXQnOiByZXF1aXJlKCcuL3ZpZXdzL2xheW91dC5qcycpXG59O1xuXG52YXIgY29udHJvbGxlcnMgPSB7XG4gICdkb2N1bWVudGF0aW9uL2Fib3V0JzogcmVxdWlyZSgnLi4vY2xpZW50L2pzL2NvbnRyb2xsZXJzL2RvY3VtZW50YXRpb24vYWJvdXQuanMnKVxufTtcblxudmFyIHJvdXRlcyA9IFtcbiAge1xuICAgIHJvdXRlOiAnLycsXG4gICAgYWN0aW9uOiAnZG9jdW1lbnRhdGlvbi9hYm91dCdcbiAgfSxcbiAge1xuICAgIHJvdXRlOiAnL2dldHRpbmctc3RhcnRlZCcsXG4gICAgYWN0aW9uOiAnZG9jdW1lbnRhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQnXG4gIH0sXG4gIHtcbiAgICByb3V0ZTogJy9hcGknLFxuICAgIGFjdGlvbjogJ2RvY3VtZW50YXRpb24vYXBpJ1xuICB9LFxuICB7XG4gICAgcm91dGU6ICcvY29tcGxlbWVudHMnLFxuICAgIGFjdGlvbjogJ2RvY3VtZW50YXRpb24vY29tcGxlbWVudHMnXG4gIH0sXG4gIHtcbiAgICByb3V0ZTogJy9wZXJmb3JtYW5jZScsXG4gICAgYWN0aW9uOiAnZG9jdW1lbnRhdGlvbi9wZXJmb3JtYW5jZSdcbiAgfSxcbiAge1xuICAgIHJvdXRlOiAnL3NvdXJjZS1jb2RlJyxcbiAgICBpZ25vcmU6IHRydWVcbiAgfSxcbiAge1xuICAgIHJvdXRlOiAnL2NoYW5nZWxvZycsXG4gICAgaWdub3JlOiB0cnVlXG4gIH0sXG4gIHtcbiAgICByb3V0ZTogJy86Y2F0Y2hhbGwqJyxcbiAgICBhY3Rpb246ICdlcnJvci9ub3QtZm91bmQnXG4gIH1cbl07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICByb3V0ZXM6IHJvdXRlc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUubG9nKCdXZWxjb21lIHRvIFRhdW51cyBkb2N1bWVudGF0aW9uIG1pbmktc2l0ZSEnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnZG9taW51cycpO1xudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpO1xudmFyIHRhdW51cyA9IHJlcXVpcmUoJ3RhdW51cycpO1xudmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi90aHJvdHRsZScpO1xudmFyIHNsb3dTY3JvbGxDaGVjayA9IHRocm90dGxlKHNjcm9sbENoZWNrLCA1MCk7XG52YXIgaHggPSAvXmhbMS02XSQvaTtcbnZhciBoZWFkaW5nO1xuXG5mdW5jdGlvbiBjb252ZW50aW9ucyAoY29udGFpbmVyKSB7XG4gICQoJ2JvZHknKS5vbignY2xpY2snLCAnaDEsaDIsaDMsaDQsaDUsaDYnLCBoZWFkaW5nQ2xpY2spO1xuXG4gIHJhZihzY3JvbGwpO1xufVxuXG5mdW5jdGlvbiBzY3JvbGwgKCkge1xuICBzbG93U2Nyb2xsQ2hlY2soKTtcbiAgcmFmKHNjcm9sbCk7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbENoZWNrICgpIHtcbiAgdmFyIGZvdW5kID0gJCgnbWFpbicpLmZpbmQoJ2gxLGgyLGgzLGg0LGg1LGg2JykuZmlsdGVyKGluVmlld3BvcnQpO1xuICBpZiAoZm91bmQubGVuZ3RoID09PSAwIHx8IGhlYWRpbmcgJiYgZm91bmRbMF0gPT09IGhlYWRpbmdbMF0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGhlYWRpbmcpIHtcbiAgICBoZWFkaW5nLnJlbW92ZUNsYXNzKCd1di1oaWdobGlnaHQnKTtcbiAgfVxuICBoZWFkaW5nID0gZm91bmQuaSgwKTtcbiAgaGVhZGluZy5hZGRDbGFzcygndXYtaGlnaGxpZ2h0Jyk7XG59XG5cbmZ1bmN0aW9uIGluVmlld3BvcnQgKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdmlld2FibGUgPSAoXG4gICAgTWF0aC5jZWlsKHJlY3QudG9wKSA+PSAwICYmXG4gICAgTWF0aC5jZWlsKHJlY3QubGVmdCkgPj0gMCAmJlxuICAgIE1hdGguZmxvb3IocmVjdC5ib3R0b20pIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiZcbiAgICBNYXRoLmZsb29yKHJlY3QucmlnaHQpIDw9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpXG4gICk7XG4gIHJldHVybiB2aWV3YWJsZTtcbn1cblxuZnVuY3Rpb24gZmluZEhlYWRpbmcgKGUpIHtcbiAgdmFyIGggPSBlLnRhcmdldDtcbiAgd2hpbGUgKGggJiYgIWh4LnRlc3QoaC50YWdOYW1lKSkge1xuICAgIGggPSBoLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGhlYWRpbmdDbGljayAoZSkge1xuICB2YXIgaCA9IGZpbmRIZWFkaW5nKGUpO1xuICBpZiAoaCAmJiBoLmlkKSB7XG4gICAgdGF1bnVzLm5hdmlnYXRlKCcjJyArIGguaWQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVudGlvbnM7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIGltcG9ydCB0aGUgdGF1bnVzIG1vZHVsZVxudmFyIHRhdW51cyA9IHJlcXVpcmUoJ3RhdW51cycpO1xuXG4vLyBpbXBvcnQgdGhlIHdpcmluZyBtb2R1bGUgZXhwb3J0ZWQgYnkgVGF1bnVzXG52YXIgd2lyaW5nID0gcmVxdWlyZSgnLi4vLi4vLmJpbi93aXJpbmcnKTtcblxuLy8gaW1wb3J0IGNvbnZlbnRpb25zXG52YXIgY29udmVudGlvbnMgPSByZXF1aXJlKCcuL2NvbnZlbnRpb25zJyk7XG5cbi8vIGdldCB0aGUgPG1haW4+IGVsZW1lbnRcbnZhciBtYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcGxpY2F0aW9uLXJvb3QnKTtcblxuLy8gc2V0IHVwIGNvbnZlbnRpb25zIHRoYXQgZ2V0IGV4ZWN1dGVkIGZvciBldmVyeSB2aWV3XG50YXVudXMub24oJ3JlbmRlcicsIGNvbnZlbnRpb25zKTtcblxuLy8gbW91bnQgdGF1bnVzIHNvIGl0IHN0YXJ0cyBpdHMgcm91dGluZyBlbmdpbmVcbnRhdW51cy5tb3VudChtYWluLCB3aXJpbmcpO1xuXG4vLyBjcmVhdGUgZ2xvYmFscyB0byBtYWtlIGl0IGVhc3kgdG8gZGVidWdcbi8vIGRvbid0IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiFcbmdsb2JhbC4kID0gcmVxdWlyZSgnZG9taW51cycpO1xuZ2xvYmFsLnRhdW51cyA9IHRhdW51cztcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHRocm90dGxlIChmbiwgdCkge1xuICB2YXIgY2FjaGU7XG4gIHZhciBsYXN0ID0gLTE7XG4gIHJldHVybiBmdW5jdGlvbiB0aHJvdHRsZWQgKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0ID4gdCkge1xuICAgICAgY2FjaGUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdCA9IG5vdztcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuZ2xvYmFsLnRocm90dGxlPXRocm90dGxlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciBwb3NlciA9IHJlcXVpcmUoJy4vc3JjL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NlcjtcblxuWydBcnJheScsICdGdW5jdGlvbicsICdPYmplY3QnLCAnRGF0ZScsICdTdHJpbmcnXS5mb3JFYWNoKHBvc2UpO1xuXG5mdW5jdGlvbiBwb3NlICh0eXBlKSB7XG4gIHBvc2VyW3R5cGVdID0gZnVuY3Rpb24gcG9zZUNvbXB1dGVkVHlwZSAoKSB7IHJldHVybiBwb3Nlcih0eXBlKTsgfTtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSBnbG9iYWwuZG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIHBvc2VyICh0eXBlKSB7XG4gIHZhciBpZnJhbWUgPSBkLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBkLmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICByZXR1cm4gbWFwKHR5cGUsIGlmcmFtZS5jb250ZW50V2luZG93KTtcbn1cblxuZnVuY3Rpb24gbWFwICh0eXBlLCBzb3VyY2UpIHsgLy8gZm9yd2FyZCBwb2x5ZmlsbHMgdG8gdGhlIHN0b2xlbiByZWZlcmVuY2UhXG4gIHZhciBvcmlnaW5hbCA9IHdpbmRvd1t0eXBlXS5wcm90b3R5cGU7XG4gIHZhciB2YWx1ZSA9IHNvdXJjZVt0eXBlXTtcbiAgdmFyIHByb3A7XG5cbiAgZm9yIChwcm9wIGluIG9yaWdpbmFsKSB7XG4gICAgdmFsdWUucHJvdG90eXBlW3Byb3BdID0gb3JpZ2luYWxbcHJvcF07XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zZXI7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXhwYW5kbyA9ICdzZWt0b3ItJyArIERhdGUubm93KCk7XG52YXIgcnNpYmxpbmdzID0gL1srfl0vO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIGRlbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBtYXRjaCA9IGRlbC5tYXRjaGVzIHx8XG4gICAgICAgICAgICBkZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBkZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBkZWwub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgZGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG5mdW5jdGlvbiBxc2EgKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gIHZhciBleGlzdGVkLCBpZCwgcHJlZml4LCBwcmVmaXhlZCwgYWRhcHRlciwgaGFjayA9IGNvbnRleHQgIT09IGRvY3VtZW50O1xuICBpZiAoaGFjaykgeyAvLyBpZCBoYWNrIGZvciBjb250ZXh0LXJvb3RlZCBxdWVyaWVzXG4gICAgZXhpc3RlZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlkID0gZXhpc3RlZCB8fCBleHBhbmRvO1xuICAgIHByZWZpeCA9ICcjJyArIGlkICsgJyAnO1xuICAgIHByZWZpeGVkID0gcHJlZml4ICsgc2VsZWN0b3IucmVwbGFjZSgvLC9nLCAnLCcgKyBwcmVmaXgpO1xuICAgIGFkYXB0ZXIgPSByc2libGluZ3MudGVzdChzZWxlY3RvcikgJiYgY29udGV4dC5wYXJlbnROb2RlO1xuICAgIGlmICghZXhpc3RlZCkgeyBjb250ZXh0LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7IH1cbiAgfVxuICB0cnkge1xuICAgIHJldHVybiAoYWRhcHRlciB8fCBjb250ZXh0KS5xdWVyeVNlbGVjdG9yQWxsKHByZWZpeGVkIHx8IHNlbGVjdG9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoZXhpc3RlZCA9PT0gbnVsbCkgeyBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmQgKHNlbGVjdG9yLCBjdHgsIGNvbGxlY3Rpb24sIHNlZWQpIHtcbiAgdmFyIGVsZW1lbnQ7XG4gIHZhciBjb250ZXh0ID0gY3R4IHx8IGRvY3VtZW50O1xuICB2YXIgcmVzdWx0cyA9IGNvbGxlY3Rpb24gfHwgW107XG4gIHZhciBpID0gMDtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBpZiAoY29udGV4dC5ub2RlVHlwZSAhPT0gMSAmJiBjb250ZXh0Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgcmV0dXJuIFtdOyAvLyBiYWlsIGlmIGNvbnRleHQgaXMgbm90IGFuIGVsZW1lbnQgb3IgZG9jdW1lbnRcbiAgfVxuICBpZiAoc2VlZCkge1xuICAgIHdoaWxlICgoZWxlbWVudCA9IHNlZWRbaSsrXSkpIHtcbiAgICAgIGlmIChtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIHFzYShzZWxlY3RvciwgY29udGV4dCkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChzZWxlY3RvciwgZWxlbWVudHMpIHtcbiAgcmV0dXJuIGZpbmQoc2VsZWN0b3IsIG51bGwsIG51bGwsIGVsZW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gbWF0Y2guY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcblxuZmluZC5tYXRjaGVzID0gbWF0Y2hlcztcbmZpbmQubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc2VyID0gcmVxdWlyZSgncG9zZXInKTtcbnZhciBEb21pbnVzID0gcG9zZXIuQXJyYXkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb21pbnVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJy4vcHVibGljJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgY2xhc3NlcyA9IHJlcXVpcmUoJy4vY2xhc3NlcycpO1xudmFyIERvbWludXMgPSByZXF1aXJlKCcuL0RvbWludXMuY3RvcicpO1xuXG5mdW5jdGlvbiBlcXVhbHMgKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBlcXVhbHMgKGVsZW0pIHtcbiAgICByZXR1cm4gZG9tLm1hdGNoZXMoZWxlbSwgc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJhaWdodCAocHJvcCwgb25lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBkb21NYXBwaW5nIChzZWxlY3Rvcikge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIGRvbVtwcm9wXShlbGVtLCBzZWxlY3Rvcik7XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdHMgPSBjb3JlLmZsYXR0ZW4ocmVzdWx0KTtcbiAgICByZXR1cm4gb25lID8gcmVzdWx0c1swXSA6IHJlc3VsdHM7XG4gIH07XG59XG5cbkRvbWludXMucHJvdG90eXBlLnByZXYgPSBzdHJhaWdodCgncHJldicpO1xuRG9taW51cy5wcm90b3R5cGUubmV4dCA9IHN0cmFpZ2h0KCduZXh0Jyk7XG5Eb21pbnVzLnByb3RvdHlwZS5wYXJlbnQgPSBzdHJhaWdodCgncGFyZW50Jyk7XG5Eb21pbnVzLnByb3RvdHlwZS5wYXJlbnRzID0gc3RyYWlnaHQoJ3BhcmVudHMnKTtcbkRvbWludXMucHJvdG90eXBlLmNoaWxkcmVuID0gc3RyYWlnaHQoJ2NoaWxkcmVuJyk7XG5Eb21pbnVzLnByb3RvdHlwZS5maW5kID0gc3RyYWlnaHQoJ3FzYScpO1xuRG9taW51cy5wcm90b3R5cGUuZmluZE9uZSA9IHN0cmFpZ2h0KCdxcycsIHRydWUpO1xuXG5Eb21pbnVzLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICByZXR1cm4gdGhpcy5maWx0ZXIoZXF1YWxzKHNlbGVjdG9yKSk7XG59O1xuXG5Eb21pbnVzLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICByZXR1cm4gdGhpcy5zb21lKGVxdWFscyhzZWxlY3RvcikpO1xufTtcblxuRG9taW51cy5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICByZXR1cm4gbmV3IERvbWludXModGhpc1tpbmRleF0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUZhY3RvcnkgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wYXJlICgpIHtcbiAgICAkLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZm9yRWFjaChmbiwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbkRvbWludXMucHJvdG90eXBlLmFuZCA9IGNvbXBhcmVGYWN0b3J5KGZ1bmN0aW9uIGFkZE9uZSAoZWxlbSkge1xuICBpZiAodGhpcy5pbmRleE9mKGVsZW0pID09PSAtMSkge1xuICAgIHRoaXMucHVzaChlbGVtKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn0pO1xuXG5Eb21pbnVzLnByb3RvdHlwZS5idXQgPSBjb21wYXJlRmFjdG9yeShmdW5jdGlvbiBhZGRPbmUgKGVsZW0pIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGVsZW0pO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufSk7XG5cbkRvbWludXMucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcHM7XG4gIHZhciBtYW55ID0gbmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCc7XG4gIHZhciBnZXR0ZXIgPSAhbWFueSAmJiAhdmFsdWU7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPyBkb20uZ2V0Q3NzKHRoaXNbMF0sIG5hbWUpIDogbnVsbDtcbiAgfVxuICBpZiAobWFueSkge1xuICAgIHByb3BzID0gbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wcyA9IHt9O1xuICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgdGhpcy5mb3JFYWNoKGRvbS5zZXRDc3MocHJvcHMpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Eb21pbnVzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlcywgZmlsdGVyLCBmbikge1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB0eXBlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGRvbS5vbihlbGVtLCB0eXBlLCBmaWx0ZXIsIGZuKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRG9taW51cy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGVzLCBmaWx0ZXIsIGZuKSB7XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgIHR5cGVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZG9tLm9mZihlbGVtLCB0eXBlLCBmaWx0ZXIsIGZuKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuW1xuICBbJ2FkZENsYXNzJywgY2xhc3Nlcy5hZGRdLFxuICBbJ3JlbW92ZUNsYXNzJywgY2xhc3Nlcy5yZW1vdmVdLFxuICBbJ3NldENsYXNzJywgY2xhc3Nlcy5zZXRdLFxuICBbJ3JlbW92ZUNsYXNzJywgY2xhc3Nlcy5yZW1vdmVdLFxuICBbJ3JlbW92ZScsIGRvbS5yZW1vdmVdXG5dLmZvckVhY2gobWFwTWV0aG9kcyk7XG5cbmZ1bmN0aW9uIG1hcE1ldGhvZHMgKGRhdGEpIHtcbiAgRG9taW51cy5wcm90b3R5cGVbZGF0YVswXV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIGRhdGFbMV0oZWxlbSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5bXG4gIFsnYXBwZW5kJywgZG9tLmFwcGVuZF0sXG4gIFsnYXBwZW5kVG8nLCBkb20uYXBwZW5kVG9dLFxuICBbJ3ByZXBlbmQnLCBkb20ucHJlcGVuZF0sXG4gIFsncHJlcGVuZFRvJywgZG9tLnByZXBlbmRUb10sXG4gIFsnYmVmb3JlJywgZG9tLmJlZm9yZV0sXG4gIFsnYmVmb3JlT2YnLCBkb20uYmVmb3JlT2ZdLFxuICBbJ2FmdGVyJywgZG9tLmFmdGVyXSxcbiAgWydhZnRlck9mJywgZG9tLmFmdGVyT2ZdLFxuICBbJ3Nob3cnLCBkb20uc2hvd10sXG4gIFsnaGlkZScsIGRvbS5oaWRlXVxuXS5mb3JFYWNoKG1hcE1hbmlwdWxhdGlvbik7XG5cbmZ1bmN0aW9uIG1hcE1hbmlwdWxhdGlvbiAoZGF0YSkge1xuICBEb21pbnVzLnByb3RvdHlwZVtkYXRhWzBdXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRhdGFbMV0odGhpcywgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5Eb21pbnVzLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMuY29udGFpbnMoZWxlbSwgdmFsdWUpO1xuICB9KTtcbn07XG5cbkRvbWludXMucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGhhc2ggPSBuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JztcbiAgdmFyIHNldCA9IGhhc2ggPyBzZXRNYW55IDogc2V0U2luZ2xlO1xuICB2YXIgc2V0dGVyID0gaGFzaCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMTtcbiAgaWYgKHNldHRlcikge1xuICAgIHRoaXMuZm9yRWFjaChzZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA/IGRvbS5nZXRBdHRyKHRoaXNbMF0sIG5hbWUpIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55IChlbGVtKSB7XG4gICAgZG9tLm1hbnlBdHRyKGVsZW0sIG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldFNpbmdsZSAoZWxlbSkge1xuICAgIGRvbS5hdHRyKGVsZW0sIG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24ga2V5VmFsdWUgKGtleSwgdmFsdWUpIHtcbiAgdmFyIGdldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAyO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID8gZG9tW2tleV0odGhpc1swXSkgOiAnJztcbiAgfVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBkb21ba2V5XShlbGVtLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24ga2V5VmFsdWVQcm9wZXJ0eSAocHJvcCkge1xuICBEb21pbnVzLnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uIGFjY2Vzc29yICh2YWx1ZSkge1xuICAgIHZhciBnZXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMTtcbiAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICByZXR1cm4ga2V5VmFsdWUuY2FsbCh0aGlzLCBwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbHVlLmNhbGwodGhpcywgcHJvcCwgdmFsdWUpO1xuICB9O1xufVxuXG5bJ2h0bWwnLCAndGV4dCcsICd2YWx1ZSddLmZvckVhY2goa2V5VmFsdWVQcm9wZXJ0eSk7XG5cbkRvbWludXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZG9tLmNsb25lKGVsZW0pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wdWJsaWMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRyaW0gPSAvXlxccyt8XFxzKyQvZztcbnZhciB3aGl0ZXNwYWNlID0gL1xccysvZztcblxuZnVuY3Rpb24gaW50ZXJwcmV0IChpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0LnJlcGxhY2UodHJpbSwgJycpLnNwbGl0KHdoaXRlc3BhY2UpIDogaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXMgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NOYW1lLnJlcGxhY2UodHJpbSwgJycpLnNwbGl0KHdoaXRlc3BhY2UpO1xufVxuXG5mdW5jdGlvbiBzZXQgKG5vZGUsIGlucHV0KSB7XG4gIG5vZGUuY2xhc3NOYW1lID0gaW50ZXJwcmV0KGlucHV0KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIGFkZCAobm9kZSwgaW5wdXQpIHtcbiAgdmFyIGN1cnJlbnQgPSByZW1vdmUobm9kZSwgaW5wdXQpO1xuICB2YXIgdmFsdWVzID0gaW50ZXJwcmV0KGlucHV0KTtcbiAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIHZhbHVlcyk7XG4gIHNldChub2RlLCBjdXJyZW50KTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSAobm9kZSwgaW5wdXQpIHtcbiAgdmFyIGN1cnJlbnQgPSBjbGFzc2VzKG5vZGUpO1xuICB2YXIgdmFsdWVzID0gaW50ZXJwcmV0KGlucHV0KTtcbiAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGkgPSBjdXJyZW50LmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9KTtcbiAgc2V0KG5vZGUsIGN1cnJlbnQpO1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMgKG5vZGUsIGlucHV0KSB7XG4gIHZhciBjdXJyZW50ID0gY2xhc3Nlcyhub2RlKTtcbiAgdmFyIHZhbHVlcyA9IGludGVycHJldChpbnB1dCk7XG5cbiAgcmV0dXJuIHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudC5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGQsXG4gIHJlbW92ZTogcmVtb3ZlLFxuICBjb250YWluczogY29udGFpbnMsXG4gIHNldDogc2V0LFxuICBnZXQ6IGNsYXNzZXNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG52YXIgRG9taW51cyA9IHJlcXVpcmUoJy4vRG9taW51cy5jdG9yJyk7XG52YXIgcHJvdG8gPSBEb21pbnVzLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gQXBwbGllZCAoYXJncykge1xuICByZXR1cm4gRG9taW51cy5hcHBseSh0aGlzLCBhcmdzKTtcbn1cblxuQXBwbGllZC5wcm90b3R5cGUgPSBwcm90bztcblxuWydtYXAnLCAnZmlsdGVyJywgJ2NvbmNhdCddLmZvckVhY2goZW5zdXJlKTtcblxuZnVuY3Rpb24gZW5zdXJlIChrZXkpIHtcbiAgdmFyIG9yaWdpbmFsID0gcHJvdG9ba2V5XTtcbiAgcHJvdG9ba2V5XSA9IGZ1bmN0aW9uIGFwcGxpZWQgKCkge1xuICAgIHJldHVybiBhcHBseShvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHkgKGEpIHtcbiAgcmV0dXJuIG5ldyBBcHBsaWVkKGEpO1xufVxuXG5mdW5jdGlvbiBjYXN0IChhKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgRG9taW51cykge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGlmICghYSkge1xuICAgIHJldHVybiBuZXcgRG9taW51cygpO1xuICB9XG4gIGlmICh0ZXN0LmlzRWxlbWVudChhKSkge1xuICAgIHJldHVybiBuZXcgRG9taW51cyhhKTtcbiAgfVxuICBpZiAoIXRlc3QuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBuZXcgRG9taW51cygpO1xuICB9XG4gIHJldHVybiBhcHBseShhKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gdGVzdC5pc0VsZW1lbnQoaSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhLCBjYWNoZSkge1xuICByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24gKGN1cnJlbnQsIGl0ZW0pIHtcbiAgICBpZiAoRG9taW51cy5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmxhdHRlbihpdGVtLCBjdXJyZW50KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjdXJyZW50LmNvbmNhdChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH0sIGNhY2hlIHx8IG5ldyBEb21pbnVzKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbHk6IGFwcGx5LFxuICBjYXN0OiBjYXN0LFxuICBmbGF0dGVuOiBmbGF0dGVuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VrdG9yID0gcmVxdWlyZSgnc2VrdG9yJyk7XG52YXIgRG9taW51cyA9IHJlcXVpcmUoJy4vRG9taW51cy5jdG9yJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJy4vdGV4dCcpO1xudmFyIHRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcbnZhciBhcGkgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIGRlbGVnYXRlcyA9IHt9O1xuXG5mdW5jdGlvbiBjYXN0Q29udGV4dCAoY29udGV4dCkge1xuICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGFwaS5xcyhudWxsLCBjb250ZXh0KTtcbiAgfVxuICBpZiAodGVzdC5pc0VsZW1lbnQoY29udGV4dCkpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIERvbWludXMpIHtcbiAgICByZXR1cm4gY29udGV4dFswXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuYXBpLnFzYSA9IGZ1bmN0aW9uIChlbGVtLCBzZWxlY3Rvcikge1xuICB2YXIgcmVzdWx0cyA9IG5ldyBEb21pbnVzKCk7XG4gIHJldHVybiBzZWt0b3Ioc2VsZWN0b3IsIGNhc3RDb250ZXh0KGVsZW0pLCByZXN1bHRzKTtcbn07XG5cbmFwaS5xcyA9IGZ1bmN0aW9uIChlbGVtLCBzZWxlY3Rvcikge1xuICByZXR1cm4gYXBpLnFzYShlbGVtLCBzZWxlY3RvcilbMF07XG59O1xuXG5hcGkubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtLCBzZWxlY3Rvcikge1xuICByZXR1cm4gc2VrdG9yLm1hdGNoZXNTZWxlY3RvcihlbGVtLCBzZWxlY3Rvcik7XG59O1xuXG5mdW5jdGlvbiByZWxhdGVkRmFjdG9yeSAocHJvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gcmVsYXRlZCAoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcmVsYXRpdmUgPSBlbGVtW3Byb3BdO1xuICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgaWYgKCFzZWxlY3RvciB8fCBhcGkubWF0Y2hlcyhyZWxhdGl2ZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmNhc3QocmVsYXRpdmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERvbWludXMoKTtcbiAgfTtcbn1cblxuYXBpLnByZXYgPSByZWxhdGVkRmFjdG9yeSgncHJldmlvdXNFbGVtZW50U2libGluZycpO1xuYXBpLm5leHQgPSByZWxhdGVkRmFjdG9yeSgnbmV4dEVsZW1lbnRTaWJsaW5nJyk7XG5hcGkucGFyZW50ID0gcmVsYXRlZEZhY3RvcnkoJ3BhcmVudEVsZW1lbnQnKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyAoZWxlbSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERvbWludXMpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gIH1cbiAgaWYgKHRlc3QuaXNFbGVtZW50KHZhbHVlKSkge1xuICAgIHJldHVybiBlbGVtID09PSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gYXBpLm1hdGNoZXMoZWxlbSwgdmFsdWUpO1xufVxuXG5hcGkucGFyZW50cyA9IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIG5vZGUgPSBlbGVtO1xuICB3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKG1hdGNoZXMobm9kZS5wYXJlbnRFbGVtZW50LCB2YWx1ZSkpIHtcbiAgICAgIG5vZGVzLnB1c2gobm9kZS5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gY29yZS5hcHBseShub2Rlcyk7XG59O1xuXG5hcGkuY2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW47XG4gIHZhciBjaGlsZDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKG1hdGNoZXMoY2hpbGQsIHZhbHVlKSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlLmFwcGx5KG5vZGVzKTtcbn07XG5cbi8vIHRoaXMgbWV0aG9kIGNhY2hlcyBkZWxlZ2F0ZXMgc28gdGhhdCAub2ZmKCkgd29ya3Mgc2VhbWxlc3NseVxuZnVuY3Rpb24gZGVsZWdhdGUgKHJvb3QsIGZpbHRlciwgZm4pIHtcbiAgaWYgKGRlbGVnYXRlc1tmbi5fZGRdKSB7XG4gICAgcmV0dXJuIGRlbGVnYXRlc1tmbi5fZGRdO1xuICB9XG4gIGZuLl9kZCA9IERhdGUubm93KCk7XG4gIGRlbGVnYXRlc1tmbi5fZGRdID0gZGVsZWdhdG9yO1xuICBmdW5jdGlvbiBkZWxlZ2F0b3IgKGUpIHtcbiAgICB2YXIgZWxlbSA9IGUudGFyZ2V0O1xuICAgIHdoaWxlIChlbGVtICYmIGVsZW0gIT09IHJvb3QpIHtcbiAgICAgIGlmIChhcGkubWF0Y2hlcyhlbGVtLCBmaWx0ZXIpKSB7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW0gPSBlbGVtLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWxlZ2F0b3I7XG59XG5cbmFwaS5vbiA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBmaWx0ZXIsIGZuKSB7XG4gIGlmIChmbiA9PT0gdm9pZCAwKSB7XG4gICAgZXZlbnRzLmFkZChlbGVtLCB0eXBlLCBmaWx0ZXIpOyAvLyBmaWx0ZXIgX2lzXyBmblxuICB9IGVsc2Uge1xuICAgIGV2ZW50cy5hZGQoZWxlbSwgdHlwZSwgZGVsZWdhdGUoZWxlbSwgZmlsdGVyLCBmbikpO1xuICB9XG59O1xuXG5hcGkub2ZmID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGZpbHRlciwgZm4pIHtcbiAgaWYgKGZuID09PSB2b2lkIDApIHtcbiAgICBldmVudHMucmVtb3ZlKGVsZW0sIHR5cGUsIGZpbHRlcik7IC8vIGZpbHRlciBfaXNfIGZuXG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzLnJlbW92ZShlbGVtLCB0eXBlLCBkZWxlZ2F0ZShlbGVtLCBmaWx0ZXIsIGZuKSk7XG4gIH1cbn07XG5cbmFwaS5odG1sID0gZnVuY3Rpb24gKGVsZW0sIGh0bWwpIHtcbiAgdmFyIGdldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAyO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufTtcblxuYXBpLnRleHQgPSBmdW5jdGlvbiAoZWxlbSwgdGV4dCkge1xuICB2YXIgY2hlY2thYmxlID0gdGVzdC5pc0NoZWNrYWJsZShlbGVtKTtcbiAgdmFyIGdldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAyO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIGNoZWNrYWJsZSA/IGVsZW0udmFsdWUgOiBlbGVtLmlubmVyVGV4dCB8fCBlbGVtLnRleHRDb250ZW50O1xuICB9IGVsc2UgaWYgKGNoZWNrYWJsZSkge1xuICAgIGVsZW0udmFsdWUgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGVsZW0uaW5uZXJUZXh0ID0gZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cbn07XG5cbmFwaS52YWx1ZSA9IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICB2YXIgY2hlY2thYmxlID0gdGVzdC5pc0NoZWNrYWJsZShlbGVtKTtcbiAgdmFyIGdldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAyO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIGNoZWNrYWJsZSA/IGVsZW0uY2hlY2tlZCA6IGVsZW0udmFsdWU7XG4gIH0gZWxzZSBpZiAoY2hlY2thYmxlKSB7XG4gICAgZWxlbS5jaGVja2VkID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZWxlbS52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xuXG5hcGkuYXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgY2FtZWwgPSB0ZXh0Lmh5cGhlblRvQ2FtZWwobmFtZSk7XG4gIGlmIChjYW1lbCBpbiBlbGVtKSB7XG4gICAgZWxlbVtjYW1lbF0gPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG5hcGkuZ2V0QXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XG4gIHZhciBjYW1lbCA9IHRleHQuaHlwaGVuVG9DYW1lbChuYW1lKTtcbiAgaWYgKGNhbWVsIGluIGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbVtjYW1lbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuICB9XG59O1xuXG5hcGkubWFueUF0dHIgPSBmdW5jdGlvbiAoZWxlbSwgYXR0cnMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICBhcGkuYXR0cihlbGVtLCBhdHRyLCBhdHRyc1thdHRyXSk7XG4gIH0pO1xufTtcblxuYXBpLm1ha2UgPSBmdW5jdGlvbiAodHlwZSkge1xuICByZXR1cm4gbmV3IERvbWludXMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKSk7XG59O1xuXG5hcGkuY2xvbmUgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5jbG9uZU5vZGUodHJ1ZSk7XG59O1xuXG5hcGkucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgaWYgKGVsZW0ucGFyZW50RWxlbWVudCkge1xuICAgIGVsZW0ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgfVxufTtcblxuYXBpLmFwcGVuZCA9IGZ1bmN0aW9uIChlbGVtLCB0YXJnZXQpIHtcbiAgaWYgKG1hbmlwdWxhdGlvbkd1YXJkKGVsZW0sIHRhcmdldCwgYXBpLmFwcGVuZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbS5hcHBlbmRDaGlsZCh0YXJnZXQpO1xufTtcblxuYXBpLnByZXBlbmQgPSBmdW5jdGlvbiAoZWxlbSwgdGFyZ2V0KSB7XG4gIGlmIChtYW5pcHVsYXRpb25HdWFyZChlbGVtLCB0YXJnZXQsIGFwaS5wcmVwZW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtLmluc2VydEJlZm9yZSh0YXJnZXQsIGVsZW0uZmlyc3RDaGlsZCk7XG59O1xuXG5hcGkuYmVmb3JlID0gZnVuY3Rpb24gKGVsZW0sIHRhcmdldCkge1xuICBpZiAobWFuaXB1bGF0aW9uR3VhcmQoZWxlbSwgdGFyZ2V0LCBhcGkuYmVmb3JlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbS5wYXJlbnRFbGVtZW50KSB7XG4gICAgZWxlbS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIGVsZW0pO1xuICB9XG59O1xuXG5hcGkuYWZ0ZXIgPSBmdW5jdGlvbiAoZWxlbSwgdGFyZ2V0KSB7XG4gIGlmIChtYW5pcHVsYXRpb25HdWFyZChlbGVtLCB0YXJnZXQsIGFwaS5hZnRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW0ucGFyZW50RWxlbWVudCkge1xuICAgIGVsZW0ucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBlbGVtLm5leHRTaWJsaW5nKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uR3VhcmQgKGVsZW0sIHRhcmdldCwgZm4pIHtcbiAgdmFyIHJpZ2h0ID0gdGFyZ2V0IGluc3RhbmNlb2YgRG9taW51cztcbiAgdmFyIGxlZnQgPSBlbGVtIGluc3RhbmNlb2YgRG9taW51cztcbiAgaWYgKGxlZnQpIHtcbiAgICBlbGVtLmZvckVhY2gobWFuaXB1bGF0ZU1hbnkpO1xuICB9IGVsc2UgaWYgKHJpZ2h0KSB7XG4gICAgbWFuaXB1bGF0ZShlbGVtLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gbGVmdCB8fCByaWdodDtcblxuICBmdW5jdGlvbiBtYW5pcHVsYXRlIChlbGVtLCBwcmVjb25kaXRpb24pIHtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIHRhcmdldC5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQsIGopIHtcbiAgICAgICAgZm4oZWxlbSwgY2xvbmVVbmxlc3ModGFyZ2V0LCBwcmVjb25kaXRpb24gJiYgaiA9PT0gMCkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKGVsZW0sIGNsb25lVW5sZXNzKHRhcmdldCwgcHJlY29uZGl0aW9uKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFuaXB1bGF0ZU1hbnkgKGVsZW0sIGkpIHtcbiAgICBtYW5pcHVsYXRlKGVsZW0sIGkgPT09IDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzICh0YXJnZXQsIGNvbmRpdGlvbikge1xuICByZXR1cm4gY29uZGl0aW9uID8gdGFyZ2V0IDogYXBpLmNsb25lKHRhcmdldCk7XG59XG5cblsnYXBwZW5kVG8nLCAncHJlcGVuZFRvJywgJ2JlZm9yZU9mJywgJ2FmdGVyT2YnXS5mb3JFYWNoKGZsaXApO1xuXG5mdW5jdGlvbiBmbGlwIChrZXkpIHtcbiAgdmFyIG9yaWdpbmFsID0ga2V5LnNwbGl0KC9bQS1aXS8pWzBdO1xuICBhcGlba2V5XSA9IGZ1bmN0aW9uIChlbGVtLCB0YXJnZXQpIHtcbiAgICBhcGlbb3JpZ2luYWxdKHRhcmdldCwgZWxlbSk7XG4gIH07XG59XG5cbmFwaS5zaG93ID0gZnVuY3Rpb24gKGVsZW0sIHNob3VsZCwgaW52ZXJ0KSB7XG4gIGlmIChlbGVtIGluc3RhbmNlb2YgRG9taW51cykge1xuICAgIGVsZW0uZm9yRWFjaChzaG93VGVzdCk7XG4gIH0gZWxzZSB7XG4gICAgc2hvd1Rlc3QoZWxlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93VGVzdCAoY3VycmVudCkge1xuICAgIHZhciBvayA9IHNob3VsZCA9PT0gdm9pZCAwIHx8IHNob3VsZCA9PT0gdHJ1ZSB8fCB0eXBlb2Ygc2hvdWxkID09PSAnZnVuY3Rpb24nICYmIHNob3VsZC5jYWxsKGN1cnJlbnQpO1xuICAgIGRpc3BsYXkoY3VycmVudCwgaW52ZXJ0ID8gIW9rIDogb2spO1xuICB9XG59O1xuXG5hcGkuaGlkZSA9IGZ1bmN0aW9uIChlbGVtLCBzaG91bGQpIHtcbiAgYXBpLnNob3coZWxlbSwgc2hvdWxkLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGRpc3BsYXkgKGVsZW0sIHNob3VsZCkge1xuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG91bGQgPyAnYmxvY2snIDogJ25vbmUnO1xufVxuXG52YXIgbnVtZXJpY0Nzc1Byb3BlcnRpZXMgPSB7XG4gICdjb2x1bW4tY291bnQnOiB0cnVlLFxuICAnZmlsbC1vcGFjaXR5JzogdHJ1ZSxcbiAgJ2ZsZXgtZ3Jvdyc6IHRydWUsXG4gICdmbGV4LXNocmluayc6IHRydWUsXG4gICdmb250LXdlaWdodCc6IHRydWUsXG4gICdsaW5lLWhlaWdodCc6IHRydWUsXG4gICdvcGFjaXR5JzogdHJ1ZSxcbiAgJ29yZGVyJzogdHJ1ZSxcbiAgJ29ycGhhbnMnOiB0cnVlLFxuICAnd2lkb3dzJzogdHJ1ZSxcbiAgJ3otaW5kZXgnOiB0cnVlLFxuICAnem9vbSc6IHRydWVcbn07XG52YXIgbnVtZXJpYyA9IC9eXFxkKyQvO1xudmFyIGNhbkZsb2F0ID0gJ2Zsb2F0JyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG5hcGkuZ2V0Q3NzID0gZnVuY3Rpb24gKGVsZW0sIHByb3ApIHtcbiAgdmFyIGhwcm9wID0gdGV4dC5oeXBoZW5hdGUocHJvcCk7XG4gIHZhciBmcHJvcCA9ICFjYW5GbG9hdCAmJiBocHJvcCA9PT0gJ2Zsb2F0JyA/ICdjc3NGbG9hdCcgOiBocHJvcDtcbiAgdmFyIHJlc3VsdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pW2hwcm9wXTtcbiAgaWYgKHByb3AgPT09ICdvcGFjaXR5JyAmJiByZXN1bHQgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdWJzdHIoLTIpID09PSAncHgnIHx8IG51bWVyaWMudGVzdChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzdWx0LCAxMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmFwaS5zZXRDc3MgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIG1hcHBlZCA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoYmFkKS5tYXAoZXhwYW5kKTtcbiAgZnVuY3Rpb24gYmFkIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlID09PSB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBleHBhbmQgKHByb3ApIHtcbiAgICB2YXIgaHByb3AgPSB0ZXh0Lmh5cGhlbmF0ZShwcm9wKTtcbiAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhbnVtZXJpY0Nzc1Byb3BlcnRpZXNbaHByb3BdKSB7XG4gICAgICB2YWx1ZSArPSAncHgnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogaHByb3AsIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgbWFwcGVkLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGVsZW0uc3R5bGVbcHJvcC5uYW1lXSA9IHByb3AudmFsdWU7XG4gICAgfSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRG9taW51cy5wcm90b3R5cGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFkZEV2ZW50ID0gYWRkRXZlbnRFYXN5O1xudmFyIHJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnRFYXN5O1xudmFyIGhhcmRDYWNoZSA9IFtdO1xuXG5pZiAoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gIGFkZEV2ZW50ID0gYWRkRXZlbnRIYXJkO1xufVxuXG5pZiAoIXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gIHJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnRIYXJkO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEVhc3kgKGVsZW1lbnQsIGV2dCwgZm4pIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRIYXJkIChlbGVtZW50LCBldnQsIGZuKSB7XG4gIHJldHVybiBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldnQsIHdyYXAoZWxlbWVudCwgZXZ0LCBmbikpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudEVhc3kgKGVsZW1lbnQsIGV2dCwgZm4pIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRIYXJkIChlbGVtZW50LCBldnQsIGZuKSB7XG4gIHJldHVybiBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldnQsIHVud3JhcChlbGVtZW50LCBldnQsIGZuKSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBwZXJGYWN0b3J5IChlbGVtZW50LCBldnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwcGVyIChvcmlnaW5hbEV2ZW50KSB7XG4gICAgdmFyIGUgPSBvcmlnaW5hbEV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICBlLnRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBlLnByZXZlbnREZWZhdWx0ICA9IGUucHJldmVudERlZmF1bHQgIHx8IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9O1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9O1xuICAgIGZuLmNhbGwoZWxlbWVudCwgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdyYXAgKGVsZW1lbnQsIGV2dCwgZm4pIHtcbiAgdmFyIHdyYXBwZXIgPSB1bndyYXAoZWxlbWVudCwgZXZ0LCBmbikgfHwgd3JhcHBlckZhY3RvcnkoZWxlbWVudCwgZXZ0LCBmbik7XG4gIGhhcmRDYWNoZS5wdXNoKHtcbiAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgZXZ0OiBldnQsXG4gICAgZm46IGZuXG4gIH0pO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZnVuY3Rpb24gdW53cmFwIChlbGVtZW50LCBldnQsIGZuKSB7XG4gIHZhciBpID0gZmluZChlbGVtZW50LCBldnQsIGZuKTtcbiAgaWYgKGkpIHtcbiAgICB2YXIgd3JhcHBlciA9IGhhcmRDYWNoZVtpXS53cmFwcGVyO1xuICAgIGhhcmRDYWNoZS5zcGxpY2UoaSwgMSk7IC8vIGZyZWUgdXAgYSB0YWQgb2YgbWVtb3J5XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZCAoZWxlbWVudCwgZXZ0LCBmbikge1xuICB2YXIgaSwgaXRlbTtcbiAgZm9yIChpID0gMDsgaSA8IGhhcmRDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgIGl0ZW0gPSBoYXJkQ2FjaGVbaV07XG4gICAgaWYgKGl0ZW0uZWxlbWVudCA9PT0gZWxlbWVudCAmJiBpdGVtLmV2dCA9PT0gZXZ0ICYmIGl0ZW0uZm4gPT09IGZuKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkRXZlbnQsXG4gIHJlbW92ZTogcmVtb3ZlRXZlbnRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBEb21pbnVzID0gcmVxdWlyZSgnLi9Eb21pbnVzLmN0b3InKTtcbnZhciB0YWcgPSAvXlxccyo8KFthLXpdKyg/Oi1bYS16XSspPylcXHMqXFwvPz5cXHMqJC9pO1xuXG5mdW5jdGlvbiBhcGkgKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gIHZhciBub3RUZXh0ID0gdHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJztcbiAgaWYgKG5vdFRleHQgJiYgYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gY29yZS5jYXN0KHNlbGVjdG9yKTtcbiAgfVxuICBpZiAobm90VGV4dCkge1xuICAgIHJldHVybiBuZXcgRG9taW51cygpO1xuICB9XG4gIHZhciBtYXRjaGVzID0gc2VsZWN0b3IubWF0Y2godGFnKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4gZG9tLm1ha2UobWF0Y2hlc1sxXSk7XG4gIH1cbiAgcmV0dXJuIGFwaS5maW5kKHNlbGVjdG9yLCBjb250ZXh0KTtcbn1cblxuYXBpLmZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGRvbS5xc2EoY29udGV4dCwgc2VsZWN0b3IpO1xufTtcblxuYXBpLmZpbmRPbmUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGRvbS5xcyhjb250ZXh0LCBzZWxlY3Rvcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5vZGVPYmplY3RzID0gdHlwZW9mIE5vZGUgPT09ICdvYmplY3QnO1xudmFyIGVsZW1lbnRPYmplY3RzID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0JztcblxuZnVuY3Rpb24gaXNOb2RlIChvKSB7XG4gIHJldHVybiBub2RlT2JqZWN0cyA/IG8gaW5zdGFuY2VvZiBOb2RlIDogaXNOb2RlT2JqZWN0KG8pO1xufVxuXG5mdW5jdGlvbiBpc05vZGVPYmplY3QgKG8pIHtcbiAgcmV0dXJuIG8gJiZcbiAgICB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2Ygby5ub2RlVHlwZSA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCAobykge1xuICByZXR1cm4gZWxlbWVudE9iamVjdHMgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiBpc0VsZW1lbnRPYmplY3Qobyk7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudE9iamVjdCAobykge1xuICByZXR1cm4gbyAmJlxuICAgIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJlxuICAgIG8ubm9kZVR5cGUgPT09IDE7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKGEpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUgKGVsZW0pIHtcbiAgcmV0dXJuICdjaGVja2VkJyBpbiBlbGVtICYmIGVsZW0udHlwZSA9PT0gJ3JhZGlvJyB8fCBlbGVtLnR5cGUgPT09ICdjaGVja2JveCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc05vZGU6IGlzTm9kZSxcbiAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQ2hlY2thYmxlOiBpc0NoZWNrYWJsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaHlwaGVuVG9DYW1lbCAoaHlwaGVucykge1xuICB2YXIgcGFydCA9IC8tKFthLXpdKS9nO1xuICByZXR1cm4gaHlwaGVucy5yZXBsYWNlKHBhcnQsIGZ1bmN0aW9uIChnLCBtKSB7XG4gICAgcmV0dXJuIG0udG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZSAodGV4dCkge1xuICB2YXIgY2FtZWwgPSAvKFthLXpdKShbQS1aXSkvZztcbiAgcmV0dXJuIHRleHQucmVwbGFjZShjYW1lbCwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGh5cGhlblRvQ2FtZWw6IGh5cGhlblRvQ2FtZWwsXG4gIGh5cGhlbmF0ZTogaHlwaGVuYXRlXG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuamFkZT1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gYXR0cmlidXRlIG9iamVjdHMgZ2l2aW5nIHByZWNlZGVuY2VcclxuICogdG8gdmFsdWVzIGluIG9iamVjdCBgYmAuIENsYXNzZXMgYXJlIHNwZWNpYWwtY2FzZWRcclxuICogYWxsb3dpbmcgZm9yIGFycmF5cyBhbmQgbWVyZ2luZy9qb2luaW5nIGFwcHJvcHJpYXRlbHlcclxuICogcmVzdWx0aW5nIGluIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gYVxyXG4gKiBAcGFyYW0ge09iamVjdH0gYlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgdmFyIGF0dHJzID0gYVswXTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCBhW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhdHRycztcclxuICB9XHJcbiAgdmFyIGFjID0gYVsnY2xhc3MnXTtcclxuICB2YXIgYmMgPSBiWydjbGFzcyddO1xyXG5cclxuICBpZiAoYWMgfHwgYmMpIHtcclxuICAgIGFjID0gYWMgfHwgW107XHJcbiAgICBiYyA9IGJjIHx8IFtdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjKSkgYWMgPSBbYWNdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJjKSkgYmMgPSBbYmNdO1xyXG4gICAgYVsnY2xhc3MnXSA9IGFjLmNvbmNhdChiYykuZmlsdGVyKG51bGxzKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBiKSB7XHJcbiAgICBpZiAoa2V5ICE9ICdjbGFzcycpIHtcclxuICAgICAgYVtrZXldID0gYltrZXldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGE7XHJcbn07XHJcblxyXG4vKipcclxuICogRmlsdGVyIG51bGwgYHZhbGBzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBudWxscyh2YWwpIHtcclxuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdmFsICE9PSAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGpvaW4gYXJyYXkgYXMgY2xhc3Nlcy5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWxcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0cy5qb2luQ2xhc3NlcyA9IGpvaW5DbGFzc2VzO1xyXG5mdW5jdGlvbiBqb2luQ2xhc3Nlcyh2YWwpIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLm1hcChqb2luQ2xhc3NlcykuZmlsdGVyKG51bGxzKS5qb2luKCcgJykgOiB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzZXNcclxuICogQHBhcmFtIHtBcnJheS48Qm9vbGVhbj59IGVzY2FwZWRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0cy5jbHMgPSBmdW5jdGlvbiBjbHMoY2xhc3NlcywgZXNjYXBlZCkge1xyXG4gIHZhciBidWYgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChlc2NhcGVkICYmIGVzY2FwZWRbaV0pIHtcclxuICAgICAgYnVmLnB1c2goZXhwb3J0cy5lc2NhcGUoam9pbkNsYXNzZXMoW2NsYXNzZXNbaV1dKSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVmLnB1c2goam9pbkNsYXNzZXMoY2xhc3Nlc1tpXSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgdGV4dCA9IGpvaW5DbGFzc2VzKGJ1Zik7XHJcbiAgaWYgKHRleHQubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gJyBjbGFzcz1cIicgKyB0ZXh0ICsgJ1wiJztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXNjYXBlZFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRlcnNlXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICovXHJcbmV4cG9ydHMuYXR0ciA9IGZ1bmN0aW9uIGF0dHIoa2V5LCB2YWwsIGVzY2FwZWQsIHRlcnNlKSB7XHJcbiAgaWYgKCdib29sZWFuJyA9PSB0eXBlb2YgdmFsIHx8IG51bGwgPT0gdmFsKSB7XHJcbiAgICBpZiAodmFsKSB7XHJcbiAgICAgIHJldHVybiAnICcgKyAodGVyc2UgPyBrZXkgOiBrZXkgKyAnPVwiJyArIGtleSArICdcIicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoMCA9PSBrZXkuaW5kZXhPZignZGF0YScpICYmICdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHtcclxuICAgIHJldHVybiAnICcgKyBrZXkgKyBcIj0nXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpLnJlcGxhY2UoLycvZywgJyZhcG9zOycpICsgXCInXCI7XHJcbiAgfSBlbHNlIGlmIChlc2NhcGVkKSB7XHJcbiAgICByZXR1cm4gJyAnICsga2V5ICsgJz1cIicgKyBleHBvcnRzLmVzY2FwZSh2YWwpICsgJ1wiJztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICcgJyArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVyIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXNjYXBlZFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5leHBvcnRzLmF0dHJzID0gZnVuY3Rpb24gYXR0cnMob2JqLCB0ZXJzZSl7XHJcbiAgdmFyIGJ1ZiA9IFtdO1xyXG5cclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcblxyXG4gIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldXHJcbiAgICAgICAgLCB2YWwgPSBvYmpba2V5XTtcclxuXHJcbiAgICAgIGlmICgnY2xhc3MnID09IGtleSkge1xyXG4gICAgICAgIGlmICh2YWwgPSBqb2luQ2xhc3Nlcyh2YWwpKSB7XHJcbiAgICAgICAgICBidWYucHVzaCgnICcgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBidWYucHVzaChleHBvcnRzLmF0dHIoa2V5LCB2YWwsIGZhbHNlLCB0ZXJzZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBodG1sYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShodG1sKXtcclxuICB2YXIgcmVzdWx0ID0gU3RyaW5nKGh0bWwpXHJcbiAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcclxuICBpZiAocmVzdWx0ID09PSAnJyArIGh0bWwpIHJldHVybiBodG1sO1xyXG4gIGVsc2UgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZS10aHJvdyB0aGUgZ2l2ZW4gYGVycmAgaW4gY29udGV4dCB0byB0aGVcclxuICogdGhlIGphZGUgaW4gYGZpbGVuYW1lYCBhdCB0aGUgZ2l2ZW4gYGxpbmVub2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcclxuICogQHBhcmFtIHtTdHJpbmd9IGxpbmVub1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLnJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KGVyciwgZmlsZW5hbWUsIGxpbmVubywgc3RyKXtcclxuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGVycjtcclxuICBpZiAoKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgfHwgIWZpbGVuYW1lKSAmJiAhc3RyKSB7XHJcbiAgICBlcnIubWVzc2FnZSArPSAnIG9uIGxpbmUgJyArIGxpbmVubztcclxuICAgIHRocm93IGVycjtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHN0ciA9IHN0ciB8fCBfZGVyZXFfKCdmcycpLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKVxyXG4gIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICByZXRocm93KGVyciwgbnVsbCwgbGluZW5vKVxyXG4gIH1cclxuICB2YXIgY29udGV4dCA9IDNcclxuICAgICwgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpXHJcbiAgICAsIHN0YXJ0ID0gTWF0aC5tYXgobGluZW5vIC0gY29udGV4dCwgMClcclxuICAgICwgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBsaW5lbm8gKyBjb250ZXh0KTtcclxuXHJcbiAgLy8gRXJyb3IgY29udGV4dFxyXG4gIHZhciBjb250ZXh0ID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGkpe1xyXG4gICAgdmFyIGN1cnIgPSBpICsgc3RhcnQgKyAxO1xyXG4gICAgcmV0dXJuIChjdXJyID09IGxpbmVubyA/ICcgID4gJyA6ICcgICAgJylcclxuICAgICAgKyBjdXJyXHJcbiAgICAgICsgJ3wgJ1xyXG4gICAgICArIGxpbmU7XHJcbiAgfSkuam9pbignXFxuJyk7XHJcblxyXG4gIC8vIEFsdGVyIGV4Y2VwdGlvbiBtZXNzYWdlXHJcbiAgZXJyLnBhdGggPSBmaWxlbmFtZTtcclxuICBlcnIubWVzc2FnZSA9IChmaWxlbmFtZSB8fCAnSmFkZScpICsgJzonICsgbGluZW5vXHJcbiAgICArICdcXG4nICsgY29udGV4dCArICdcXG5cXG4nICsgZXJyLm1lc3NhZ2U7XHJcbiAgdGhyb3cgZXJyO1xyXG59O1xyXG5cbn0se1wiZnNcIjoyfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dfSx7fSxbMV0pXG4oMSlcbn0pO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2phZGUvcnVudGltZScpO1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSBnbG9iYWxbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IGdsb2JhbFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgZ2xvYmFsWydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgLCBpc05hdGl2ZSA9IHRydWVcblxuZm9yKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICFyYWY7IGkrKykge1xuICByYWYgPSBnbG9iYWxbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gZ2xvYmFsW3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IGdsb2JhbFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgaXNOYXRpdmUgPSBmYWxzZVxuXG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICBpZighaXNOYXRpdmUpIHtcbiAgICByZXR1cm4gcmFmLmNhbGwoZ2xvYmFsLCBmbilcbiAgfVxuICByZXR1cm4gcmFmLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpIHtcbiAgICB0cnl7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlIH0sIDApXG4gICAgfVxuICB9KVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShnbG9iYWwsIGFyZ3VtZW50cylcbn1cbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93Lm1hcFxuKi9cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvbmljby8ubnZtL3YwLjEwLjI2L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpO1xudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXInKTtcbnZhciBmZXRjaGVyID0gcmVxdWlyZSgnLi9mZXRjaGVyJyk7XG52YXIgcHJlZmV0Y2hlciA9IHJlcXVpcmUoJy4vcHJlZmV0Y2hlcicpO1xudmFyIHZpZXcgPSByZXF1aXJlKCcuL3ZpZXcnKTtcbnZhciByb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9nbG9iYWwvZG9jdW1lbnQnKTtcbnZhciBsb2NhdGlvbiA9IHJlcXVpcmUoJy4vZ2xvYmFsL2xvY2F0aW9uJyk7XG52YXIgaGlzdG9yeSA9IHJlcXVpcmUoJy4vZ2xvYmFsL2hpc3RvcnknKTtcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi4vdmVyc2lvbmluZycpO1xuXG5mdW5jdGlvbiBtb2Rlcm4gKCkgeyAvLyBuZWVkcyB0byBiZSBhIGZ1bmN0aW9uIGJlY2F1c2UgdGVzdGluZ1xuICByZXR1cm4gaGlzdG9yeSAmJiBoaXN0b3J5Lm1vZGVybiAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdvICh1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIG8gPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZGlyZWN0aW9uID0gby5yZXBsYWNlU3RhdGUgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnO1xuICB2YXIgY29udGV4dCA9IG8uY29udGV4dCB8fCBudWxsO1xuICB2YXIgcm91dGUgPSByb3V0ZXIodXJsKTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIGlmIChvLnN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2FjdGl2YXRvcl0gcmVkaXJlY3RpbmcgdG8gJXMnLCB1cmwpO1xuICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2FjdGl2YXRvcl0gcm91dGUgbWF0Y2hlcyAlcycsIHJvdXRlLnJvdXRlKTtcblxuICB2YXIgbm90Rm9yY2VkID0gby5mb3JjZSAhPT0gdHJ1ZTtcbiAgdmFyIHNhbWUgPSByb3V0ZXIuZXF1YWxzKHJvdXRlLCBzdGF0ZS5yb3V0ZSk7XG4gIGlmIChzYW1lICYmIG5vdEZvcmNlZCkge1xuICAgIGlmIChyb3V0ZS5wYXJ0cy5oYXNoKSB7XG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbYWN0aXZhdG9yXSBzYW1lIHJvdXRlIGFuZCBoYXNoLCB1cGRhdGluZyBzY3JvbGwgcG9zaXRpb24nKTtcbiAgICAgIHNjcm9sbEludG8oaWQocm91dGUucGFydHMuaGFzaCksIG8uc2Nyb2xsKTtcbiAgICAgIG5hdmlnYXRpb24ocm91dGUsIHN0YXRlLm1vZGVsLCBkaXJlY3Rpb24pO1xuICAgICAgcmV0dXJuOyAvLyBhbmNob3IgaGFzaC1uYXZpZ2F0aW9uIG9uIHNhbWUgcGFnZSBpZ25vcmVzIHJvdXRlclxuICAgIH1cbiAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbYWN0aXZhdG9yXSBzYW1lIHJvdXRlLCByZXNvbHZpbmcnKTtcbiAgICByZXNvbHZlZChzdGF0ZS5tb2RlbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2FjdGl2YXRvcl0gJXMnLCBub3RGb3JjZWQgPyAnbm90IHNhbWUgcm91dGUgYXMgYmVmb3JlJyA6ICdmb3JjZWQgdG8gZmV0Y2ggc2FtZSByb3V0ZScpO1xuXG4gIGlmICghbW9kZXJuKCkpIHtcbiAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbYWN0aXZhdG9yXSBub3QgbW9kZXJuLCByZWRpcmVjdGluZyB0byAlcycsIHVybCk7XG4gICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICByZXR1cm47XG4gIH1cblxuICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbYWN0aXZhdG9yXSBmZXRjaGluZyAlcycsIHJvdXRlLnVybCk7XG4gIHByZWZldGNoZXIuYWJvcnRJbnRlbnQoKTtcbiAgZmV0Y2hlci5hYm9ydFBlbmRpbmcoKTtcbiAgZmV0Y2hlcihyb3V0ZSwgeyBlbGVtZW50OiBjb250ZXh0LCBzb3VyY2U6ICdpbnRlbnQnIH0sIG1heWJlUmVzb2x2ZWQpO1xuXG4gIGZ1bmN0aW9uIG1heWJlUmVzb2x2ZWQgKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEudmVyc2lvbiAhPT0gc3RhdGUudmVyc2lvbikge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2FjdGl2YXRvcl0gdmVyc2lvbiBjaGFuZ2UgKGlzIFwiJXNcIiwgd2FzIFwiJXNcIiksIHJlZGlyZWN0aW5nIHRvICVzJywgZGF0YS52ZXJzaW9uLCBzdGF0ZS52ZXJzaW9uLCB1cmwpO1xuICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDsgLy8gdmVyc2lvbiBjaGFuZ2UgZGVtYW5kcyBmYWxsYmFjayB0byBzdHJpY3QgbmF2aWdhdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJ3JlZGlyZWN0VG8nIGluIGRhdGEpIHtcbiAgICAgIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1thY3RpdmF0b3JdIHJlZGlyZWN0IGRldGVjdGVkIGluIHJlc3BvbnNlLCByZWRpcmVjdGluZyB0byAlcycsIGRhdGEucmVkaXJlY3RUbyk7XG4gICAgICBsb2NhdGlvbi5ocmVmID0gZGF0YS5yZWRpcmVjdFRvOyAvLyByZWRpcmVjdHMgdHlwaWNhbGx5IHJlcHJlc2VudCBsYXlvdXQgY2hhbmdlcywgd2Ugc2hvdWxkIGZvbGxvdyB0aGVtXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc29sdmVkKGRhdGEubW9kZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZWQgKG1vZGVsKSB7XG4gICAgdmFyIHNhbWUgPSByb3V0ZXIuZXF1YWxzKHJvdXRlLCBzdGF0ZS5yb3V0ZSk7XG4gICAgbmF2aWdhdGlvbihyb3V0ZSwgbW9kZWwsIHNhbWUgPyAncmVwbGFjZVN0YXRlJyA6IGRpcmVjdGlvbik7XG4gICAgdmlldyhzdGF0ZS5jb250YWluZXIsIG51bGwsIG1vZGVsLCByb3V0ZSk7XG4gICAgc2Nyb2xsSW50byhpZChyb3V0ZS5wYXJ0cy5oYXNoKSwgby5zY3JvbGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0IChkYXRhKSB7XG4gIGlmIChkYXRhLnZlcnNpb24gIT09IHN0YXRlLnZlcnNpb24pIHtcbiAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbYWN0aXZhdG9yXSB2ZXJzaW9uIGNoYW5nZSwgcmVsb2FkaW5nIGJyb3dzZXInKTtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTsgLy8gdmVyc2lvbiBtYXkgY2hhbmdlIGJldHdlZW4gVGF1bnVzIGxvYWRpbmcgYW5kIGEgbW9kZWwgYmVjb21pbmcgYXZhaWxhYmxlXG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtb2RlbCA9IGRhdGEubW9kZWw7XG4gIHZhciByb3V0ZSA9IHJvdXRlcihsb2NhdGlvbi5ocmVmKTtcbiAgbmF2aWdhdGlvbihyb3V0ZSwgbW9kZWwsICdyZXBsYWNlU3RhdGUnKTtcbiAgZW1pdHRlci5lbWl0KCdzdGFydCcsIHN0YXRlLmNvbnRhaW5lciwgbW9kZWwsIHJvdXRlKTtcbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2FjdGl2YXRvcl0gc3RhcnRlZCwgZXhlY3V0aW5nIGNsaWVudC1zaWRlIGNvbnRyb2xsZXInKTtcbiAgdmlldyhzdGF0ZS5jb250YWluZXIsIG51bGwsIG1vZGVsLCByb3V0ZSwgeyByZW5kZXI6IGZhbHNlIH0pO1xuICBnbG9iYWwub25wb3BzdGF0ZSA9IGJhY2s7XG59XG5cbmZ1bmN0aW9uIGJhY2sgKGUpIHtcbiAgdmFyIHMgPSBlLnN0YXRlO1xuICB2YXIgZW1wdHkgPSAhcyB8fCAhcy5fX3RhdW51cztcbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1thY3RpdmF0b3JdIGJhY2t3YXJkcyBoaXN0b3J5IG5hdmlnYXRpb24gd2l0aCBzdGF0ZScsIHMpO1xuICB2YXIgbW9kZWwgPSBzLm1vZGVsO1xuICB2YXIgcm91dGUgPSByb3V0ZXIobG9jYXRpb24uaHJlZik7XG4gIG5hdmlnYXRpb24ocm91dGUsIG1vZGVsLCAncmVwbGFjZVN0YXRlJyk7XG4gIHZpZXcoc3RhdGUuY29udGFpbmVyLCBudWxsLCBtb2RlbCwgcm91dGUpO1xuICBzY3JvbGxJbnRvKGlkKHJvdXRlLnBhcnRzLmhhc2gpKTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsSW50byAoaWQsIGVuYWJsZWQpIHtcbiAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1thY3RpdmF0b3JdIHNjcm9sbGluZyBpbnRvIFwiJXNcIicsIGlkIHx8ICcjZG9jdW1lbnQnKTtcblxuICB2YXIgZWxlbSA9IGlkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChlbGVtICYmIGVsZW0uc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICByYWYoc2Nyb2xsU29vbik7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxTb29uICgpIHtcbiAgICBlbGVtLnNjcm9sbEludG9WaWV3KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaWQgKGhhc2gpIHtcbiAgcmV0dXJuIG9yRW1wdHkoaGFzaCkuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBvckVtcHR5ICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIG5hdmlnYXRpb24gKHJvdXRlLCBtb2RlbCwgZGlyZWN0aW9uKSB7XG4gIHZhciBkYXRhO1xuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1thY3RpdmF0b3JdIGhpc3RvcnkgOiVzICVzJywgZGlyZWN0aW9uLnJlcGxhY2UoJ1N0YXRlJywgJycpLCByb3V0ZS51cmwpO1xuICBzdGF0ZS5yb3V0ZSA9IHJvdXRlO1xuICBzdGF0ZS5tb2RlbCA9IGNsb25lKG1vZGVsKTtcbiAgaWYgKG1vZGVsLnRpdGxlKSB7XG4gICAgZG9jdW1lbnQudGl0bGUgPSBtb2RlbC50aXRsZTtcbiAgfVxuICBpZiAobW9kZXJuKCkgJiYgaGlzdG9yeVtkaXJlY3Rpb25dKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIF9fdGF1bnVzOiB0cnVlLFxuICAgICAgbW9kZWw6IG1vZGVsXG4gICAgfTtcbiAgICBoaXN0b3J5W2RpcmVjdGlvbl0oZGF0YSwgbW9kZWwudGl0bGUsIHJvdXRlLnVybCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXJ0OiBzdGFydCxcbiAgZ286IGdvXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xudmFyIG9uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcbnZhciByYXcgPSByZXF1aXJlKCcuL3N0b3Jlcy9yYXcnKTtcbnZhciBpZGIgPSByZXF1aXJlKCcuL3N0b3Jlcy9pZGInKTtcbnZhciB2ZXJzaW9uaW5nID0gcmVxdWlyZSgnLi4vdmVyc2lvbmluZycpO1xudmFyIHN0b3JlcyA9IFtyYXcsIGlkYl07XG5cbmZ1bmN0aW9uIGdldCAodHlwZSwga2V5LCBkb25lKSB7XG4gIHZhciBpID0gMDtcblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICB2YXIgZ290T25jZSA9IG9uY2UoZ290KTtcbiAgICB2YXIgc3RvcmUgPSBzdG9yZXNbaSsrXTtcbiAgICBpZiAoc3RvcmUpIHtcbiAgICAgIHN0b3JlLmdldCh0eXBlLCBrZXksIGdvdE9uY2UpO1xuICAgICAgc2V0VGltZW91dChnb3RPbmNlLCBzdG9yZSA9PT0gaWRiID8gMzUgOiA1KTsgLy8gYXQgd29yc3QsIHNwZW5kIDQwbXMgb24gY2FjaGluZyBsYXllcnNcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb3QgKGVyciwgaXRlbSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbGlkKGl0ZW0pKSB7XG4gICAgICAgIGRvbmUoZmFsc2UsIGJsb2IoaXRlbSkpOyAvLyBhbHdheXMgcmV0dXJuIGEgdW5pcXVlIGNvcHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZCAoaXRlbSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FjaGUgbXVzdCBoYXZlIGl0ZW1cbiAgICAgIH1cbiAgICAgIHZhciBtaXNtYXRjaCA9IHR5cGVvZiBpdGVtLnZlcnNpb24gIT09ICdzdHJpbmcnIHx8IGl0ZW0udmVyc2lvbiAhPT0gc3RhdGUudmVyc2lvbjtcbiAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhY2hlIG11c3QgbWF0Y2ggY3VycmVudCB2ZXJzaW9uXG4gICAgICB9XG4gICAgICB2YXIgc3RhbGUgPSB0eXBlb2YgaXRlbS5leHBpcmVzICE9PSAnbnVtYmVyJyB8fCBEYXRlLm5vdygpID49IGl0ZW0uZXhwaXJlcztcbiAgICAgIGlmIChzdGFsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhY2hlIG11c3QgYmUgZnJlc2hcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJsb2IgKGl0ZW0pIHtcbiAgICAgIHZhciBzaW5ndWxhciA9IHR5cGUuc3Vic3RyKDAsIHR5cGUubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgZGF0YSA9IGNsb25lKGl0ZW0uZGF0YSk7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgfTtcbiAgICAgIHJlc3BvbnNlW3Npbmd1bGFyXSA9IGRhdGE7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBzZXQgKHR5cGUsIGtleSwgZGF0YSwgZHVyYXRpb24pIHtcbiAgaWYgKGR1cmF0aW9uIDwgMSkgeyAvLyBzYW5pdHlcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNsb25lZCA9IGNsb25lKGRhdGEpOyAvLyBmcmVlemUgYSBjb3B5IGZvciBvdXIgcmVjb3Jkc1xuICBzdG9yZXMuZm9yRWFjaChzdG9yZSk7XG4gIGZ1bmN0aW9uIHN0b3JlIChzKSB7XG4gICAgcy5zZXQodHlwZSwga2V5LCB7XG4gICAgICBkYXRhOiBjbG9uZWQsXG4gICAgICB2ZXJzaW9uOiBzdGF0ZS52ZXJzaW9uLFxuICAgICAgZXhwaXJlczogRGF0ZS5ub3coKSArIGR1cmF0aW9uXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldDogZ2V0LFxuICBzZXQ6IHNldFxufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xudmFyIGlkYiA9IHJlcXVpcmUoJy4vc3RvcmVzL2lkYicpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXInKTtcbnZhciBpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3InKTtcbnZhciBkZWZhdWx0cyA9IDE1O1xudmFyIGJhc2VsaW5lO1xuXG5mdW5jdGlvbiBlICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIHNldHVwIChkdXJhdGlvbiwgcm91dGUpIHtcbiAgYmFzZWxpbmUgPSBwYXJzZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgaWYgKGJhc2VsaW5lIDwgMSkge1xuICAgIHN0YXRlLmNhY2hlID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIGludGVyY2VwdG9yLmFkZChpbnRlcmNlcHQpO1xuICBlbWl0dGVyLm9uKCdmZXRjaC5kb25lJywgcGVyc2lzdCk7XG4gIHN0YXRlLmNhY2hlID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0IChlKSB7XG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tjYWNoZV0gYXR0ZW1wdGluZyB0byBpbnRlcmNlcHQgJXMnLCBlLnJvdXRlLnVybCk7XG4gIGNhY2hlLmdldCgnbW9kZWxzJywgZS5yb3V0ZS5wYXJ0cy5wYXRoLCByZXN1bHQpO1xuXG4gIGZ1bmN0aW9uIHJlc3VsdCAoZXJyLCBkYXRhKSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2NhY2hlXSBpbnRlcmNlcHRpb24gZm9yICVzICVzJywgZS5yb3V0ZS51cmwsIGVyciB8fCAhZGF0YSA/ICdmYWlsZWQnIDogJ3N1Y2NlZWRlZCcpO1xuICAgIGlmICghZXJyICYmIGRhdGEpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoZGF0YSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRHVyYXRpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBiYXNlbGluZSB8fCBkZWZhdWx0cztcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gcGVyc2lzdCAocm91dGUsIGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFzdGF0ZS5jYWNoZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocm91dGUuY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkID0gYmFzZWxpbmU7XG4gIGlmICh0eXBlb2Ygcm91dGUuY2FjaGUgPT09ICdudW1iZXInKSB7XG4gICAgZCA9IHJvdXRlLmNhY2hlO1xuICB9XG4gIHZhciB0YXJnZXQgPSBjb250ZXh0LmhpamFja2VyIHx8IHJvdXRlLmFjdGlvbjtcbiAgdmFyIGZyZXNobmVzcyA9IHBhcnNlRHVyYXRpb24oZCkgKiAxMDAwO1xuICBpZiAoJ21vZGVsJyBpbiBkYXRhKSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2NhY2hlXSBzYXZpbmcgbW9kZWwgZm9yICVzJywgcm91dGUucGFydHMucGF0aCk7XG4gICAgY2FjaGUuc2V0KCdtb2RlbHMnLCByb3V0ZS5wYXJ0cy5wYXRoLCBkYXRhLm1vZGVsLCBmcmVzaG5lc3MpO1xuICB9XG4gIGlmICgndGVtcGxhdGUnIGluIGRhdGEpIHtcbiAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbY2FjaGVdIHNhdmluZyB0ZW1wbGF0ZSBmb3IgJXMnLCB0YXJnZXQpO1xuICAgIGNhY2hlLnNldCgndGVtcGxhdGVzJywgdGFyZ2V0LCBkYXRhLnRlbXBsYXRlLCBJbmZpbml0eSk7XG4gIH1cbiAgaWYgKCdjb250cm9sbGVyJyBpbiBkYXRhKSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2NhY2hlXSBzYXZpbmcgY29udHJvbGxlciBmb3IgJXMnLCB0YXJnZXQpO1xuICAgIGNhY2hlLnNldCgnY29udHJvbGxlcnMnLCB0YXJnZXQsIGRhdGEuY29udHJvbGxlciwgSW5maW5pdHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWR5IChmbikge1xuICBpZiAoc3RhdGUuY2FjaGUpIHtcbiAgICBpZGIudGVzdGVkKGZuKTsgLy8gd2FpdCBvbiBpZGIgY29tcGF0aWJpbGl0eSB0ZXN0c1xuICB9IGVsc2Uge1xuICAgIGZuKGZhbHNlKTsgLy8gY2FjaGluZyBpcyBhIG5vLW9wXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldHVwOiBzZXR1cCxcbiAgcGVyc2lzdDogcGVyc2lzdCxcbiAgcmVhZHk6IHJlYWR5XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcbnZhciBjYWNoaW5nID0gcmVxdWlyZSgnLi9jYWNoaW5nJyk7XG52YXIgdW5zdHJpY3RFdmFsID0gcmVxdWlyZSgnLi91bnN0cmljdEV2YWwnKTtcbnZhciBpZGIgPSByZXF1aXJlKCcuL3N0b3Jlcy9pZGInKTtcbnZhciBkZWZlcnJlZCA9IHJlcXVpcmUoJy4uL2xpYi9kZWZlcnJlZCcpO1xuXG5mdW5jdGlvbiBzZXQgKGFjdGlvbiwgZGF0YSkge1xuICBzdG9yZSgndGVtcGxhdGUnKTtcbiAgc3RvcmUoJ2NvbnRyb2xsZXInKTtcblxuICBmdW5jdGlvbiBzdG9yZSAoa2V5KSB7XG4gICAgdmFyIHR5cGUgPSBrZXkgKyAncyc7XG5cbiAgICBpZiAoa2V5IGluIGRhdGEpIHtcbiAgICAgIHB1c2godHlwZSwgYWN0aW9uLCBkYXRhW2tleV0sIGRhdGEudmVyc2lvbik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmlsbCAoKSB7XG4gIGNhY2hpbmcucmVhZHkocHVsbENvbXBvbmVudHMpO1xufVxuXG5mdW5jdGlvbiBwdWxsQ29tcG9uZW50cyAoZW5hYmxlZCkge1xuICBpZiAoIWVuYWJsZWQpIHsgLy8gYmFpbCBpZiBjYWNoaW5nIGlzIHR1cm5lZCBvZmZcbiAgICByZXR1cm47XG4gIH1cbiAgaWRiLmdldCgnY29udHJvbGxlcnMnLCBwdWxsLmJpbmQobnVsbCwgJ2NvbnRyb2xsZXJzJykpO1xuICBpZGIuZ2V0KCd0ZW1wbGF0ZXMnLCBwdWxsLmJpbmQobnVsbCwgJ3RlbXBsYXRlcycpKTtcbn1cblxuZnVuY3Rpb24gcHVsbCAodHlwZSwgZXJyLCBpdGVtcykge1xuICBpZiAoZXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGl0ZW1zLmZvckVhY2gocHVsbEl0ZW0pO1xuXG4gIGZ1bmN0aW9uIHB1bGxJdGVtIChpdGVtKSB7XG4gICAgcHVzaCh0eXBlLCBpdGVtLmtleSwgaXRlbS5kYXRhLCBpdGVtLnZlcnNpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2ggKHR5cGUsIGFjdGlvbiwgdmFsdWUsIHZlcnNpb24pIHtcbiAgdmFyIHNpbmd1bGFyID0gdHlwZS5zdWJzdHIoMCwgdHlwZS5sZW5ndGggLSAxKTtcbiAgdmFyIGlzID0gZGVmZXJyZWQoYWN0aW9uLCBzdGF0ZS5kZWZlcnJhbHMpO1xuICBpZiAoaXMgPT09IGZhbHNlKSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2NvbXBvbmVudENhY2hlXSBhY3Rpb24gXCIlc1wiIGlzIG5vdCBkZWZlcnJlZCwgbm90IHN0b3JpbmcgJXMnLCBhY3Rpb24sIHNpbmd1bGFyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IHN0YXRlLnZlcnNpb24pIHtcbiAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbY29tcG9uZW50Q2FjaGVdIHN0b3JpbmcgJXMgZm9yICVzIGluIHN0YXRlJywgc2luZ3VsYXIsIGFjdGlvbik7XG4gICAgc3RhdGVbdHlwZV1bYWN0aW9uXSA9IHtcbiAgICAgIGZuOiBwYXJzZShzaW5ndWxhciwgdmFsdWUpLFxuICAgICAgdmVyc2lvbjogdmVyc2lvblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2NvbXBvbmVudENhY2hlXSBiYWQgdmVyc2lvbjogJXMgIT09ICVzJywgdmVyc2lvbiwgc3RhdGUudmVyc2lvbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2UgKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdW5zdHJpY3RFdmFsKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbY29tcG9uZW50Q2FjaGVdICVzIGV2YWwgZmFpbGVkJywgdHlwZSwgZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgcmVmaWxsOiByZWZpbGxcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG52YXIgZGVmZXJyZWQgPSByZXF1aXJlKCcuLi9saWIvZGVmZXJyZWQnKTtcblxuZnVuY3Rpb24gbmVlZHMgKGFjdGlvbikge1xuICB2YXIgZGVtYW5kcyA9IFtdO1xuICB2YXIgaXMgPSBkZWZlcnJlZChhY3Rpb24sIHN0YXRlLmRlZmVycmFscyk7XG4gIGlmIChpcykge1xuICAgIGlmIChpbnZhbGlkKCd0ZW1wbGF0ZXMnKSkge1xuICAgICAgZGVtYW5kcy5wdXNoKCd0ZW1wbGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZCgnY29udHJvbGxlcnMnKSkge1xuICAgICAgZGVtYW5kcy5wdXNoKCdjb250cm9sbGVyJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZCAodHlwZSkge1xuICAgIHZhciBzdG9yZSA9IHN0YXRlW3R5cGVdO1xuICAgIHZhciBmYWlsID0gIXN0b3JlW2FjdGlvbl0gfHwgc3RvcmVbYWN0aW9uXS52ZXJzaW9uICE9PSBzdGF0ZS52ZXJzaW9uO1xuICAgIGlmIChmYWlsKSB7XG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbZGVmZXJyYWxdIGRlZmVycmVkICVzICVzIG5vdCBmb3VuZCcsIGFjdGlvbiwgdHlwZS5zdWJzdHIoMCwgdHlwZS5sZW5ndGggLSAxKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRlbWFuZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuZWVkczogbmVlZHNcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJ2NvbnRyYS5lbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW1pdHRlcih7fSwgeyB0aHJvd3M6IGZhbHNlIH0pO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhZGQgKGVsZW1lbnQsIHR5cGUsIGZuKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCB3cmFwcGVyRmFjdG9yeShlbGVtZW50LCBmbikpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRbJ29uJyArIHR5cGVdID0gZm47XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcHBlckZhY3RvcnkgKGVsZW1lbnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwcGVyIChvcmlnaW5hbEV2ZW50KSB7XG4gICAgdmFyIGUgPSBvcmlnaW5hbEV2ZW50IHx8IGdsb2JhbC5ldmVudDtcbiAgICBlLnRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBlLnByZXZlbnREZWZhdWx0ICA9IGUucHJldmVudERlZmF1bHQgIHx8IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9O1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9O1xuICAgIGZuLmNhbGwoZWxlbWVudCwgZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGQ6IGFkZFxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB4aHIgPSByZXF1aXJlKCcuL3hocicpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xudmFyIHJvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlcicpO1xudmFyIGRlZmVycmFsID0gcmVxdWlyZSgnLi9kZWZlcnJhbCcpO1xudmFyIGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvcicpO1xudmFyIGNvbXBvbmVudENhY2hlID0gcmVxdWlyZSgnLi9jb21wb25lbnRDYWNoZScpO1xudmFyIGxhc3RYaHIgPSB7fTtcblxuZnVuY3Rpb24gZSAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBuZWdvdGlhdGUgKHJvdXRlLCBjb250ZXh0KSB7XG4gIHZhciBwYXJ0cyA9IHJvdXRlLnBhcnRzO1xuICB2YXIgcXMgPSBlKHBhcnRzLnNlYXJjaCk7XG4gIHZhciBwID0gcXMgPyAnJicgOiAnPyc7XG4gIHZhciB0YXJnZXQgPSBjb250ZXh0LmhpamFja2VyIHx8IHJvdXRlLmFjdGlvbjtcbiAgdmFyIGRlbWFuZHMgPSBbJ2pzb24nXS5jb25jYXQoZGVmZXJyYWwubmVlZHModGFyZ2V0KSk7XG4gIGlmIChjb250ZXh0LmhpamFja2VyICYmIGNvbnRleHQuaGlqYWNrZXIgIT09IHJvdXRlLmFjdGlvbikge1xuICAgIGRlbWFuZHMucHVzaCgnaGlqYWNrZXI9JyArIGNvbnRleHQuaGlqYWNrZXIpO1xuICB9XG4gIHJldHVybiBwYXJ0cy5wYXRobmFtZSArIHFzICsgcCArIGRlbWFuZHMuam9pbignJicpO1xufVxuXG5mdW5jdGlvbiBhYm9ydCAoc291cmNlKSB7XG4gIGlmIChsYXN0WGhyW3NvdXJjZV0pIHtcbiAgICBsYXN0WGhyW3NvdXJjZV0uYWJvcnQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFBlbmRpbmcgKCkge1xuICBPYmplY3Qua2V5cyhsYXN0WGhyKS5mb3JFYWNoKGFib3J0KTtcbiAgbGFzdFhociA9IHt9O1xufVxuXG5mdW5jdGlvbiBmZXRjaGVyIChyb3V0ZSwgY29udGV4dCwgZG9uZSkge1xuICB2YXIgdXJsID0gcm91dGUudXJsO1xuICBpZiAobGFzdFhocltjb250ZXh0LnNvdXJjZV0pIHtcbiAgICBsYXN0WGhyW2NvbnRleHQuc291cmNlXS5hYm9ydCgpO1xuICAgIGxhc3RYaHJbY29udGV4dC5zb3VyY2VdID0gbnVsbDtcbiAgfVxuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tmZXRjaGVyXSByZXF1ZXN0ZWQgJXMnLCByb3V0ZS51cmwpO1xuXG4gIGludGVyY2VwdG9yLmV4ZWN1dGUocm91dGUsIGFmdGVySW50ZXJjZXB0b3JzKTtcblxuICBmdW5jdGlvbiBhZnRlckludGVyY2VwdG9ycyAoZXJyLCByZXN1bHQpIHtcbiAgICBpZiAoIWVyciAmJiByZXN1bHQuZGVmYXVsdFByZXZlbnRlZCAmJiAhY29udGV4dC5oaWphY2tlcikge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2ZldGNoZXJdIHByZXZlbnRlZCAlcyB3aXRoIGRhdGEnLCByb3V0ZS51cmwsIHJlc3VsdC5kYXRhKTtcbiAgICAgIGRvbmUobnVsbCwgcmVzdWx0LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ2ZldGNoLnN0YXJ0Jywgcm91dGUsIGNvbnRleHQpO1xuICAgICAgbGFzdFhocltjb250ZXh0LnNvdXJjZV0gPSB4aHIobmVnb3RpYXRlKHJvdXRlLCBjb250ZXh0KSwgbm90aWZ5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnkgKGVyciwgZGF0YSwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2ZldGNoZXJdIGZhaWxlZCBmb3IgJXMnLCByb3V0ZS51cmwpO1xuICAgICAgaWYgKGVyci5tZXNzYWdlID09PSAnYWJvcnRlZCcpIHtcbiAgICAgICAgZW1pdHRlci5lbWl0KCdmZXRjaC5hYm9ydCcsIHJvdXRlLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXR0ZXIuZW1pdCgnZmV0Y2guZXJyb3InLCByb3V0ZSwgY29udGV4dCwgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2ZldGNoZXJdIHN1Y2NlZWRlZCBmb3IgJXMnLCByb3V0ZS51cmwpO1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS52ZXJzaW9uKSB7XG4gICAgICAgIHN0YXRlLnZlcnNpb24gPSBkYXRhLnZlcnNpb247IC8vIHN5bmMgdmVyc2lvbiBleHBlY3RhdGlvbiB3aXRoIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbXBvbmVudENhY2hlLnNldChyb3V0ZXIocmVzLnVybCkucGFydHMucXVlcnkuaGlqYWNrZXIgfHwgcm91dGUuYWN0aW9uLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGVtaXR0ZXIuZW1pdCgnZmV0Y2guZG9uZScsIHJvdXRlLCBjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgZG9uZShlcnIsIGRhdGEpO1xuICB9XG59XG5cbmZldGNoZXIuYWJvcnRQZW5kaW5nID0gYWJvcnRQZW5kaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoZXI7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2Rlcm4gPSAnaGlzdG9yeScgaW4gZ2xvYmFsICYmICdwdXNoU3RhdGUnIGluIGdsb2JhbC5oaXN0b3J5O1xudmFyIGFwaSA9IG1vZGVybiAmJiBnbG9iYWwuaGlzdG9yeTtcblxuLy8gR29vZ2xlIENocm9tZSAzOCBvbiBpT1MgbWFrZXMgd2VpcmQgY2hhbmdlcyB0byBoaXN0b3J5LnJlcGxhY2VTdGF0ZSwgYnJlYWtpbmcgaXRcbnZhciBuYXRpdmVGbiA9IHJlcXVpcmUoJy4uL25hdGl2ZUZuJyk7XG52YXIgbmF0aXZlUmVwbGFjZUJyb2tlbiA9IG1vZGVybiAmJiAhbmF0aXZlRm4oYXBpLnJlcGxhY2VTdGF0ZSk7XG5pZiAobmF0aXZlUmVwbGFjZUJyb2tlbikge1xuICBhcGkgPSB7XG4gICAgcHVzaFN0YXRlOiBhcGkucHVzaFN0YXRlLmJpbmQoYXBpKVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXInKTtcbnZhciBsaW5rcyA9IHJlcXVpcmUoJy4vbGlua3MnKTtcblxuZnVuY3Rpb24gYXR0YWNoICgpIHtcbiAgZW1pdHRlci5vbignc3RhcnQnLCBsaW5rcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2g6IGF0dGFjaFxufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2luZGV4XSBsb2FkaW5nIHRhdW51cycpO1xuXG5pZiAoZ2xvYmFsLnRhdW51cyAhPT0gdm9pZCAwKSB7XG4gIHRocm93IG5ldyBFcnJvcignVXNlIHJlcXVpcmUoXFwndGF1bnVzL2dsb2JhbFxcJykgYWZ0ZXIgdGhlIGluaXRpYWwgcmVxdWlyZShcXCd0YXVudXNcXCcpIHN0YXRlbWVudCEnKTtcbn1cblxudmFyIHN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xudmFyIHN0YXRlQ2xlYXIgPSByZXF1aXJlKCcuL3N0YXRlQ2xlYXInKTtcbnZhciBpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3InKTtcbnZhciBhY3RpdmF0b3IgPSByZXF1aXJlKCcuL2FjdGl2YXRvcicpO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXInKTtcbnZhciBob29rcyA9IHJlcXVpcmUoJy4vaG9va3MnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG52YXIgbW91bnQgPSByZXF1aXJlKCcuL21vdW50Jyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcbnZhciB4aHIgPSByZXF1aXJlKCcuL3hocicpO1xudmFyIHByZWZldGNoZXIgPSByZXF1aXJlKCcuL3ByZWZldGNoZXInKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZSgnLi4vbGliL3Jlc29sdmUnKTtcblxuc3RhdGUuY2xlYXIgPSBzdGF0ZUNsZWFyO1xuaG9va3MuYXR0YWNoKCk7XG5cbmZ1bmN0aW9uIGJpbmQgKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbWl0dGVyW21ldGhvZF0uYXBwbHkoZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwudGF1bnVzID0ge1xuICBtb3VudDogbW91bnQsXG4gIHBhcnRpYWw6IHZpZXcucGFydGlhbCxcbiAgb246IGJpbmQoJ29uJyksXG4gIG9uY2U6IGJpbmQoJ29uY2UnKSxcbiAgb2ZmOiBiaW5kKCdvZmYnKSxcbiAgaW50ZXJjZXB0OiBpbnRlcmNlcHRvci5hZGQsXG4gIG5hdmlnYXRlOiBhY3RpdmF0b3IuZ28sXG4gIHByZWZldGNoOiBwcmVmZXRjaGVyLnN0YXJ0LFxuICBzdGF0ZTogc3RhdGUsXG4gIHJvdXRlOiByb3V0ZXIsXG4gIHJlc29sdmU6IHJlc29sdmUsXG4gIHhocjogeGhyXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCdjb250cmEuZW1pdHRlcicpO1xudmFyIG9uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcbnZhciByb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpO1xudmFyIGludGVyY2VwdG9ycyA9IGVtaXR0ZXIoeyBjb3VudDogMCB9LCB7IGFzeW5jOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBnZXRJbnRlcmNlcHRvckV2ZW50IChyb3V0ZSkge1xuICB2YXIgZSA9IHtcbiAgICB1cmw6IHJvdXRlLnVybCxcbiAgICByb3V0ZTogcm91dGUsXG4gICAgcGFydHM6IHJvdXRlLnBhcnRzLFxuICAgIGRhdGE6IG51bGwsXG4gICAgY2FuUHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IG9uY2UocHJldmVudERlZmF1bHQpXG4gIH07XG5cbiAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKGRhdGEpIHtcbiAgICBpZiAoIWUuY2FuUHJldmVudERlZmF1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5jYW5QcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgZS5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBhZGQgKGFjdGlvbiwgZm4pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmbiA9IGFjdGlvbjtcbiAgICBhY3Rpb24gPSAnKic7XG4gIH1cbiAgaW50ZXJjZXB0b3JzLmNvdW50Kys7XG4gIGludGVyY2VwdG9ycy5vbihhY3Rpb24sIGZuKTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZSAocm91dGUsIGRvbmUpIHtcbiAgdmFyIGUgPSBnZXRJbnRlcmNlcHRvckV2ZW50KHJvdXRlKTtcbiAgaWYgKGludGVyY2VwdG9ycy5jb3VudCA9PT0gMCkgeyAvLyBmYWlsIGZhc3RcbiAgICBlbmQoKTsgcmV0dXJuO1xuICB9XG4gIHZhciBmbiA9IG9uY2UoZW5kKTtcbiAgdmFyIHByZXZlbnREZWZhdWx0QmFzZSA9IGUucHJldmVudERlZmF1bHQ7XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCA9IG9uY2UocHJldmVudERlZmF1bHRFbmRzKTtcblxuICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbaW50ZXJjZXB0b3JdIGV4ZWN1dGluZyBmb3IgJXMnLCByb3V0ZS51cmwpO1xuXG4gIGludGVyY2VwdG9ycy5lbWl0KCcqJywgZSk7XG4gIGludGVyY2VwdG9ycy5lbWl0KHJvdXRlLmFjdGlvbiwgZSk7XG5cbiAgc2V0VGltZW91dChmbiwgNTApOyAvLyBhdCB3b3JzdCwgc3BlbmQgNTBtcyB3YWl0aW5nIG9uIGludGVyY2VwdG9yc1xuXG4gIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0RW5kcyAoKSB7XG4gICAgcHJldmVudERlZmF1bHRCYXNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2ludGVyY2VwdG9yXSAlcyBmb3IgJXMnLCBpbnRlcmNlcHRvcnMuY291bnQgPT09IDAgJiYgJ3NraXBwZWQnIHx8IGUuZGVmYXVsdFByZXZlbnRlZCAmJiAncHJldmVudGVkJyB8fCAndGltZWQgb3V0Jywgcm91dGUudXJsKTtcbiAgICBlLmNhblByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgZG9uZShudWxsLCBlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGQsXG4gIGV4ZWN1dGU6IGV4ZWN1dGVcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xudmFyIHByZWZldGNoZXIgPSByZXF1aXJlKCcuL3ByZWZldGNoZXInKTtcbnZhciBhY3RpdmF0b3IgPSByZXF1aXJlKCcuL2FjdGl2YXRvcicpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9nbG9iYWwvZG9jdW1lbnQnKTtcbnZhciBvcmlnaW4gPSBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW47XG52YXIgbGVmdENsaWNrID0gMTtcbnZhciBwcmVmZXRjaGluZyA9IFtdO1xudmFyIGNsaWNrc09uSG9sZCA9IFtdO1xuXG5mdW5jdGlvbiBsaW5rcyAoKSB7XG4gIGlmIChzdGF0ZS5wcmVmZXRjaCAmJiBzdGF0ZS5jYWNoZSkgeyAvLyBwcmVmZXRjaCB3aXRob3V0IGNhY2hlIG1ha2VzIG5vIHNlbnNlXG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2xpbmtzXSBsaXN0ZW5pbmcgZm9yIHByZWZldGNoaW5nIG9wcG9ydHVuaXRpZXMnKTtcbiAgICBldmVudHMuYWRkKGRvY3VtZW50LmJvZHksICdtb3VzZW92ZXInLCBtYXliZVByZWZldGNoKTtcbiAgICBldmVudHMuYWRkKGRvY3VtZW50LmJvZHksICd0b3VjaHN0YXJ0JywgbWF5YmVQcmVmZXRjaCk7XG4gIH1cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2xpbmtzXSBsaXN0ZW5pbmcgZm9yIHJlcm91dGluZyBvcHBvcnR1bml0aWVzJyk7XG4gIGV2ZW50cy5hZGQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJywgbWF5YmVSZXJvdXRlKTtcbn1cblxuZnVuY3Rpb24gc28gKGFuY2hvcikge1xuICByZXR1cm4gYW5jaG9yLm9yaWdpbiA9PT0gb3JpZ2luO1xufVxuXG5mdW5jdGlvbiBsZWZ0Q2xpY2tPbkFuY2hvciAoZSwgYW5jaG9yKSB7XG4gIHJldHVybiBhbmNob3IucGF0aG5hbWUgJiYgZS53aGljaCA9PT0gbGVmdENsaWNrICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleTtcbn1cblxuZnVuY3Rpb24gdGFyZ2V0T3JBbmNob3IgKGUpIHtcbiAgdmFyIGFuY2hvciA9IGUudGFyZ2V0O1xuICB3aGlsZSAoYW5jaG9yKSB7XG4gICAgaWYgKGFuY2hvci50YWdOYW1lID09PSAnQScpIHtcbiAgICAgIHJldHVybiBhbmNob3I7XG4gICAgfVxuICAgIGFuY2hvciA9IGFuY2hvci5wYXJlbnRFbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVyb3V0ZSAoZSkge1xuICB2YXIgYW5jaG9yID0gdGFyZ2V0T3JBbmNob3IoZSk7XG4gIGlmIChhbmNob3IgJiYgc28oYW5jaG9yKSAmJiBsZWZ0Q2xpY2tPbkFuY2hvcihlLCBhbmNob3IpKSB7XG4gICAgcmVyb3V0ZShlLCBhbmNob3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUHJlZmV0Y2ggKGUpIHtcbiAgdmFyIGFuY2hvciA9IHRhcmdldE9yQW5jaG9yKGUpO1xuICBpZiAoYW5jaG9yICYmIHNvKGFuY2hvcikpIHtcbiAgICBwcmVmZXRjaChlLCBhbmNob3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcGFyc2UgKGFuY2hvcikge1xuICByZXR1cm4gYW5jaG9yLnBhdGhuYW1lICsgYW5jaG9yLnNlYXJjaCArIGFuY2hvci5oYXNoO1xufVxuXG5mdW5jdGlvbiByZXJvdXRlIChlLCBhbmNob3IpIHtcbiAgdmFyIHVybCA9IHBhcnNlKGFuY2hvcik7XG4gIHZhciByb3V0ZSA9IHJvdXRlcih1cmwpO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJldmVudCgpO1xuXG4gIGlmIChwcmVmZXRjaGVyLmJ1c3kodXJsKSkge1xuICAgIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tsaW5rc10gbmF2aWdhdGlvbiB0byAlcyBibG9ja2VkIGJ5IHByZWZldGNoZXInLCByb3V0ZS51cmwpO1xuICAgIHByZWZldGNoZXIucmVnaXN0ZXJJbnRlbnQodXJsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbbGlua3NdIG5hdmlnYXRpbmcgdG8gJXMnLCByb3V0ZS51cmwpO1xuICBhY3RpdmF0b3IuZ28ocm91dGUudXJsLCB7IGNvbnRleHQ6IGFuY2hvciB9KTtcblxuICBmdW5jdGlvbiBwcmV2ZW50ICgpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG59XG5cbmZ1bmN0aW9uIHByZWZldGNoIChlLCBhbmNob3IpIHtcbiAgcHJlZmV0Y2hlci5zdGFydChwYXJzZShhbmNob3IpLCBhbmNob3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmtzO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVuZXNjYXBlID0gcmVxdWlyZSgnLi91bmVzY2FwZScpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xudmFyIHJvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XG52YXIgYWN0aXZhdG9yID0gcmVxdWlyZSgnLi9hY3RpdmF0b3InKTtcbnZhciBjYWNoaW5nID0gcmVxdWlyZSgnLi9jYWNoaW5nJyk7XG52YXIgY29tcG9uZW50Q2FjaGUgPSByZXF1aXJlKCcuL2NvbXBvbmVudENhY2hlJyk7XG52YXIgZmV0Y2hlciA9IHJlcXVpcmUoJy4vZmV0Y2hlcicpO1xudmFyIHZlcnNpb25pbmcgPSByZXF1aXJlKCcuLi92ZXJzaW9uaW5nJyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL2dsb2JhbC9kb2N1bWVudCcpO1xudmFyIGxvY2F0aW9uID0gcmVxdWlyZSgnLi9nbG9iYWwvbG9jYXRpb24nKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZSgnLi4vbGliL3Jlc29sdmUnKTtcbnZhciBnID0gZ2xvYmFsO1xudmFyIG1vdW50ZWQ7XG52YXIgYm9vdGVkO1xuXG5mdW5jdGlvbiBvckVtcHR5ICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIG1vdW50IChjb250YWluZXIsIHdpcmluZywgb3B0aW9ucykge1xuICB2YXIgbyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChtb3VudGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXVudXMgYWxyZWFkeSBtb3VudGVkIScpO1xuICB9XG4gIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSkgeyAvLyBuYcOvdmUgaXMgZW5vdWdoXG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgYW4gYXBwbGljYXRpb24gcm9vdCBjb250YWluZXIhJyk7XG4gIH1cbiAgaWYgKCFvLmJvb3RzdHJhcCkgeyBvLmJvb3RzdHJhcCA9ICdhdXRvJzsgfVxuXG4gIG1vdW50ZWQgPSB0cnVlO1xuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1ttb3VudF0gbW91bnRwb2ludCBpbnZva2VkIHVzaW5nIFwiJXNcIiBzdHJhdGVneScsIG8uYm9vdHN0cmFwKTtcblxuICBzdGF0ZS5jb250YWluZXIgPSBjb250YWluZXI7XG4gIHN0YXRlLmNvbnRyb2xsZXJzID0gd2lyaW5nLmNvbnRyb2xsZXJzO1xuICBzdGF0ZS50ZW1wbGF0ZXMgPSB3aXJpbmcudGVtcGxhdGVzO1xuICBzdGF0ZS5yb3V0ZXMgPSB3aXJpbmcucm91dGVzO1xuICBzdGF0ZS5kZWZlcnJhbHMgPSB3aXJpbmcuZGVmZXJyYWxzIHx8IFtdO1xuICBzdGF0ZS5wcmVmZXRjaCA9ICEhby5wcmVmZXRjaDtcbiAgc3RhdGUudmVyc2lvbiA9IHZlcnNpb25pbmcuZ2V0KG8udmVyc2lvbiB8fCAnMScpO1xuXG4gIHJlc29sdmUuc2V0KHN0YXRlLnJvdXRlcyk7XG4gIHJvdXRlci5zZXR1cChzdGF0ZS5yb3V0ZXMpO1xuXG4gIHZhciB1cmwgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgdmFyIHF1ZXJ5ID0gb3JFbXB0eShsb2NhdGlvbi5zZWFyY2gpICsgb3JFbXB0eShsb2NhdGlvbi5oYXNoKTtcbiAgdmFyIHJvdXRlID0gcm91dGVyKHVybCArIHF1ZXJ5KTtcblxuICBjYWNoaW5nLnNldHVwKG8uY2FjaGUsIHJvdXRlKTtcbiAgY2FjaGluZy5yZWFkeShraWNrc3RhcnQpO1xuICBjb21wb25lbnRDYWNoZS5yZWZpbGwoKTtcblxuICBmdW5jdGlvbiBraWNrc3RhcnQgKCkge1xuICAgIGlmIChvLmJvb3RzdHJhcCA9PT0gJ2F1dG8nKSB7XG4gICAgICBhdXRvYm9vdCgpO1xuICAgIH0gZWxzZSBpZiAoby5ib290c3RyYXAgPT09ICdpbmxpbmUnKSB7XG4gICAgICBpbmxpbmVib290KCk7XG4gICAgfSBlbHNlIGlmIChvLmJvb3RzdHJhcCA9PT0gJ21hbnVhbCcpIHtcbiAgICAgIG1hbnVhbGJvb3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG8uYm9vdHN0cmFwICsgJyBpcyBub3QgYSB2YWxpZCBib290c3RyYXAgbW9kZSEnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdXRvYm9vdCAoKSB7XG4gICAgZmV0Y2hlcihyb3V0ZSwgeyBlbGVtZW50OiBjb250YWluZXIsIHNvdXJjZTogJ2Jvb3QnIH0sIGZldGNoZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hlZCAoZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZXRjaGluZyBKU09OIGRhdGEgbW9kZWwgZmFpbGVkIGF0IG1vdW50cG9pbnQuJyk7XG4gICAgfVxuICAgIGJvb3QoZGF0YSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmxpbmVib290ICgpIHtcbiAgICB2YXIgaWQgPSBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdkYXRhLXRhdW51cycpO1xuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHVuZXNjYXBlKHNjcmlwdC5pbm5lclRleHQgfHwgc2NyaXB0LnRleHRDb250ZW50KSk7XG4gICAgYm9vdChkYXRhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hbnVhbGJvb3QgKCkge1xuICAgIGlmICh0eXBlb2YgZy50YXVudXNSZWFkeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZy50YXVudXNSZWFkeSA9IGJvb3Q7IC8vIG5vdCB5ZXQgYW4gb2JqZWN0PyB0dXJuIGl0IGludG8gdGhlIGJvb3QgbWV0aG9kXG4gICAgfSBlbHNlIGlmIChnLnRhdW51c1JlYWR5ICYmIHR5cGVvZiBnLnRhdW51c1JlYWR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgYm9vdChnLnRhdW51c1JlYWR5KTsgLy8gYWxyZWFkeSBhbiBvYmplY3Q/IGJvb3Qgd2l0aCB0aGF0IGFzIHRoZSBkYXRhIG9iamVjdFxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgdGF1bnVzUmVhZHkgZ2xvYmFsPycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJvb3QgKGRhdGEpIHtcbiAgICBpZiAoYm9vdGVkKSB7IC8vIHNhbml0eVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1ttb3VudF0gbW91bnRwb2ludCBib290ZWQgd2l0aCBkYXRhJywgZGF0YSk7XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGF1bnVzIGRhdGEgaXMgcmVxdWlyZWQhIEJvb3QgZmFpbGVkJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS52ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb24gZGF0YSBpcyBtaXNzaW5nISBCb290IGZhaWxlZCcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubW9kZWwgfHwgdHlwZW9mIGRhdGEubW9kZWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhdW51cyBtb2RlbCBtdXN0IGJlIGFuIG9iamVjdCEgQm9vdCBmYWlsZWQnKTtcbiAgICB9XG4gICAgYm9vdGVkID0gdHJ1ZTtcbiAgICBjYWNoaW5nLnBlcnNpc3Qocm91dGUsIHN0YXRlLmNvbnRhaW5lciwgZGF0YSk7XG4gICAgYWN0aXZhdG9yLnN0YXJ0KGRhdGEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW91bnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2pkYWx0b24vNWUzNGQ4OTAxMDVhY2E0NDM5OWZcbi8vIHRoYW5rcyBAamRhbHRvbiFcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsgLy8gdXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBgW1tDbGFzc11dYCBvZiB2YWx1ZXNcbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nOyAvLyB1c2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9uc1xudmFyIGhvc3QgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvOyAvLyB1c2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNDsgcmVhbGx5IHR5cGVkIGFycmF5IHNwZWNpZmljKVxuXG4vLyBFc2NhcGUgYW55IHNwZWNpYWwgcmVnZXhwIGNoYXJhY3RlcnMuXG52YXIgc3BlY2lhbHMgPSAvWy4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbi8vIFJlcGxhY2UgbWVudGlvbnMgb2YgYHRvU3RyaW5nYCB3aXRoIGAuKj9gIHRvIGtlZXAgdGhlIHRlbXBsYXRlIGdlbmVyaWMuXG4vLyBSZXBsYWNlIHRoaW5nIGxpa2UgYGZvciAuLi5gIHRvIHN1cHBvcnQgZW52aXJvbm1lbnRzLCBsaWtlIFJoaW5vLCB3aGljaCBhZGQgZXh0cmFcbi8vIGluZm8gc3VjaCBhcyBtZXRob2QgYXJpdHkuXG52YXIgZXh0cmFzID0gL3RvU3RyaW5nfChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2c7XG5cbi8vIENvbXBpbGUgYSByZWdleHAgdXNpbmcgYSBjb21tb24gbmF0aXZlIG1ldGhvZCBhcyBhIHRlbXBsYXRlLlxuLy8gV2UgY2hvc2UgYE9iamVjdCN0b1N0cmluZ2AgYmVjYXVzZSB0aGVyZSdzIGEgZ29vZCBjaGFuY2UgaXQgaXMgbm90IGJlaW5nIG11Y2tlZCB3aXRoLlxudmFyIGZuU3RyaW5nID0gU3RyaW5nKHRvU3RyaW5nKS5yZXBsYWNlKHNwZWNpYWxzLCAnXFxcXCQmJykucmVwbGFjZShleHRyYXMsICckMS4qPycpO1xudmFyIHJlTmF0aXZlID0gbmV3IFJlZ0V4cCgnXicgKyBmblN0cmluZyArICckJyk7XG5cbmZ1bmN0aW9uIG5hdGl2ZUZuICh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYEZ1bmN0aW9uI3RvU3RyaW5nYCB0byBieXBhc3MgdGhlIHZhbHVlJ3Mgb3duIGB0b1N0cmluZ2AgbWV0aG9kXG4gICAgLy8gYW5kIGF2b2lkIGJlaW5nIGZha2VkIG91dC5cbiAgICByZXR1cm4gcmVOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGEgaG9zdCBvYmplY3QgY2hlY2sgYmVjYXVzZSBzb21lIGVudmlyb25tZW50cyB3aWxsIHJlcHJlc2VudFxuICAvLyB0aGluZ3MgbGlrZSB0eXBlZCBhcnJheXMgYXMgRE9NIG1ldGhvZHMgd2hpY2ggbWF5IG5vdCBjb25mb3JtIHRvIHRoZVxuICAvLyBub3JtYWwgbmF0aXZlIHBhdHRlcm4uXG4gIHJldHVybiAodmFsdWUgJiYgdHlwZSA9PT0gJ29iamVjdCcgJiYgaG9zdC50ZXN0KHRvU3RyaW5nLmNhbGwodmFsdWUpKSkgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlRm47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcG9zYWJsZSAoZm4pIHtcbiAgdmFyIHVzZWQ7XG4gIHZhciByZXN1bHQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlICgpIHtcbiAgICBpZiAodXNlZCkgeyByZXR1cm4gcmVzdWx0OyB9IHVzZWQgPSB0cnVlO1xuICAgIHJldHVybiAocmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcbnZhciBmZXRjaGVyID0gcmVxdWlyZSgnLi9mZXRjaGVyJyk7XG52YXIgYWN0aXZhdG9yID0gcmVxdWlyZSgnLi9hY3RpdmF0b3InKTtcbnZhciBqb2JzID0gW107XG52YXIgaW50ZW50O1xuXG5mdW5jdGlvbiBidXN5ICh1cmwpIHtcbiAgcmV0dXJuIGpvYnMuaW5kZXhPZih1cmwpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRlbnQgKHVybCkge1xuICBpbnRlbnQgPSB1cmw7XG59XG5cbmZ1bmN0aW9uIGFib3J0SW50ZW50ICh1cmwpIHtcbiAgaW50ZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc3RhcnQgKHVybCwgZWxlbWVudCkge1xuICBpZiAoc3RhdGUuY2FjaGUgIT09IHRydWUpIHsgLy8gY2FuJ3QgcHJlZmV0Y2ggaWYgY2FjaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW50ZW50KSB7IC8vIGRvbid0IHByZWZldGNoIGlmIHRoZSBodW1hbiB3YW50cyB0byBuYXZpZ2F0ZTogaXQnZCBhYm9ydCB0aGUgcHJldmlvdXMgYXR0ZW1wdFxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcm91dGUgPSByb3V0ZXIodXJsKTtcbiAgaWYgKHJvdXRlID09PSBudWxsKSB7IC8vIG9ubHkgcHJlZmV0Y2ggdGF1bnVzIHZpZXcgcm91dGVzXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChidXN5KHVybCkpIHsgLy8gYWxyZWFkeSBwcmVmZXRjaGluZyB0aGlzIHVybFxuICAgIHJldHVybjtcbiAgfVxuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1twcmVmZXRjaGVyXSBwcmVmZXRjaGluZyAlcycsIHJvdXRlLnVybCk7XG4gIGpvYnMucHVzaCh1cmwpO1xuICBmZXRjaGVyKHJvdXRlLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIHNvdXJjZTogJ3ByZWZldGNoJyB9LCBmZXRjaGVkKTtcblxuICBmdW5jdGlvbiBmZXRjaGVkICgpIHtcbiAgICBqb2JzLnNwbGljZShqb2JzLmluZGV4T2YodXJsKSwgMSk7XG4gICAgaWYgKGludGVudCA9PT0gdXJsKSB7XG4gICAgICBpbnRlbnQgPSBudWxsO1xuXG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbcHJlZmV0Y2hlcl0gcmVzdW1lZCBuYXZpZ2F0aW9uIGZvciAlcycsIHJvdXRlLnVybCk7XG4gICAgICBhY3RpdmF0b3IuZ28ocm91dGUudXJsLCB7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidXN5OiBidXN5LFxuICBzdGFydDogc3RhcnQsXG4gIHJlZ2lzdGVySW50ZW50OiByZWdpc3RlckludGVudCxcbiAgYWJvcnRJbnRlbnQ6IGFib3J0SW50ZW50XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybCA9IHJlcXVpcmUoJ2Zhc3QtdXJsLXBhcnNlcicpO1xudmFyIHJ1dGEzID0gcmVxdWlyZSgncnV0YTMnKTtcbnZhciBsb2NhdGlvbiA9IHJlcXVpcmUoJy4vZ2xvYmFsL2xvY2F0aW9uJyk7XG52YXIgbWF0Y2hlciA9IHJ1dGEzKCk7XG52YXIgcHJvdG9jb2wgPSAvXlthLXpdKz86XFwvXFwvL2k7XG5cbmZ1bmN0aW9uIGdldEZ1bGxVcmwgKHJhdykge1xuICB2YXIgYmFzZSA9IGxvY2F0aW9uLmhyZWYuc3Vic3RyKGxvY2F0aW9uLm9yaWdpbi5sZW5ndGgpO1xuICB2YXIgaGFzaGxlc3M7XG4gIGlmICghcmF3KSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKHJhd1swXSA9PT0gJyMnKSB7XG4gICAgaGFzaGxlc3MgPSBiYXNlLnN1YnN0cigwLCBiYXNlLmxlbmd0aCAtIGxvY2F0aW9uLmhhc2gubGVuZ3RoKTtcbiAgICByZXR1cm4gaGFzaGxlc3MgKyByYXc7XG4gIH1cbiAgaWYgKHByb3RvY29sLnRlc3QocmF3KSkge1xuICAgIGlmIChyYXcuaW5kZXhPZihsb2NhdGlvbi5vcmlnaW4pID09PSAwKSB7XG4gICAgICByZXR1cm4gcmF3LnN1YnN0cihsb2NhdGlvbi5vcmlnaW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cblxuZnVuY3Rpb24gcm91dGVyIChyYXcsIHN0YXJ0SW5kZXgpIHtcbiAgdmFyIGZ1bGwgPSBnZXRGdWxsVXJsKHJhdyk7XG4gIGlmIChmdWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhcnRzID0gdXJsLnBhcnNlKGZ1bGwsIHRydWUpO1xuICB2YXIgaW5mbyA9IG1hdGNoZXIubWF0Y2gocGFydHMucGF0aG5hbWUsIHN0YXJ0SW5kZXgpO1xuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tyb3V0ZXJdICVzIHByb2R1Y2VzICVvJywgcmF3LCBpbmZvKTtcblxuICB2YXIgcm91dGUgPSBpbmZvID8gbWVyZ2UoaW5mbykgOiBudWxsO1xuICBpZiAocm91dGUgPT09IG51bGwgfHwgcm91dGUuaWdub3JlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb3V0ZS51cmwgPSBmdWxsO1xuICByb3V0ZS5wYXJ0cyA9IHBhcnRzO1xuXG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tyb3V0ZXJdICVzIHlpZWxkcyAlcycsIHJhdywgcm91dGUucm91dGUpO1xuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UgKGluZm8pIHtcbiAgdmFyIHJvdXRlID0gT2JqZWN0LmtleXMoaW5mby5hY3Rpb24pLnJlZHVjZShjb3B5T3Zlciwge1xuICAgIHBhcmFtczogaW5mby5wYXJhbXNcbiAgfSk7XG4gIGluZm8ucGFyYW1zLmFyZ3MgPSBpbmZvLnNwbGF0cztcblxuICByZXR1cm4gcm91dGU7XG5cbiAgZnVuY3Rpb24gY29weU92ZXIgKHJvdXRlLCBrZXkpIHtcbiAgICByb3V0ZVtrZXldID0gaW5mby5hY3Rpb25ba2V5XTsgcmV0dXJuIHJvdXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwIChkZWZpbml0aW9ucykge1xuICBkZWZpbml0aW9ucy5mb3JFYWNoKGRlZmluZSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZSAoZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIGRlZmluaXRpb24uYWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIGRlZmluaXRpb24uYWN0aW9uID0gbnVsbDtcbiAgfVxuICBtYXRjaGVyLmFkZFJvdXRlKGRlZmluaXRpb24ucm91dGUsIGRlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMgKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiAoXG4gICAgbGVmdCAmJiByaWdodCAmJlxuICAgIGxlZnQucm91dGUgPT09IHJpZ2h0LnJvdXRlICYmXG4gICAgSlNPTi5zdHJpbmdpZnkobGVmdC5wYXJhbXMpID09PSBKU09OLnN0cmluZ2lmeShyaWdodC5wYXJhbXMpXG4gICk7XG59XG5cbnJvdXRlci5zZXR1cCA9IHNldHVwO1xucm91dGVyLmVxdWFscyA9IGVxdWFscztcblxubW9kdWxlLmV4cG9ydHMgPSByb3V0ZXI7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGFpbmVyOiBudWxsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG52YXIgcmF3ID0gcmVxdWlyZSgnLi9zdG9yZXMvcmF3Jyk7XG52YXIgaWRiID0gcmVxdWlyZSgnLi9zdG9yZXMvaWRiJyk7XG5cbmZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgcmF3LmNsZWFyKCk7XG4gIGlkYi5jbGVhcignbW9kZWxzJyk7XG4gIGlkYi5jbGVhcignY29udHJvbGxlcnMnKTtcbiAgaWRiLmNsZWFyKCd0ZW1wbGF0ZXMnKTtcbiAgY2xlYXJTdG9yZSgnY29udHJvbGxlcnMnKTtcbiAgY2xlYXJTdG9yZSgndGVtcGxhdGVzJyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RvcmUgKHR5cGUpIHtcbiAgdmFyIHN0b3JlID0gc3RhdGVbdHlwZV07XG4gIE9iamVjdC5rZXlzKHN0b3JlKS5maWx0ZXIobykuZm9yRWFjaChybSk7XG5cbiAgZnVuY3Rpb24gbyAoYWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0b3JlW2FjdGlvbl0gJiYgdHlwZW9mIHN0b3JlW2FjdGlvbl0gPT09ICdvYmplY3QnO1xuICB9XG4gIGZ1bmN0aW9uIHJtIChhY3Rpb24pIHtcbiAgICBkZWxldGUgc3RvcmVbYWN0aW9uXTtcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xlYXI7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhcGkgPSB7fTtcbnZhciBpZGIgPSByZXF1aXJlKCcuL3VuZGVybHlpbmdfaWRiJyk7XG52YXIgc3VwcG9ydHM7XG52YXIgZGI7XG52YXIgZGJWZXJzaW9uID0gMztcbnZhciBkYk5hbWUgPSAndGF1bnVzJztcbnZhciBrZXlQYXRoID0gJ2tleSc7XG52YXIgc2V0UXVldWUgPSBbXTtcbnZhciB0ZXN0ZWRRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIHRlc3QgKCkge1xuICB2YXIga2V5ID0gJ2luZGV4ZWQtZGItZmVhdHVyZS1kZXRlY3Rpb24nO1xuICB2YXIgcmVxO1xuICB2YXIgZGI7XG5cbiAgaWYgKCFpZGIgfHwgISgnZGVsZXRlRGF0YWJhc2UnIGluIGlkYikpIHtcbiAgICBzdXBwb3J0KGZhbHNlKTsgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZGIuZGVsZXRlRGF0YWJhc2Uoa2V5KS5vbnN1Y2Nlc3MgPSB0cmFuc2FjdGlvbmFsVGVzdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHN1cHBvcnQoZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb25hbFRlc3QgKCkge1xuICAgIHJlcSA9IGlkYi5vcGVuKGtleSwgMSk7XG4gICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHVwZ25lZWRlZDtcbiAgICByZXEub25lcnJvciA9IGVycm9yO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzO1xuXG4gICAgZnVuY3Rpb24gdXBnbmVlZGVkICgpIHtcbiAgICAgIHJlcS5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUoJ3N0b3JlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyAoKSB7XG4gICAgICBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICBkYi50cmFuc2FjdGlvbignc3RvcmUnLCAncmVhZHdyaXRlJykub2JqZWN0U3RvcmUoJ3N0b3JlJykuYWRkKG5ldyBnbG9iYWwuQmxvYigpLCAna2V5Jyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN1cHBvcnQoZmFsc2UpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgaWRiLmRlbGV0ZURhdGFiYXNlKGtleSk7XG4gICAgICAgIGlmIChzdXBwb3J0cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvciAoKSB7XG4gICAgICBzdXBwb3J0KGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb3BlbiAoKSB7XG4gIHZhciByZXEgPSBpZGIub3BlbihkYk5hbWUsIGRiVmVyc2lvbik7XG4gIHJlcS5vbmVycm9yID0gZXJyb3I7XG4gIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSB1cGduZWVkZWQ7XG4gIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzO1xuXG4gIGZ1bmN0aW9uIHVwZ25lZWRlZCAoZSkge1xuICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgdmFyIHYgPSBlLm9sZFZlcnNpb247XG4gICAgaWYgKHYgPT09IDEpIHtcbiAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCd3aWxkc3RvcmUnKTtcbiAgICB9XG4gICAgaWYgKHYgPCAyKSB7XG4gICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnbW9kZWxzJywgeyBrZXlQYXRoOiBrZXlQYXRoIH0pO1xuICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3RlbXBsYXRlcycsIHsga2V5UGF0aDoga2V5UGF0aCB9KTtcbiAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdjb250cm9sbGVycycsIHsga2V5UGF0aDoga2V5UGF0aCB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdWNjZXNzICgpIHtcbiAgICBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgYXBpLm5hbWUgPSAnSW5kZXhlZERCJztcbiAgICBhcGkuZ2V0ID0gZ2V0O1xuICAgIGFwaS5zZXQgPSBzZXQ7XG4gICAgYXBpLmNsZWFyID0gY2xlYXI7XG4gICAgc3VwcG9ydCh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yICgpIHtcbiAgICBzdXBwb3J0KGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWxsYmFjayAoKSB7XG4gIGFwaS5uYW1lID0gJ0luZGV4ZWREQi1mYWxsYmFja1N0b3JlJztcbiAgYXBpLmdldCA9IHVuZGVmaW5lZEdldDtcbiAgYXBpLnNldCA9IGVucXVldWVTZXQ7XG4gIGFwaS5jbGVhciA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHVuZGVmaW5lZEdldCAoc3RvcmUsIGtleSwgZG9uZSkge1xuICAoZG9uZSB8fCBrZXkpKG51bGwsIGRvbmUgPyBudWxsIDogW10pO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlU2V0IChzdG9yZSwga2V5LCAgdmFsdWUsIGRvbmUpIHtcbiAgaWYgKHN1cHBvcnRzID09PSBmYWxzZSkge1xuICAgIGRvbmUobnVsbCk7IHJldHVybjtcbiAgfVxuICBpZiAoc2V0UXVldWUubGVuZ3RoID4gMTApIHsgLy8gbGV0J3Mgbm90IHdhc3RlIGFueSBtb3JlIG1lbW9yeVxuICAgIGRvbmUobmV3IEVycm9yKCdFRlVMTFFVRVVFJykpOyByZXR1cm47XG4gIH1cbiAgc2V0UXVldWUucHVzaCh7IHN0b3JlOiBzdG9yZSwga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgZG9uZTogZG9uZSB9KTtcbn1cblxuZnVuY3Rpb24gZHJhaW5TZXQgKCkge1xuICBpZiAoc3VwcG9ydHMgPT09IGZhbHNlKSB7XG4gICAgc2V0UXVldWUgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2lkYl0gZHJhaW5pbmcgc2V0UXVldWUgKCVzIGl0ZW1zKScsIHNldFF1ZXVlLmxlbmd0aCk7XG4gIHdoaWxlIChzZXRRdWV1ZS5sZW5ndGgpIHtcbiAgICB2YXIgaXRlbSA9IHNldFF1ZXVlLnNoaWZ0KCk7XG4gICAgc2V0KGl0ZW0uc3RvcmUsIGl0ZW0ua2V5LCBpdGVtLnZhbHVlLCBpdGVtLmRvbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5IChvcCwgc3RvcmUsIHZhbHVlLCBkb25lKSB7XG4gIHZhciByZXEgPSBkYi50cmFuc2FjdGlvbihzdG9yZSwgJ3JlYWR3cml0ZScpLm9iamVjdFN0b3JlKHN0b3JlKVtvcF0odmFsdWUpO1xuXG4gIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICByZXEub25lcnJvciA9IGVycm9yO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MgKCkge1xuICAgIChkb25lIHx8IG5vb3ApKG51bGwsIHJlcS5yZXN1bHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IgKCkge1xuICAgIChkb25lIHx8IG5vb3ApKG5ldyBFcnJvcignVGF1bnVzIGNhY2hlIHF1ZXJ5IGZhaWxlZCBhdCBJbmRleGVkREIhJykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFsbCAoc3RvcmUsIGRvbmUpIHtcbiAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oc3RvcmUsICdyZWFkb25seScpO1xuICB2YXIgcyA9IHR4Lm9iamVjdFN0b3JlKHN0b3JlKTtcbiAgdmFyIHJlcSA9IHMub3BlbkN1cnNvcigpO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICByZXEub25zdWNjZXNzID0gc3VjY2VzcztcbiAgcmVxLm9uZXJyb3IgPSBlcnJvcjtcbiAgdHgub25jb21wbGV0ZSA9IGNvbXBsZXRlO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICAoZG9uZSB8fCBub29wKShudWxsLCBpdGVtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzdWNjZXNzIChlKSB7XG4gICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoY3Vyc29yKSB7XG4gICAgICBpdGVtcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvciAoKSB7XG4gICAgKGRvbmUgfHwgbm9vcCkobmV3IEVycm9yKCdUYXVudXMgY2FjaGUgcXVlcnktYWxsIGZhaWxlZCBhdCBJbmRleGVkREIhJykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyIChzdG9yZSwgZG9uZSkge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihzdG9yZSwgJ3JlYWR3cml0ZScpO1xuICB2YXIgcyA9IHR4Lm9iamVjdFN0b3JlKHN0b3JlKTtcbiAgdmFyIHJlcSA9IHMuY2xlYXIoKTtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgcmVxLm9uZXJyb3IgPSBlcnJvcjtcbiAgdHgub25jb21wbGV0ZSA9IGNvbXBsZXRlO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICAoZG9uZSB8fCBub29wKShudWxsLCBpdGVtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvciAoKSB7XG4gICAgKGRvbmUgfHwgbm9vcCkobmV3IEVycm9yKCdUYXVudXMgY2FjaGUgY2xlYXIgZmFpbGVkIGF0IEluZGV4ZWREQiEnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0IChzdG9yZSwga2V5LCBkb25lKSB7XG4gIGlmIChkb25lID09PSB2b2lkIDApIHtcbiAgICBhbGwoc3RvcmUsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcXVlcnkoJ2dldCcsIHN0b3JlLCBrZXksIGRvbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAoc3RvcmUsIGtleSwgdmFsdWUsIGRvbmUpIHtcbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW2lkYl0gc3RvcmluZyAlcywgaW4gJXMgZGInLCBrZXksIHN0b3JlLCB2YWx1ZSk7XG4gIHZhbHVlW2tleVBhdGhdID0ga2V5O1xuICBxdWVyeSgnYWRkJywgc3RvcmUsIHZhbHVlLCBkb25lKTsgLy8gYXR0ZW1wdCB0byBpbnNlcnRcbiAgcXVlcnkoJ3B1dCcsIHN0b3JlLCB2YWx1ZSwgZG9uZSk7IC8vIGF0dGVtcHQgdG8gdXBkYXRlXG59XG5cbmZ1bmN0aW9uIGRyYWluVGVzdGVkICgpIHtcbiAgd2hpbGUgKHRlc3RlZFF1ZXVlLmxlbmd0aCkge1xuICAgIHRlc3RlZFF1ZXVlLnNoaWZ0KCkoc3VwcG9ydHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RlZCAoZm4pIHtcbiAgaWYgKHN1cHBvcnRzICE9PSB2b2lkIDApIHtcbiAgICBmbihzdXBwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGVzdGVkUXVldWUucHVzaChmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydCAodmFsdWUpIHtcbiAgaWYgKHN1cHBvcnRzICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm47IC8vIHNhbml0eVxuICB9XG4gIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1tpZGJdIHRlc3QgcmVzdWx0ICVzLCBkYiAlcycsIHZhbHVlLCB2YWx1ZSA/ICdyZWFkeScgOiAndW5hdmFpbGFibGUnKTtcbiAgc3VwcG9ydHMgPSB2YWx1ZTtcbiAgZHJhaW5UZXN0ZWQoKTtcbiAgZHJhaW5TZXQoKTtcbn1cblxuZnVuY3Rpb24gZmFpbGVkICgpIHtcbiAgc3VwcG9ydChmYWxzZSk7XG59XG5cbmZhbGxiYWNrKCk7XG50ZXN0KCk7XG5zZXRUaW1lb3V0KGZhaWxlZCwgNjAwKTsgLy8gdGhlIHRlc3QgY2FuIHRha2Ugc29tZXdoZXJlIG5lYXIgMzAwbXMgdG8gY29tcGxldGVcblxubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbmFwaS50ZXN0ZWQgPSB0ZXN0ZWQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmF3ID0ge307XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gZW5zdXJlIChzdG9yZSkge1xuICBpZiAoIXJhd1tzdG9yZV0pIHsgcmF3W3N0b3JlXSA9IHt9OyB9XG59XG5cbmZ1bmN0aW9uIGdldCAoc3RvcmUsIGtleSwgZG9uZSkge1xuICBlbnN1cmUoc3RvcmUpO1xuICBkb25lKG51bGwsIHJhd1tzdG9yZV1ba2V5XSk7XG59XG5cbmZ1bmN0aW9uIHNldCAoc3RvcmUsIGtleSwgdmFsdWUsIGRvbmUpIHtcbiAgZW5zdXJlKHN0b3JlKTtcbiAgcmF3W3N0b3JlXVtrZXldID0gdmFsdWU7XG4gIChkb25lIHx8IG5vb3ApKG51bGwpO1xufVxuXG5mdW5jdGlvbiBjbGVhciAoKSB7XG4gIHJhdyA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ21lbW9yeVN0b3JlJyxcbiAgZ2V0OiBnZXQsXG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBnID0gZ2xvYmFsO1xuXG4vLyBmYWxsYmFjayB0byBlbXB0eSBvYmplY3QgYmVjYXVzZSB0ZXN0c1xubW9kdWxlLmV4cG9ydHMgPSBnLmluZGV4ZWREQiB8fCBnLm1vekluZGV4ZWREQiB8fCBnLndlYmtpdEluZGV4ZWREQiB8fCBnLm1zSW5kZXhlZERCIHx8IHt9O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuLi9saWIvcmVzb2x2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVzb2x2ZTogcmVzb2x2ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nO1xudmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICcmYW1wOyc6ICcmJyxcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyYjMzk7JzogJ1xcJycsXG4gICcmIzk2Oyc6ICdgJ1xufTtcblxuZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhciAoYykge1xuICByZXR1cm4gaHRtbFVuZXNjYXBlc1tjXTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGUgKGlucHV0KSB7XG4gIHZhciBkYXRhID0gaW5wdXQgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGlucHV0KTtcbiAgaWYgKGRhdGEgJiYgKHJlRXNjYXBlZEh0bWwubGFzdEluZGV4ID0gMCwgcmVFc2NhcGVkSHRtbC50ZXN0KGRhdGEpKSkge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5lc2NhcGU7XG4iLCIvKiBqc2hpbnQgc3RyaWN0OmZhbHNlICovXG4vLyB0aGlzIG1vZHVsZSBkb2Vzbid0IHVzZSBzdHJpY3QsIHNvIGV2YWwgaXMgdW5zdHJpY3QuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgLyoganNoaW50IGV2aWw6dHJ1ZSAqL1xuICByZXR1cm4gZXZhbChjb2RlKTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSgnLi9lbWl0dGVyJyk7XG52YXIgZmV0Y2hlciA9IHJlcXVpcmUoJy4vZmV0Y2hlcicpO1xudmFyIGRlZmVycmFsID0gcmVxdWlyZSgnLi9kZWZlcnJhbCcpO1xudmFyIHRlbXBsYXRpbmdBUEkgPSByZXF1aXJlKCcuL3RlbXBsYXRpbmdBUEknKTtcblxuZnVuY3Rpb24gdmlldyAoY29udGFpbmVyLCBlbmZvcmNlZEFjdGlvbiwgbW9kZWwsIHJvdXRlLCBvcHRpb25zKSB7XG4gIHZhciBhY3Rpb24gPSBlbmZvcmNlZEFjdGlvbiB8fCBtb2RlbCAmJiBtb2RlbC5hY3Rpb24gfHwgcm91dGUgJiYgcm91dGUuYWN0aW9uO1xuICB2YXIgZGVtYW5kcyA9IGRlZmVycmFsLm5lZWRzKGFjdGlvbik7XG5cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW3ZpZXddIHJlbmRlcmluZyB2aWV3ICVzIHdpdGggWyVzXSBkZW1hbmRzJywgYWN0aW9uLCBkZW1hbmRzLmpvaW4oJywnKSk7XG5cbiAgaWYgKGRlbWFuZHMubGVuZ3RoKSB7XG4gICAgcHVsbCgpO1xuICB9IGVsc2Uge1xuICAgIHJlYWR5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsICgpIHtcbiAgICB2YXIgdmljdGltID0gcm91dGUgfHwgc3RhdGUucm91dGU7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICBzb3VyY2U6ICdoaWphY2tpbmcnLFxuICAgICAgaGlqYWNrZXI6IGFjdGlvbixcbiAgICAgIGVsZW1lbnQ6IGNvbnRhaW5lclxuICAgIH07XG4gICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW3ZpZXddIGhpamFja2luZyAlcyBmb3IgYWN0aW9uICVzJywgdmljdGltLnVybCwgYWN0aW9uKTtcbiAgICBmZXRjaGVyKHZpY3RpbSwgY29udGV4dCwgcmVhZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZHkgKCkge1xuICAgIHZhciBjb250cm9sbGVyID0gZ2V0Q29tcG9uZW50KCdjb250cm9sbGVycycsIGFjdGlvbik7XG4gICAgdmFyIGludGVybmFscyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGludGVybmFscy5yZW5kZXIgIT09IGZhbHNlKSB7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gcmVuZGVyKGFjdGlvbiwgbW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbdmlld10gbm90IHJlbmRlcmluZyAlcycsIGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIgPT09IHN0YXRlLmNvbnRhaW5lcikge1xuICAgICAgZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCByb3V0ZSwgbW9kZWwpO1xuICAgIH1cbiAgICBlbWl0dGVyLmVtaXQoJ3JlbmRlcicsIGNvbnRhaW5lciwgbW9kZWwsIHJvdXRlIHx8IG51bGwpO1xuICAgIGdsb2JhbC5ERUJVRyAmJiBnbG9iYWwuREVCVUcoJ1t2aWV3XSAlcyBjbGllbnQtc2lkZSBjb250cm9sbGVyIGZvciAlcycsIGNvbnRyb2xsZXIgPyAnZXhlY3V0aW5nJyA6ICdubycsIGFjdGlvbik7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIobW9kZWwsIGNvbnRhaW5lciwgcm91dGUgfHwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlciAoYWN0aW9uLCBtb2RlbCkge1xuICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbdmlld10gcmVuZGVyaW5nICVzIHdpdGggbW9kZWwnLCBhY3Rpb24sIG1vZGVsKTtcbiAgdmFyIHRlbXBsYXRlID0gZ2V0Q29tcG9uZW50KCd0ZW1wbGF0ZXMnLCBhY3Rpb24pO1xuICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQtc2lkZSBcIicgKyBhY3Rpb24gKyAnXCIgdGVtcGxhdGUgbm90IGZvdW5kJyk7XG4gIH1cbiAgbW9kZWwudGF1bnVzID0gdGVtcGxhdGluZ0FQSTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGVtcGxhdGUobW9kZWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciByZW5kZXJpbmcgXCInICsgYWN0aW9uICsgJ1wiIHZpZXcgdGVtcGxhdGVcXG4nICsgZS5zdGFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50ICh0eXBlLCBhY3Rpb24pIHtcbiAgdmFyIGNvbXBvbmVudCA9IHN0YXRlW3R5cGVdW2FjdGlvbl07XG4gIHZhciB0cmFuc3BvcnQgPSB0eXBlb2YgY29tcG9uZW50O1xuICBpZiAodHJhbnNwb3J0ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LmZuOyAvLyBkZWZlcnJlZHMgYXJlIHN0b3JlZCBhcyB7Zm4sdmVyc2lvbn1cbiAgfVxuICBpZiAodHJhbnNwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aWFsIChjb250YWluZXIsIGFjdGlvbiwgbW9kZWwpIHtcbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW3ZpZXddIHJlbmRlcmluZyBwYXJ0aWFsICVzJywgYWN0aW9uKTtcbiAgcmV0dXJuIHZpZXcoY29udGFpbmVyLCBhY3Rpb24sIG1vZGVsLCBudWxsLCB7IHBhcnRpYWw6IHRydWUgfSk7XG59XG5cbnZpZXcucGFydGlhbCA9IHBhcnRpYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gdmlldztcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB4aHIgPSByZXF1aXJlKCd4aHInKTtcblxuZnVuY3Rpb24gcmVxdWVzdCAodXJsLCBvLCBkb25lKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIHVybDogdXJsLFxuICAgIGpzb246IHRydWUsXG4gICAgaGVhZGVyczogeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gIH07XG4gIGlmIChkb25lKSB7XG4gICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChvdmVyd3JpdGUpO1xuICB9IGVsc2Uge1xuICAgIGRvbmUgPSBvO1xuICB9XG5cbiAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW3hocl0gJXMgJXMnLCBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgb3B0aW9ucy51cmwpO1xuXG4gIHZhciByZXEgPSB4aHIob3B0aW9ucywgaGFuZGxlKTtcblxuICByZXR1cm4gcmVxO1xuXG4gIGZ1bmN0aW9uIG92ZXJ3cml0ZSAocHJvcCkge1xuICAgIG9wdGlvbnNbcHJvcF0gPSBvW3Byb3BdO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlIChlcnIsIHJlcywgYm9keSkge1xuICAgIGlmIChlcnIgJiYgIXJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkge1xuICAgICAgZ2xvYmFsLkRFQlVHICYmIGdsb2JhbC5ERUJVRygnW3hocl0gJXMgJXMgYWJvcnRlZCcsIG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBvcHRpb25zLnVybCk7XG4gICAgICBkb25lKG5ldyBFcnJvcignYWJvcnRlZCcpLCBudWxsLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwuREVCVUcgJiYgZ2xvYmFsLkRFQlVHKCdbeGhyXSAlcyAlcyBkb25lJywgb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsIG9wdGlvbnMudXJsKTtcbiAgICAgIGRvbmUoZXJyLCBib2R5LCByZXMpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmVycmVkIChhY3Rpb24sIHJ1bGVzKSB7XG4gIHJldHVybiBydWxlcy5zb21lKGZhaWxlZCk7XG4gIGZ1bmN0aW9uIGZhaWxlZCAoY2hhbGxlbmdlKSB7XG4gICAgdmFyIGxlZnQgPSBjaGFsbGVuZ2Uuc3BsaXQoJy8nKTtcbiAgICB2YXIgcmlnaHQgPSBhY3Rpb24uc3BsaXQoJy8nKTtcbiAgICB2YXIgbHBhcnQsIHJwYXJ0O1xuICAgIHdoaWxlIChsZWZ0Lmxlbmd0aCkge1xuICAgICAgbHBhcnQgPSBsZWZ0LnNoaWZ0KCk7XG4gICAgICBycGFydCA9IHJpZ2h0LnNoaWZ0KCk7XG4gICAgICBpZiAobHBhcnQgIT09ICc/JyAmJiBscGFydCAhPT0gcnBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqICMgYSBuYW1lZCBwYXJhbWV0ZXIgaW4gdGhlICc6bmFtZScgZm9ybWF0XG4gKiA6KFthLXpdKylcbiAqXG4gKiAjIG1hdGNoZXMgYSByZWdleHAgdGhhdCBjb25zdHJhaW50cyB0aGUgcG9zc2libGUgdmFsdWVzIGZvciB0aGlzIHBhcmFtZXRlclxuICogIyBlLmcgJzpuYW1lKFthLXorXSknXG4gKiAoPzpcXCgoPyFbKis/XSkoPzpbXlxcclxcblxcWy9cXFxcXXxcXFxcLnxcXFsoPzpbXlxcclxcblxcXVxcXFxdfFxcXFwuKSpcXF0pK1xcKSk/XG4gKlxuICogIyB0aGUgcGFyYW1ldGVyIG1heSBiZSBvcHRpb25hbCwgZS5nICc6bmFtZT8nXG4gKiAoXFw/KT9cbiAqXG4gKiAtIGk6IHJvdXRlcyBhcmUgdHlwaWNhbGx5IGxvd2VyLWNhc2UgYnV0IHRoZXkgbWF5IGJlIG1peGVkIGNhc2UgYXMgd2VsbFxuICogLSBnOiByb3V0ZXMgbWF5IGhhdmUgemVybyBvciBtb3JlIG5hbWVkIHBhcmFtZXRlcnNcbiAqXG4gKiByZWdleHBlcjogaHR0cDovL3JlZ2V4cGVyLmNvbS8jJTJGJTNBKCU1QmEteiU1RCUyQikoJTNGJTNBJTVDKCglM0YhJTVCKiUyQiUzRiU1RCkoJTNGJTNBJTVCJTVFJTVDciU1Q24lNUMlNUIlMkYlNUMlNUMlNUQlN0MlNUMlNUMuJTdDJTVDJTVCKCUzRiUzQSU1QiU1RSU1Q3IlNUNuJTVDJTVEJTVDJTVDJTVEJTdDJTVDJTVDLikqJTVDJTVEKSUyQiU1QykpJTNGKCU1QyUzRiklM0YlMkZpZ1xuICovXG5cbnZhciBkZWZhdWx0TWF0Y2hlciA9IC86KFthLXpdKykoPzpcXCgoPyFbKis/XSkoPzpbXlxcclxcblxcWy9cXFxcXXxcXFxcLnxcXFsoPzpbXlxcclxcblxcXVxcXFxdfFxcXFwuKSpcXF0pK1xcKSk/KFxcPyk/L2lnO1xudmFyIHJvdXRlcztcbnZhciBtYXRjaGVyO1xuXG5mdW5jdGlvbiBmaW5kIChhY3Rpb24pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCByb3V0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocm91dGVzW2ldLmFjdGlvbiA9PT0gYWN0aW9uKSB7XG4gICAgICByZXR1cm4gcm91dGVzW2ldLnJvdXRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXNlIChtKSB7XG4gIG1hdGNoZXIgPSBtIHx8IGRlZmF1bHRNYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBzZXQgKHIpIHtcbiAgcm91dGVzID0gciB8fCBbXTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZSAoYWN0aW9uLCBkYXRhKSB7XG4gIHZhciBwcm9wcyA9IGRhdGEgfHwge307XG4gIHZhciByb3V0ZSA9IGZpbmQoYWN0aW9uKTtcbiAgaWYgKHJvdXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJvdXRlLnJlcGxhY2UobWF0Y2hlciwgcmVwbGFjZXIpICsgcXVlcnlTdHJpbmcocHJvcHMuYXJncyk7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZXIgKG1hdGNoLCBrZXksIG9wdGlvbmFsKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgfVxuICAgIGlmIChrZXkgaW4gcHJvcHMgfHwgb3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZSAnICsgcm91dGUgKyAnIGV4cGVjdGVkIFwiJyArIGtleSArICdcIiBwYXJhbWV0ZXIuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWVyeVN0cmluZyAoYXJncykge1xuICAgIHZhciBwYXJ0cyA9IGFyZ3MgfHwge307XG4gICAgdmFyIHF1ZXJ5ID0gT2JqZWN0LmtleXMocGFydHMpLm1hcChrZXlWYWx1ZVBhaXIpLmpvaW4oJyYnKTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHJldHVybiAnPycgKyBxdWVyeTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuXG4gICAgZnVuY3Rpb24ga2V5VmFsdWVQYWlyIChwcm9wKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0c1twcm9wXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wICsgJz0nICsgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbnVzZSgpO1xuc2V0KCk7XG5cbnJlc29sdmUudXNlID0gdXNlO1xucmVzb2x2ZS5zZXQgPSBzZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvY29udHJhLmVtaXR0ZXIuanMnKTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4oZnVuY3Rpb24gKHJvb3QsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHVuZGVmID0gJycgKyB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIGF0b2EgKGEsIG4pIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIG4pOyB9XG4gIGZ1bmN0aW9uIGRlYm91bmNlIChmbiwgYXJncywgY3R4KSB7IGlmICghZm4pIHsgcmV0dXJuOyB9IHRpY2soZnVuY3Rpb24gcnVuICgpIHsgZm4uYXBwbHkoY3R4IHx8IG51bGwsIGFyZ3MgfHwgW10pOyB9KTsgfVxuXG4gIC8vIGNyb3NzLXBsYXRmb3JtIHRpY2tlclxuICB2YXIgc2kgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nLCB0aWNrO1xuICBpZiAoc2kpIHtcbiAgICB0aWNrID0gZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09IHVuZGVmICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICB0aWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgfSBlbHNlIHtcbiAgICB0aWNrID0gZnVuY3Rpb24gKGZuKSB7IHNldFRpbWVvdXQoZm4sIDApOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2VtaXR0ZXIgKHRoaW5nLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBldnQgPSB7fTtcbiAgICBpZiAodGhpbmcgPT09IHVuZGVmaW5lZCkgeyB0aGluZyA9IHt9OyB9XG4gICAgdGhpbmcub24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICAgIGlmICghZXZ0W3R5cGVdKSB7XG4gICAgICAgIGV2dFt0eXBlXSA9IFtmbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldnRbdHlwZV0ucHVzaChmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfTtcbiAgICB0aGluZy5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICBmbi5fb25jZSA9IHRydWU7IC8vIHRoaW5nLm9mZihmbikgc3RpbGwgd29ya3MhXG4gICAgICB0aGluZy5vbih0eXBlLCBmbik7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfTtcbiAgICB0aGluZy5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChjID09PSAxKSB7XG4gICAgICAgIGRlbGV0ZSBldnRbdHlwZV07XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IDApIHtcbiAgICAgICAgZXZ0ID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXQgPSBldnRbdHlwZV07XG4gICAgICAgIGlmICghZXQpIHsgcmV0dXJuIHRoaW5nOyB9XG4gICAgICAgIGV0LnNwbGljZShldC5pbmRleE9mKGZuKSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfTtcbiAgICB0aGluZy5lbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGF0b2EoYXJndW1lbnRzKTtcbiAgICAgIHZhciB0eXBlID0gYXJncy5zaGlmdCgpO1xuICAgICAgdmFyIGV0ID0gZXZ0W3R5cGVdO1xuICAgICAgaWYgKHR5cGUgPT09ICdlcnJvcicgJiYgb3B0cy50aHJvd3MgIT09IGZhbHNlICYmICFldCkgeyB0aHJvdyBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBhcmdzOyB9XG4gICAgICBpZiAoIWV0KSB7IHJldHVybiB0aGluZzsgfVxuICAgICAgZXZ0W3R5cGVdID0gZXQuZmlsdGVyKGZ1bmN0aW9uIGVtaXR0ZXIgKGxpc3Rlbikge1xuICAgICAgICBpZiAob3B0cy5hc3luYykgeyBkZWJvdW5jZShsaXN0ZW4sIGFyZ3MsIGN0eCk7IH0gZWxzZSB7IGxpc3Rlbi5hcHBseShjdHgsIGFyZ3MpOyB9XG4gICAgICAgIHJldHVybiAhbGlzdGVuLl9vbmNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH1cblxuICAvLyBjcm9zcy1wbGF0Zm9ybSBleHBvcnRcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IHVuZGVmICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZW1pdHRlcjtcbiAgfSBlbHNlIHtcbiAgICByb290LmNvbnRyYSA9IHJvb3QuY29udHJhIHx8IHt9O1xuICAgIHJvb3QuY29udHJhLmVtaXR0ZXIgPSBfZW1pdHRlcjtcbiAgfVxufSkodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL25pY28vLm52bS92MC4xMC4yNi9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkiLCJcInVzZSBzdHJpY3RcIjtcbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cbmZ1bmN0aW9uIFVybCgpIHtcbiAgICAvL0ZvciBtb3JlIGVmZmljaWVudCBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBhbmQgbGF6aW5lc3MuXG4gICAgLy9UaGUgbm9uLXVuZGVyc2NvcmUgdmVyc2lvbnMgb2YgdGhlc2UgcHJvcGVydGllcyBhcmUgYWNjZXNzb3IgZnVuY3Rpb25zXG4gICAgLy9kZWZpbmVkIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgdGhpcy5fcHJvdG9jb2wgPSBudWxsO1xuICAgIHRoaXMuX2hyZWYgPSBcIlwiO1xuICAgIHRoaXMuX3BvcnQgPSAtMTtcbiAgICB0aGlzLl9xdWVyeSA9IG51bGw7XG5cbiAgICB0aGlzLmF1dGggPSBudWxsO1xuICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3ByZXBlbmRTbGFzaCA9IGZhbHNlO1xufVxuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5VcmwucHJvdG90eXBlLnBhcnNlID1cbmZ1bmN0aW9uIFVybCRwYXJzZShzdHIsIHBhcnNlUXVlcnlTdHJpbmcsIGhvc3REZW5vdGVzU2xhc2gpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArXG4gICAgICAgICAgICB0eXBlb2Ygc3RyKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgICAvL1RyaW0gbGVhZGluZyBhbmQgdHJhaWxpbmcgd3NcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpIDw9IDB4MjAgLyonICcqLykgc3RhcnQrKztcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoZW5kKSA8PSAweDIwIC8qJyAnKi8pIGVuZC0tO1xuXG4gICAgc3RhcnQgPSB0aGlzLl9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCk7XG5cbiAgICAvL0phdmFzY3JpcHQgZG9lc24ndCBoYXZlIGhvc3RcbiAgICBpZiAodGhpcy5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgaG9zdERlbm90ZXNTbGFzaCk7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICBpZiAoIXRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaFByb3RvY29sc1twcm90b10pKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MkYgLyonLycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0YgLyonPycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Byb3RvY29sICE9PSBcImphdmFzY3JpcHRcIikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vRm9yIGphdmFzY3JpcHQgdGhlIHBhdGhuYW1lIGlzIGp1c3QgdGhlIHJlc3Qgb2YgaXRcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdGhuYW1lICYmIHRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgdGhpcy5fc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdKSB7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBcIi9cIjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgICAgIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VhcmNoID0gdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNhbGxzIGEgc2V0dGVyIGZ1bmN0aW9uLCB0aGVyZSBpcyBubyAucXVlcnkgZGF0YSBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uoc2VhcmNoKTtcbiAgICB9XG59O1xuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiBVcmwkcmVzb2x2ZShyZWxhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QoVXJsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiBVcmwkZm9ybWF0KCkge1xuICAgIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8IFwiXCI7XG5cbiAgICBpZiAoYXV0aCkge1xuICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgICAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgXCI6XCIpO1xuICAgICAgICBhdXRoICs9IFwiQFwiO1xuICAgIH1cblxuICAgIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgXCJcIjtcbiAgICB2YXIgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2ggfHwgXCJcIjtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgXCJcIjtcbiAgICB2YXIgcXVlcnkgPSBcIlwiO1xuICAgIHZhciBob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgXCJcIjtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydCB8fCBcIlwiO1xuICAgIHZhciBob3N0ID0gZmFsc2U7XG4gICAgdmFyIHNjaGVtZSA9IFwiXCI7XG5cbiAgICAvL0NhY2hlIHRoZSByZXN1bHQgb2YgdGhlIGdldHRlciBmdW5jdGlvblxuICAgIHZhciBxID0gdGhpcy5xdWVyeTtcbiAgICBpZiAocSAmJiB0eXBlb2YgcSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShxKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICBzZWFyY2ggPSBxdWVyeSA/IFwiP1wiICsgcXVlcnkgOiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQ29kZUF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAweDNBIC8qJzonKi8pXG4gICAgICAgIHByb3RvY29sICs9IFwiOlwiO1xuXG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgdmFyIGlwNiA9IGhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID4gLTE7XG4gICAgICAgIGlmIChpcDYpIGhvc3RuYW1lID0gXCJbXCIgKyBob3N0bmFtZSArIFwiXVwiO1xuICAgICAgICBob3N0ID0gYXV0aCArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc2xhc2hlcyA9IHRoaXMuc2xhc2hlcyB8fFxuICAgICAgICAoKCFwcm90b2NvbCB8fFxuICAgICAgICBzbGFzaFByb3RvY29sc1twcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKTtcblxuXG4gICAgaWYgKHByb3RvY29sKSBzY2hlbWUgPSBwcm90b2NvbCArIChzbGFzaGVzID8gXCIvL1wiIDogXCJcIik7XG4gICAgZWxzZSBpZiAoc2xhc2hlcykgc2NoZW1lID0gXCIvL1wiO1xuXG4gICAgaWYgKHNsYXNoZXMgJiYgcGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckNvZGVBdCgwKSAhPT0gMHgyRiAvKicvJyovKSB7XG4gICAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsYXNoZXMgJiYgcGF0aG5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGhuYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckNvZGVBdCgwKSAhPT0gMHgzRiAvKic/JyovKVxuICAgICAgICBzZWFyY2ggPSBcIj9cIiArIHNlYXJjaDtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJDb2RlQXQoMCkgIT09IDB4MjMgLyonIycqLylcbiAgICAgICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcblxuICAgIHBhdGhuYW1lID0gZXNjYXBlUGF0aE5hbWUocGF0aG5hbWUpO1xuICAgIHNlYXJjaCA9IGVzY2FwZVNlYXJjaChzZWFyY2gpO1xuXG4gICAgcmV0dXJuIHNjaGVtZSArIChob3N0ID09PSBmYWxzZSA/IFwiXCIgOiBob3N0KSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRyZXNvbHZlT2JqZWN0KHJlbGF0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiByZWxhdGl2ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVsYXRpdmUgPSBVcmwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9jbG9uZSgpO1xuXG4gICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gICAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZVwicyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgICBpZiAoIXJlbGF0aXZlLmhyZWYpIHtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IHJlc3VsdC5fcHJvdG9jb2wpIHtcbiAgICAgICAgLy8gaWYgaXRcInMgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICAgIC8vIGZpcnN0LCBpZiBpdFwicyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAgICAvLyBiZWNhdXNlIHRoYXRcInMga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgICAgaWYgKCFzbGFzaFByb3RvY29sc1tyZWxhdGl2ZS5fcHJvdG9jb2xdKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5fY29weVByb3BzVG8ocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5fcHJvdG9jb2wgPSByZWxhdGl2ZS5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09IFwiXCIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbihcIi9cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCBcIlwiO1xuICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IHJlbGF0aXZlLl9wb3J0O1xuICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzU291cmNlQWJzID1cbiAgICAgICAgKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKTtcbiAgICB2YXIgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgICAocmVsYXRpdmUucGF0aG5hbWUgJiZcbiAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLylcbiAgICAgICAgKTtcbiAgICB2YXIgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSk7XG5cbiAgICB2YXIgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnM7XG5cbiAgICB2YXIgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciBwc3ljaG90aWMgPSByZXN1bHQuX3Byb3RvY29sICYmICFzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXTtcblxuICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gICAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICByZXN1bHQuX3BvcnQgPSAtMTtcbiAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gXCJcIikgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gXCJcIjtcbiAgICAgICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCkge1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgcmVsYXRpdmUuX3BvcnQgPSAtMTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09IFwiXCIpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09IFwiXCIgfHwgc3JjUGF0aFswXSA9PT0gXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgIC8vIGl0XCJzIGFic29sdXRlLlxuICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgP1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICAgIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gaXRcInMgcmVsYXRpdmVcbiAgICAgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgICAgICBzcmNQYXRoLnBvcCgpO1xuICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgfSBlbHNlIGlmIChyZWxhdGl2ZS5zZWFyY2gpIHtcbiAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAgICAvLyBsaWtlIGhyZWY9XCI/Zm9vXCIuXG4gICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KFwibWFpbHRvOmxvY2FsMUBkb21haW4xXCIsIFwibG9jYWwyQGRvbWFpbjJcIilcbiAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdChcIkBcIikgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgLy8gd2VcInZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICAgIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09IFwiLlwiIHx8IGxhc3QgPT09IFwiLi5cIikgfHxcbiAgICAgICAgbGFzdCA9PT0gXCJcIik7XG5cbiAgICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgICAgIGlmIChsYXN0ID09IFwiLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdChcIi4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gXCJcIiAmJlxuICAgICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pKSB7XG4gICAgICAgIHNyY1BhdGgudW5zaGlmdChcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKFwiL1wiKS5zdWJzdHIoLTEpICE9PSBcIi9cIikpIHtcbiAgICAgICAgc3JjUGF0aC5wdXNoKFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gXCJcIiB8fFxuICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLyk7XG5cbiAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gXCJcIiA6XG4gICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6IFwiXCI7XG4gICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdChcIm1haWx0bzpsb2NhbDFAZG9tYWluMVwiLCBcImxvY2FsMkBkb21haW4yXCIpXG4gICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogc3JjUGF0aC5qb2luKFwiL1wiKTtcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoXCJwdW55Y29kZVwiKTtcblVybC5wcm90b3R5cGUuX2hvc3RJZG5hID0gZnVuY3Rpb24gVXJsJF9ob3N0SWRuYShob3N0bmFtZSkge1xuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICB2YXIgZG9tYWluQXJyYXkgPSBob3N0bmFtZS5zcGxpdChcIi5cIik7XG4gICAgdmFyIG5ld091dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICBcInhuLS1cIiArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T3V0LmpvaW4oXCIuXCIpO1xufTtcblxudmFyIGVzY2FwZVBhdGhOYW1lID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlUGF0aE5hbWUgPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVQYXRoTmFtZShwYXRobmFtZSkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHBhdGhuYW1lLCAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlUGF0aChwYXRobmFtZSk7XG59O1xuXG52YXIgZXNjYXBlU2VhcmNoID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlU2VhcmNoID1cbmZ1bmN0aW9uIFVybCRfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHNlYXJjaCwgMHgyMyAvKicjJyovLCAtMSkpIHJldHVybiBzZWFyY2g7XG4gICAgLy9Bdm9pZCBjbG9zdXJlIGNyZWF0aW9uIHRvIGtlZXAgdGhpcyBpbmxpbmFibGVcbiAgICByZXR1cm4gX2VzY2FwZVNlYXJjaChzZWFyY2gpO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQcm90b2NvbCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQcm90b2NvbChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgcHJvdG9jb2xDaGFyYWN0ZXJzID0gdGhpcy5fcHJvdG9jb2xDaGFyYWN0ZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBzdHIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaWYgKGRvTG93ZXJDYXNlKSBwcm90b2NvbCA9IHByb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3RvY29sQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChjaCA8IDB4NjEgLyonYScqLylcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUF1dGggPSBmdW5jdGlvbiBVcmwkX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBlbmQsIGRlY29kZSkge1xuICAgIHZhciBhdXRoID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICBpZiAoZGVjb2RlKSB7XG4gICAgICAgIGF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVBvcnQgPSBmdW5jdGlvbiBVcmwkX3BhcnNlUG9ydChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAvL0ludGVybmFsIGZvcm1hdCBpcyBpbnRlZ2VyIGZvciBtb3JlIGVmZmljaWVudCBwYXJzaW5nXG4gICAgLy9hbmQgZm9yIGVmZmljaWVudCB0cmltbWluZyBvZiBsZWFkaW5nIHplcm9zXG4gICAgdmFyIHBvcnQgPSAwO1xuICAgIC8vRGlzdGluZ3Vpc2ggYmV0d2VlbiA6MCBhbmQgOiAobm8gcG9ydCBudW1iZXIgYXQgYWxsKVxuICAgIHZhciBoYWRDaGFycyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSB7XG4gICAgICAgICAgICBwb3J0ID0gKDEwICogcG9ydCkgKyAoY2ggLSAweDMwIC8qJzAnKi8pO1xuICAgICAgICAgICAgaGFkQ2hhcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYnJlYWs7XG5cbiAgICB9XG4gICAgaWYgKHBvcnQgPT09IDAgJiYgIWhhZENoYXJzKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHJldHVybiBpIC0gc3RhcnQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUhvc3QgPVxuZnVuY3Rpb24gVXJsJF9wYXJzZUhvc3Qoc3RyLCBzdGFydCwgZW5kLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICAgIHZhciBob3N0RW5kaW5nQ2hhcmFjdGVycyA9IHRoaXMuX2hvc3RFbmRpbmdDaGFyYWN0ZXJzO1xuICAgIGlmIChzdHIuY2hhckNvZGVBdChzdGFydCkgPT09IDB4MkYgLyonLycqLyAmJlxuICAgICAgICBzdHIuY2hhckNvZGVBdChzdGFydCArIDEpID09PSAweDJGIC8qJy8nKi8pIHtcbiAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcblxuICAgICAgICAvL1RoZSBzdHJpbmcgc3RhcnRzIHdpdGggLy9cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAvL1RoZSBzdHJpbmcgaXMganVzdCBcIi8vXCJcbiAgICAgICAgICAgIGlmIChlbmQgPCAyKSByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAvL0lmIHNsYXNoZXMgZG8gbm90IGRlbm90ZSBob3N0IGFuZCB0aGVyZSBpcyBubyBhdXRoLFxuICAgICAgICAgICAgLy90aGVyZSBpcyBubyBob3N0IHdoZW4gdGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICAgICAgdmFyIGhhc0F1dGggPVxuICAgICAgICAgICAgICAgIGNvbnRhaW5zQ2hhcmFjdGVyKHN0ciwgMHg0MCAvKidAJyovLCAyLCBob3N0RW5kaW5nQ2hhcmFjdGVycyk7XG4gICAgICAgICAgICBpZiAoIWhhc0F1dGggJiYgIXNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGVyZSBpcyBhIGhvc3QgdGhhdCBzdGFydHMgYWZ0ZXIgdGhlIC8vXG4gICAgICAgIHN0YXJ0ICs9IDI7XG4gICAgfVxuICAgIC8vSWYgdGhlcmUgaXMgbm8gc2xhc2hlcywgdGhlcmUgaXMgbm8gaG9zdG5hbWUgaWZcbiAgICAvLzEuIHRoZXJlIHdhcyBubyBwcm90b2NvbCBhdCBhbGxcbiAgICBlbHNlIGlmICghdGhpcy5fcHJvdG9jb2wgfHxcbiAgICAgICAgLy8yLiB0aGVyZSB3YXMgYSBwcm90b2NvbCB0aGF0IHJlcXVpcmVzIHNsYXNoZXNcbiAgICAgICAgLy9lLmcuIGluICdodHRwOmFzZCcgJ2FzZCcgaXMgbm90IGEgaG9zdG5hbWVcbiAgICAgICAgc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgaWRuYSA9IGZhbHNlO1xuICAgIHZhciBob3N0TmFtZVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIGhvc3ROYW1lRW5kID0gZW5kO1xuICAgIHZhciBsYXN0Q2ggPSAtMTtcbiAgICB2YXIgcG9ydExlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXJzQWZ0ZXJEb3QgPSAwO1xuICAgIHZhciBhdXRoTmVlZHNEZWNvZGluZyA9IGZhbHNlO1xuXG4gICAgdmFyIGogPSAtMTtcblxuICAgIC8vRmluZCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIEAtc2lnbiB1bnRpbCBob3N0ZW5kaW5nIGNoYXJhY3RlciBpcyBtZXRcbiAgICAvL2Fsc28gbWFyayBpZiBkZWNvZGluZyBpcyBuZWVkZWQgZm9yIHRoZSBhdXRoIHBvcnRpb25cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDQwIC8qJ0AnKi8pIHtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBjaGVjayBpcyB2ZXJ5LCB2ZXJ5IGNoZWFwLiBVbm5lZWRlZCBkZWNvZGVVUklDb21wb25lbnQgaXMgdmVyeVxuICAgICAgICAvL3ZlcnkgZXhwZW5zaXZlXG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDI1IC8qJyUnKi8pIHtcbiAgICAgICAgICAgIGF1dGhOZWVkc0RlY29kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob3N0RW5kaW5nQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9ALXNpZ24gd2FzIGZvdW5kIGF0IGluZGV4IGosIGV2ZXJ5dGhpbmcgdG8gdGhlIGxlZnQgZnJvbSBpdFxuICAgIC8vaXMgYXV0aCBwYXJ0XG4gICAgaWYgKGogPiAtMSkge1xuICAgICAgICB0aGlzLl9wYXJzZUF1dGgoc3RyLCBzdGFydCwgaiAtIDEsIGF1dGhOZWVkc0RlY29kaW5nKTtcbiAgICAgICAgLy9ob3N0bmFtZSBzdGFydHMgYWZ0ZXIgdGhlIGxhc3QgQC1zaWduXG4gICAgICAgIHN0YXJ0ID0gaG9zdE5hbWVTdGFydCA9IGogKyAxO1xuICAgIH1cblxuICAgIC8vSG9zdCBuYW1lIGlzIHN0YXJ0aW5nIHdpdGggYSBbXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QiAvKidbJyovKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAvL0Fzc3VtZSB2YWxpZCBJUDYgaXMgYmV0d2VlbiB0aGUgYnJhY2tldHNcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1RCAvKiddJyovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRMZW5ndGggPSB0aGlzLl9wYXJzZVBvcnQoc3RyLCBpICsgMiwgZW5kKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBob3N0bmFtZSA9IHN0ci5zbGljZShzdGFydCArIDEsIGkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IHRoaXMuX3BvcnQgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gXCJbXCIgKyBob3N0bmFtZSArIFwiXTpcIiArIHRoaXMuX3BvcnRcbiAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgcG9ydExlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9FbXB0eSBob3N0bmFtZSwgWyBzdGFydHMgYSBwYXRoXG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJzQWZ0ZXJEb3QgPiA2Mikge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EgLyonOicqLykge1xuICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAxLCBlbmQpICsgMTtcbiAgICAgICAgICAgIGhvc3ROYW1lRW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA8IDB4NjEgLyonYScqLykge1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDJFIC8qJy4nKi8pIHtcbiAgICAgICAgICAgICAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoID09PSBET1QgfHwgbGFzdENoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNoYXJzQWZ0ZXJEb3QgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDB4NDEgLyonQScqLyA8PSBjaCAmJiBjaCA8PSAweDVBIC8qJ1onKi8pIHtcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKGNoID09PSAweDJEIC8qJy0nKi8gfHwgY2ggPT09IDB4NUYgLyonXycqLyB8fFxuICAgICAgICAgICAgICAgICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEVuZGluZ0NoYXJhY3RlcnNbY2hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA+PSAweDdCIC8qJ3snKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdFIC8qJ34nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbm9QcmVwZW5kU2xhc2hIb3N0RW5kZXJzW2NoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwZW5kU2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0TmFtZUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRuYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENoID0gY2g7XG4gICAgICAgIGNoYXJzQWZ0ZXJEb3QrKztcbiAgICB9XG5cbiAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgLypcbiAgICBpZiAobGFzdENoID09PSBET1QpIHtcbiAgICAgICAgaG9zdE5hbWVFbmQtLTtcbiAgICB9XG4gICAgKi9cblxuICAgIGlmIChob3N0TmFtZUVuZCArIDEgIT09IHN0YXJ0ICYmXG4gICAgICAgIGhvc3ROYW1lRW5kIC0gaG9zdE5hbWVTdGFydCA8PSAyNTYpIHtcbiAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKGhvc3ROYW1lU3RhcnQsIGhvc3ROYW1lRW5kICsgMSk7XG4gICAgICAgIGlmIChkb0xvd2VyQ2FzZSkgaG9zdG5hbWUgPSBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaWRuYSkgaG9zdG5hbWUgPSB0aGlzLl9ob3N0SWRuYShob3N0bmFtZSk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0bmFtZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgPyBob3N0bmFtZSArIFwiOlwiICsgdGhpcy5fcG9ydCA6IGhvc3RuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBob3N0TmFtZUVuZCArIDEgKyBwb3J0TGVuZ3RoO1xuXG59O1xuXG5VcmwucHJvdG90eXBlLl9jb3B5UHJvcHNUbyA9IGZ1bmN0aW9uIFVybCRfY29weVByb3BzVG8oaW5wdXQsIG5vUHJvdG9jb2wpIHtcbiAgICBpZiAoIW5vUHJvdG9jb2wpIHtcbiAgICAgICAgaW5wdXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIGlucHV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICBpbnB1dC5fcG9ydCA9IHRoaXMuX3BvcnQ7XG4gICAgaW5wdXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICBpbnB1dC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIGlucHV0LnNsYXNoZXMgPSB0aGlzLnNsYXNoZXM7XG4gICAgaW5wdXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICBpbnB1dC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgaW5wdXQuaGFzaCA9IHRoaXMuaGFzaDtcbiAgICBpbnB1dC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICBpbnB1dC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG59O1xuXG5VcmwucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIFVybCRfY2xvbmUoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgcmV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICByZXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIHJldC5fcHJlcGVuZFNsYXNoID0gdGhpcy5fcHJlcGVuZFNsYXNoO1xuICAgIHJldC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIHJldC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIHJldC5ob3N0ID0gdGhpcy5ob3N0O1xuICAgIHJldC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgcmV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgcmV0LnNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgIHJldC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX2dldENvbXBvbmVudEVzY2FwZWQgPVxuZnVuY3Rpb24gVXJsJF9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBjdXIgPSBzdGFydDtcbiAgICB2YXIgaSA9IHN0YXJ0O1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBhdXRvRXNjYXBlTWFwID0gdGhpcy5fYXV0b0VzY2FwZU1hcDtcbiAgICBmb3IgKDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSBhdXRvRXNjYXBlTWFwW2NoXTtcblxuICAgICAgICBpZiAoZXNjYXBlZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKGN1ciA8IGkpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICAgICAgICAgIHJldCArPSBlc2NhcGVkO1xuICAgICAgICAgICAgY3VyID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1ciA8IGkgKyAxKSByZXQgKz0gc3RyLnNsaWNlKGN1ciwgaSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUGF0aCA9XG5mdW5jdGlvbiBVcmwkX3BhcnNlUGF0aChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcGF0aFN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHBhdGhFbmQgPSBlbmQ7XG4gICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xuICAgIHZhciBhdXRvRXNjYXBlQ2hhcmFjdGVycyA9IHRoaXMuX2F1dG9Fc2NhcGVDaGFyYWN0ZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUXVlcnkoc3RyLCBpLCBlbmQpO1xuICAgICAgICAgICAgcGF0aEVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aFN0YXJ0ID4gcGF0aEVuZCkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aDtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcGF0aFN0YXJ0LCBwYXRoRW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGggPSBzdHIuc2xpY2UocGF0aFN0YXJ0LCBwYXRoRW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMucGF0aG5hbWUgPSB0aGlzLl9wcmVwZW5kU2xhc2ggPyBcIi9cIiArIHBhdGggOiBwYXRoO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VRdWVyeSA9IGZ1bmN0aW9uIFVybCRfcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcXVlcnlTdGFydCA9IHN0YXJ0O1xuICAgIHZhciBxdWVyeUVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIGksIGVuZCk7XG4gICAgICAgICAgICBxdWVyeUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVlcnlTdGFydCA+IHF1ZXJ5RW5kKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWVyeTtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5fZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXJ5ID0gc3RyLnNsaWNlKHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoID0gcXVlcnk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUhhc2ggPSBmdW5jdGlvbiBVcmwkX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhhc2ggPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiXCIgKyB0aGlzLl9wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeTtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG5cbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5jaGFyQ29kZUF0KDApID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VhcmNoICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gdjtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgaWYgKHAgfHwgcykge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocCA9PSBudWxsICYmIHMpID8gKFwiL1wiICsgcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICByZXR1cm4gcHJvdG8gPyBwcm90byArIFwiOlwiIDogcHJvdG87XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gdi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHYuY2hhckNvZGVBdChlbmQpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHYuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJocmVmXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuX2hyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX2hyZWYgPSB2O1xuICAgIH1cbn0pO1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiBVcmwkUGFyc2Uoc3RyLCBwYXJzZVF1ZXJ5U3RyaW5nLCBob3N0RGVub3Rlc1NsYXNoKSB7XG4gICAgaWYgKHN0ciBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHN0cjtcbiAgICB2YXIgcmV0ID0gbmV3IFVybCgpO1xuICAgIHJldC5wYXJzZShzdHIsICEhcGFyc2VRdWVyeVN0cmluZywgISFob3N0RGVub3Rlc1NsYXNoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLmZvcm1hdCA9IGZ1bmN0aW9uIFVybCRGb3JtYXQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb2JqID0gVXJsLnBhcnNlKG9iaik7XG4gICAgfVxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICAgICAgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn07XG5cblVybC5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59O1xuXG5VcmwucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59O1xuXG5mdW5jdGlvbiBfZXNjYXBlUGF0aChwYXRobmFtZSkge1xuICAgIHJldHVybiBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIHJldHVybiBzZWFyY2gucmVwbGFjZSgvIy9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgICB9KTtcbn1cblxuLy9TZWFyY2ggYGNoYXIxYCAoaW50ZWdlciBjb2RlIGZvciBhIGNoYXJhY3RlcikgaW4gYHN0cmluZ2Bcbi8vc3RhcnRpbmcgZnJvbSBgZnJvbUluZGV4YCBhbmQgZW5kaW5nIGF0IGBzdHJpbmcubGVuZ3RoIC0gMWBcbi8vb3Igd2hlbiBhIHN0b3AgY2hhcmFjdGVyIGlzIGZvdW5kXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcihzdHJpbmcsIGNoYXIxLCBmcm9tSW5kZXgsIHN0b3BDaGFyYWN0ZXJUYWJsZSkge1xuICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IGNoYXIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG9wQ2hhcmFjdGVyVGFibGVbY2hdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1NlZSBpZiBgY2hhcjFgIG9yIGBjaGFyMmAgKGludGVnZXIgY29kZXMgZm9yIGNoYXJhY3RlcnMpXG4vL2lzIGNvbnRhaW5lZCBpbiBgc3RyaW5nYFxuZnVuY3Rpb24gY29udGFpbnNDaGFyYWN0ZXIyKHN0cmluZywgY2hhcjEsIGNoYXIyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSBjaGFyMSB8fCBjaCA9PT0gY2hhcjIpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vTWFrZXMgYW4gYXJyYXkgb2YgMTI4IHVpbnQ4J3Mgd2hpY2ggcmVwcmVzZW50IGJvb2xlYW4gdmFsdWVzLlxuLy9TcGVjIGlzIGFuIGFycmF5IG9mIGFzY2lpIGNvZGUgcG9pbnRzIG9yIGFzY2lpIGNvZGUgcG9pbnQgcmFuZ2VzXG4vL3JhbmdlcyBhcmUgZXhwcmVzc2VkIGFzIFtzdGFydCwgZW5kXVxuXG4vL0NyZWF0ZSBhIHRhYmxlIHdpdGggdGhlIGNoYXJhY3RlcnMgMHgzMC0weDM5IChkZWNpbWFscyAnMCcgLSAnOScpIGFuZFxuLy8weDdBIChsb3dlcmNhc2VsZXR0ZXIgJ3onKSBhcyBgdHJ1ZWA6XG4vL1xuLy92YXIgYSA9IG1ha2VBc2NpaVRhYmxlKFtbMHgzMCwgMHgzOV0sIDB4N0FdKTtcbi8vYVsweDMwXTsgLy8xXG4vL2FbMHgxNV07IC8vMFxuLy9hWzB4MzVdOyAvLzFcbmZ1bmN0aW9uIG1ha2VBc2NpaVRhYmxlKHNwZWMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoMTI4KTtcbiAgICBzcGVjLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0W2l0ZW1dID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGl0ZW1bMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gaXRlbVsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7ICsraikge1xuICAgICAgICAgICAgICAgIHJldFtqXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cblxudmFyIGF1dG9Fc2NhcGUgPSBbXCI8XCIsIFwiPlwiLCBcIlxcXCJcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLCBcIlxcblwiLFxuICAgIFwiXFx0XCIsIFwie1wiLCBcIn1cIiwgXCJ8XCIsIFwiXFxcXFwiLCBcIl5cIiwgXCJgXCIsIFwiJ1wiXTtcblxudmFyIGF1dG9Fc2NhcGVNYXAgPSBuZXcgQXJyYXkoMTI4KTtcblxuXG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXV0b0VzY2FwZU1hcFtpXSA9IFwiXCI7XG59XG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBhdXRvRXNjYXBlW2ldO1xuICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYyk7XG4gICAgaWYgKGVzYyA9PT0gYykge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYyk7XG4gICAgfVxuICAgIGF1dG9Fc2NhcGVNYXBbYy5jaGFyQ29kZUF0KDApXSA9IGVzYztcbn1cblxuXG52YXIgc2xhc2hQcm90b2NvbHMgPSBVcmwucHJvdG90eXBlLl9zbGFzaFByb3RvY29scyA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcblxuICAgIFwiaHR0cDpcIjogdHJ1ZSxcbiAgICBcImh0dHBzOlwiOiB0cnVlLFxuICAgIFwiZ29waGVyOlwiOiB0cnVlLFxuICAgIFwiZmlsZTpcIjogdHJ1ZSxcbiAgICBcImZ0cDpcIjogdHJ1ZVxufTtcblxuLy9PcHRpbWl6ZSBiYWNrIGZyb20gbm9ybWFsaXplZCBvYmplY3QgY2F1c2VkIGJ5IG5vbi1pZGVudGlmaWVyIGtleXNcbmZ1bmN0aW9uIGYoKXt9XG5mLnByb3RvdHlwZSA9IHNsYXNoUHJvdG9jb2xzO1xuXG5VcmwucHJvdG90eXBlLl9wcm90b2NvbENoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgWzB4NjEgLyonYScqLywgMHg3QSAvKid6JyovXSxcbiAgICBbMHg0MSAvKidBJyovLCAweDVBIC8qJ1onKi9dLFxuICAgIDB4MkUgLyonLicqLywgMHgyQiAvKicrJyovLCAweDJEIC8qJy0nKi9cbl0pO1xuXG5VcmwucHJvdG90eXBlLl9ob3N0RW5kaW5nQ2hhcmFjdGVycyA9IG1ha2VBc2NpaVRhYmxlKFtcbiAgICAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLywgMHgyRiAvKicvJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5fYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBhdXRvRXNjYXBlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cbi8vSWYgdGhlc2UgY2hhcmFjdGVycyBlbmQgYSBob3N0IG5hbWUsIHRoZSBwYXRoIHdpbGwgbm90IGJlIHByZXBlbmRlZCBhIC9cblVybC5wcm90b3R5cGUuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVycyA9IG1ha2VBc2NpaVRhYmxlKFxuICAgIFtcbiAgICAgICAgXCI8XCIsIFwiPlwiLCBcIidcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLFxuICAgICAgICBcIlxcblwiLCBcIlxcdFwiLCBcIntcIiwgXCJ9XCIsIFwifFwiLCBcIlxcXFxcIixcbiAgICAgICAgXCJeXCIsIFwiYFwiLCBcIlxcXCJcIiwgXCIlXCIsIFwiO1wiXG4gICAgXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jaGFyQ29kZUF0KDApO1xuICAgIH0pXG4pO1xuXG5VcmwucHJvdG90eXBlLl9hdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cblVybC5yZXBsYWNlID0gZnVuY3Rpb24gVXJsJFJlcGxhY2UoKSB7XG4gICAgcmVxdWlyZS5jYWNoZVtcInVybFwiXSA9IHtcbiAgICAgICAgZXhwb3J0czogVXJsXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoVG9SZWdFeHAgPSByZXF1aXJlKCcuL3BhdGhUb1JlZ0V4cCcpO1xuXG5mdW5jdGlvbiBtYXRjaCAocm91dGVzLCB1cmksIHN0YXJ0QXQpIHtcbiAgdmFyIGNhcHR1cmVzO1xuICB2YXIgaSA9IHN0YXJ0QXQgfHwgMDtcblxuICBmb3IgKHZhciBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgdmFyIHJlID0gcm91dGUucmU7XG4gICAgdmFyIGtleXMgPSByb3V0ZS5rZXlzO1xuICAgIHZhciBzcGxhdHMgPSBbXTtcbiAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICBpZiAoY2FwdHVyZXMgPSB1cmkubWF0Y2gocmUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMSwgbGVuID0gY2FwdHVyZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIGNhcHR1cmVzW2pdID09PSAnc3RyaW5nJyA/IHVuZXNjYXBlKGNhcHR1cmVzW2pdKSA6IGNhcHR1cmVzW2pdO1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tqIC0gMV07XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwbGF0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgc3BsYXRzOiBzcGxhdHMsXG4gICAgICAgIHJvdXRlOiByb3V0ZS5zcmMsXG4gICAgICAgIG5leHQ6IGkgKyAxLFxuICAgICAgICBpbmRleDogcm91dGUuaW5kZXhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlSW5mbyAocGF0aCwgaW5kZXgpIHtcbiAgdmFyIHNyYztcbiAgdmFyIHJlO1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmUgPSBwYXRoO1xuICAgIHNyYyA9IHBhdGgudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZSA9IHBhdGhUb1JlZ0V4cChwYXRoLCBrZXlzKTtcbiAgICBzcmMgPSBwYXRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAgcmU6IHJlLFxuICAgICBzcmM6IHBhdGgudG9TdHJpbmcoKSxcbiAgICAga2V5czoga2V5cyxcbiAgICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIFJvdXRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3V0ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZXIoKTtcbiAgfVxuXG4gIHRoaXMucm91dGVzID0gW107XG4gIHRoaXMucm91dGVNYXAgPSBbXTtcbn1cblxuUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZSA9IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24pIHtcbiAgaWYgKCFwYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcgcm91dGUgcmVxdWlyZXMgYSBwYXRoJyk7XG4gIH1cbiAgaWYgKCFhY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyByb3V0ZSAnICsgcGF0aC50b1N0cmluZygpICsgJyByZXF1aXJlcyBhbiBhY3Rpb24nKTtcbiAgfVxuXG4gIHZhciByb3V0ZSA9IHJvdXRlSW5mbyhwYXRoLCB0aGlzLnJvdXRlTWFwLmxlbmd0aCk7XG4gIHJvdXRlLmFjdGlvbiA9IGFjdGlvbjtcbiAgdGhpcy5yb3V0ZXMucHVzaChyb3V0ZSk7XG4gIHRoaXMucm91dGVNYXAucHVzaChbcGF0aCwgYWN0aW9uXSk7XG59XG5cblJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodXJpLCBzdGFydEF0KSB7XG4gIHZhciByb3V0ZSA9IG1hdGNoKHRoaXMucm91dGVzLCB1cmksIHN0YXJ0QXQpO1xuICBpZiAocm91dGUpIHtcbiAgICByb3V0ZS5hY3Rpb24gPSB0aGlzLnJvdXRlTWFwW3JvdXRlLmluZGV4XVsxXTtcbiAgICByb3V0ZS5uZXh0ID0gdGhpcy5tYXRjaC5iaW5kKHRoaXMsIHVyaSwgcm91dGUubmV4dCk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcGF0aFRvUmVnRXhwIChwYXRoLCBrZXlzKSB7XG4gIHBhdGggPSBwYXRoXG4gICAgLmNvbmNhdCgnLz8nKVxuICAgIC5yZXBsYWNlKC9cXC9cXCgvZywgJyg/Oi8nKVxuICAgIC5yZXBsYWNlKC8oXFwvKT8oXFwuKT86KFxcdyspKD86KFxcKC4qP1xcKSkpPyhcXD8pP3xcXCovZywgdHdlYWspXG4gICAgLnJlcGxhY2UoLyhbXFwvLl0pL2csICdcXFxcJDEnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJyguKiknKTtcblxuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgJyQnLCAnaScpO1xuXG4gIGZ1bmN0aW9uIHR3ZWFrIChtYXRjaCwgc2xhc2gsIGZvcm1hdCwga2V5LCBjYXB0dXJlLCBvcHRpb25hbCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyonKSB7XG4gICAgICBrZXlzLnB1c2godm9pZCAwKTtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2goa2V5KTtcblxuICAgIHNsYXNoID0gc2xhc2ggfHwgJyc7XG5cbiAgICByZXR1cm4gJydcbiAgICAgICsgKG9wdGlvbmFsID8gJycgOiBzbGFzaClcbiAgICAgICsgJyg/OidcbiAgICAgICsgKG9wdGlvbmFsID8gc2xhc2ggOiAnJylcbiAgICAgICsgKGZvcm1hdCB8fCAnJylcbiAgICAgICsgKGNhcHR1cmUgPyBjYXB0dXJlLnJlcGxhY2UoL1xcKi9nLCAnezAsfScpLnJlcGxhY2UoL1xcLi9nLCAnW1xcXFxzXFxcXFNdJykgOiAnKFteL10rPyknKVxuICAgICAgKyAnKSdcbiAgICAgICsgKG9wdGlvbmFsIHx8ICcnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ0V4cDtcbiIsInZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJ3BhcnNlLWhlYWRlcnMnKVxuXG52YXIgbWVzc2FnZXMgPSB7XG4gICAgXCIwXCI6IFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIixcbiAgICBcIjRcIjogXCI0eHggQ2xpZW50IEVycm9yXCIsXG4gICAgXCI1XCI6IFwiNXh4IFNlcnZlciBFcnJvclwiXG59XG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IFhEUigpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IFhIUigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIga2V5XG4gICAgdmFyIGxvYWQgPSBvcHRpb25zLnJlc3BvbnNlID8gbG9hZFJlc3BvbnNlIDogbG9hZFhoclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvclxuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIC8vIGhhdGUgSUVcbiAgICB4aHIub250aW1lb3V0ID0gbm9vcFxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCAob3B0aW9ucy5jb3JzICYmIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzICE9PSBmYWxzZSkpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBcInRpbWVvdXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50aW1lb3V0IDogNTAwMFxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cbiAgICBcbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiBcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gbnVsbFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgZ2V0dGluZyBhIG5vbmUtb2sgc3RhdHVzQ29kZSwgYnVpbGQgJiByZXR1cm4gYW4gZXJyb3JcbiAgICBmdW5jdGlvbiBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cywgYm9keSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDAgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBib2R5IDogZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbU3RyaW5nKHN0YXR1cykuY2hhckF0KDApXVxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvclxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkUmVzcG9uc2UoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMsIGJvZHkpXG4gICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJhdzogeGhyXG4gICAgICAgIH1cbiAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgYW5kIGFkZCBzb21lIHJlc3BvbnNlIHByb3BlcnRpZXMgdG8gdGhlIHNvdXJjZSB4aHJcbiAgICAvLyBhbmQgdGhlbiByZXNwb25kIHdpdGggdGhhdFxuICAgIGZ1bmN0aW9uIGxvYWRYaHIoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpXG5cbiAgICAgICAgeGhyLnN0YXR1cyA9IHhoci5zdGF0dXNDb2RlID0gc3RhdHVzXG4gICAgICAgIHhoci5ib2R5ID0gZ2V0Qm9keSgpXG4gICAgICAgIHhoci5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcblxuICAgICAgICBjYWxsYmFjayhlcnJvciwgeGhyLCB4aHIuYm9keSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihldnQpIHtcbiAgICAgICAgY2FsbGJhY2soZXZ0LCB4aHIpXG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iLCJtb2R1bGUuZXhwb3J0cz1cIjQuMC4wXCJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHQgPSByZXF1aXJlKCcuL3ZlcnNpb24uanNvbicpO1xuXG5mdW5jdGlvbiBnZXQgKHYpIHtcbiAgcmV0dXJuICd0JyArIHQgKyAnO3YnICsgdjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldDogZ2V0XG59O1xuIl19
